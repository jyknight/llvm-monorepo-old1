//===-- Driver.cpp ----------------------------------------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "Driver.h"

#ifdef _WIN32
#include "lldb/lldb-windows.h"
#include "lldb/lldb-private-log.h"
#include "lldb/Core/StreamCallback.h"
#include "lldb/Core/Log.h"
#endif
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <fcntl.h>

#include "IOChannel.h"
#include "lldb/API/SBBreakpoint.h"
#include "lldb/API/SBCommandInterpreter.h"
#include "lldb/API/SBCommandReturnObject.h"
#include "lldb/API/SBCommunication.h"
#include "lldb/API/SBDebugger.h"
#include "lldb/API/SBEvent.h"
#include "lldb/API/SBHostOS.h"
#include "lldb/API/SBListener.h"
#include "lldb/API/SBStream.h"
#include "lldb/API/SBTarget.h"
#include "lldb/API/SBThread.h"
#include "lldb/API/SBProcess.h"

using namespace lldb;

static void reset_stdin_termios ();

Driver::Driver () :
    SBBroadcaster ("Driver"),
    m_debugger (NULL),
    m_editline_pty (),
    m_editline_slave_fh (NULL),
    m_editline_reader (),
    m_io_channel_ap (),
    m_option_data (),
    m_waiting_for_command (false)
{
}

Driver::~Driver ()
{
}

const char *
Driver::GetFilename() const
{
    if (m_option_data.m_args.empty())
        return NULL;
    return m_option_data.m_args.front().c_str();
}

const char *
Driver::GetCrashLogFilename() const
{
    if (m_option_data.m_crash_log.empty())
        return NULL;
    return m_option_data.m_crash_log.c_str();
}

lldb::ScriptLanguage
Driver::GetScriptLanguage() const
{
    return m_option_data.m_script_lang;
}

size_t
Driver::GetNumSourceCommandFiles () const
{
    return m_option_data.m_source_command_files.size();
}

const char *
Driver::GetSourceCommandFileAtIndex (uint32_t idx) const
{
    if (idx < m_option_data.m_source_command_files.size())
        return m_option_data.m_source_command_files[idx].c_str();
    return NULL;
}

bool
Driver::GetDebugMode() const
{
    return m_option_data.m_debug_mode;
}

size_t
Driver::GetProcessSTDOUT ()
{
    //  The process has stuff waiting for stdout; get it and write it out to the appropriate place.
    char stdio_buffer[1024];
    size_t len;
    size_t total_bytes = 0;
    while ((len = m_debugger.GetSelectedTarget().GetProcess().GetSTDOUT (stdio_buffer, sizeof (stdio_buffer))) > 0)
    {
        m_io_channel_ap->OutWrite (stdio_buffer, len, ASYNC);
        total_bytes += len;
    }
    return total_bytes;
}

size_t
Driver::GetProcessSTDERR ()
{
    //  The process has stuff waiting for stderr; get it and write it out to the appropriate place.
    char stdio_buffer[1024];
    size_t len;
    size_t total_bytes = 0;
    while ((len = m_debugger.GetSelectedTarget().GetProcess().GetSTDERR (stdio_buffer, sizeof (stdio_buffer))) > 0)
    {
        m_io_channel_ap->ErrWrite (stdio_buffer, len, ASYNC);
        total_bytes += len;
    }
    return total_bytes;
}

void
Driver::UpdateSelectedThread ()
{
    using namespace lldb;
    SBProcess process(m_debugger.GetSelectedTarget().GetProcess());
    if (!process.IsValid())
        return;
    
    SBThread curr_thread (process.GetSelectedThread());
    SBThread thread;
    StopReason curr_thread_stop_reason = eStopReasonInvalid;
    curr_thread_stop_reason = curr_thread.GetStopReason();

    if (!curr_thread.IsValid() ||
        curr_thread_stop_reason == eStopReasonInvalid ||
        curr_thread_stop_reason == eStopReasonNone)
    {
        // Prefer a thread that has just completed its plan over another thread as current thread.
        SBThread plan_thread;
        SBThread other_thread;
       const size_t num_threads = process.GetNumThreads();
        size_t i;
        for (i = 0; i < num_threads; ++i)
        {
            thread = process.GetThreadAtIndex(i);
            StopReason thread_stop_reason = thread.GetStopReason();
            switch (thread_stop_reason)
			{
            default:
            case eStopReasonInvalid:
            case eStopReasonNone:
                break;

            case eStopReasonTrace:
            case eStopReasonBreakpoint:
            case eStopReasonWatchpoint:
            case eStopReasonSignal:
            case eStopReasonException:
                if (!other_thread.IsValid())
                    other_thread = thread;
                break;
            case eStopReasonPlanComplete:
                if (!plan_thread.IsValid())
                    plan_thread = thread;
                break;
            }
        }
        if (plan_thread.IsValid())
            process.SetSelectedThread (plan_thread);
        else if (other_thread.IsValid())
            process.SetSelectedThread (other_thread);
        else
		{
			if (curr_thread.IsValid())
				thread = curr_thread;
			else
				thread = process.GetThreadAtIndex(0);

<<<<<<< .working
			if (thread.IsValid())
				process.SetSelectedThread (thread);
=======
void
Driver::HandleThreadEvent (const SBEvent &event)
{
    // At present the only thread event we handle is the Frame Changed event, and all we do for that is just
    // reprint the thread status for that thread.
    using namespace lldb;
    const uint32_t event_type = event.GetType();
    if (event_type == SBThread::eBroadcastBitStackChanged)
    {
        SBThread thread = SBThread::GetThreadFromEvent (event);
        if (thread.IsValid())
        {
            SBStream out_stream;
            thread.GetStatus(out_stream);
            m_io_channel_ap->OutWrite (out_stream.GetData (), out_stream.GetSize (), ASYNC);
        }
    }
}

//  This function handles events broadcast by the IOChannel (HasInput, UserInterrupt, or ThreadShouldExit).

bool
Driver::HandleIOEvent (const SBEvent &event)
{
    bool quit = false;

    const uint32_t event_type = event.GetType();

    if (event_type & IOChannel::eBroadcastBitHasUserInput)
    {
        // We got some input (i.e. a command string) from the user; pass it off to the command interpreter for
        // handling.

        const char *command_string = SBEvent::GetCStringFromEvent(event);
        if (command_string == NULL)
            command_string = "";
        SBCommandReturnObject result;
        
        // We don't want the result to bypass the OutWrite function in IOChannel, as this can result in odd
        // output orderings and problems with the prompt.
        m_debugger.GetCommandInterpreter().HandleCommand (command_string, result, true);

        if (result.GetOutputSize() > 0)
            m_io_channel_ap->OutWrite (result.GetOutput(), result.GetOutputSize(), NO_ASYNC);
            
        if (result.GetErrorSize() > 0)
            m_io_channel_ap->OutWrite (result.GetError(), result.GetErrorSize(), NO_ASYNC);

        // We are done getting and running our command, we can now clear the
        // m_waiting_for_command so we can get another one.
        m_waiting_for_command = false;

        // If our editline input reader is active, it means another input reader
        // got pushed onto the input reader and caused us to become deactivated.
        // When the input reader above us gets popped, we will get re-activated
        // and our prompt will refresh in our callback
        if (m_editline_reader.IsActive())
        {
            ReadyForCommand ();
>>>>>>> .merge-right.r165938
        }
    }
}

void LogOutput(const char * msg, void *baton)
{
    puts(msg);
}

void Driver::Initialize()
{
    m_debugger = SBDebugger::Create(false, LogOutput, 0);
    // We want to be able to handle CTRL+D in the terminal to have it terminate
    // certain input
    m_debugger.SetCloseInputOnEOF (false);
    InitializePseudoTerminal();
 

    m_debugger.SetErrorFileHandle (stderr, false);
    m_debugger.SetOutputFileHandle (stdout, false);
    m_debugger.SetInputFileHandle (stdin, true);
 
    m_debugger.SetUseExternalEditor(m_option_data.m_use_external_editor);

    InitializeEditLineIO();	

	
    SBCommandInterpreter sb_interpreter = m_debugger.GetCommandInterpreter();
    m_interpreter = &sb_interpreter;

    SBListener listener(m_debugger.GetListener());
    listener.StartListeningForEventClass(m_debugger, 
                                         SBTarget::GetBroadcasterClassName(), 
                                         SBTarget::eBroadcastBitBreakpointChanged);
    if (!listener.IsValid())
        return;

    listener.StartListeningForEvents (*m_io_channel_ap,
                                        IOChannel::eBroadcastBitHasUserInput |
                                        IOChannel::eBroadcastBitUserInterrupt |
                                        IOChannel::eBroadcastBitThreadShouldExit |
                                        IOChannel::eBroadcastBitThreadDidStart |
                                        IOChannel::eBroadcastBitThreadDidExit);

    if (!m_io_channel_ap->Start ())
        return;
    
	iochannel_thread_exited = false;
	
    listener.StartListeningForEvents (sb_interpreter.GetBroadcaster(),
                                        SBCommandInterpreter::eBroadcastBitQuitCommandReceived |
                                        SBCommandInterpreter::eBroadcastBitAsynchronousOutputData |
                                        SBCommandInterpreter::eBroadcastBitAsynchronousErrorData);

    // Before we handle any options from the command line, we parse the
    // .lldbinit file in the user's home directory.
    SBCommandReturnObject result;
    sb_interpreter.SourceInitFileInHomeDirectory(result);

    if (GetDebugMode())
    {
        result.PutError (m_debugger.GetErrorFileHandle());
        result.PutOutput (m_debugger.GetOutputFileHandle());
    }
	HandleCommandLine(result);

    // Now that all option parsing is done, we try and parse the .lldbinit
    // file in the current working directory
    sb_interpreter.SourceInitFileInCurrentWorkingDirectory (result);
    if (GetDebugMode())	
    {
        result.PutError(m_debugger.GetErrorFileHandle());
        result.PutOutput(m_debugger.GetOutputFileHandle());
    }
	SBEvent event;
    // Make sure the IO channel is started up before we try to tell it we
    // are ready for input
    listener.WaitForEventForBroadcasterWithType (UINT32_MAX, 
                                                    *m_io_channel_ap,
                                                    IOChannel::eBroadcastBitThreadDidStart, 
                                                    event);
    
    // If we were asked to attach, then do that here:
    // I'm going to use the command string rather than directly
    // calling the API's because then I don't have to recode the
    // event handling here.
    if (!m_option_data.m_process_name.empty()
        || m_option_data.m_process_pid != LLDB_INVALID_PROCESS_ID)
    {
        AttachToProcess();
    }
    
    ReadyForCommand ();
}

<<<<<<< .working
void
Driver::MainLoop ()
{
    SBEvent event;
    while (!GetIsDone())
=======
    SBListener listener(m_debugger.GetListener());
    if (listener.IsValid())
>>>>>>> .merge-right.r165938
    {
<<<<<<< .working
        m_listener->WaitForEvent (UINT32_MAX, event);
        if (event.IsValid())
		{
            ProcessEvent(event);
        }
    }
	
	
    DestroyPseudoTerminal();
    CloseIOChannelFile ();
 
    if (!iochannel_thread_exited)
    {
	        event.Clear();
        m_listener->GetNextEventForBroadcasterWithType (*m_io_channel_ap,
                                                        IOChannel::eBroadcastBitThreadDidExit,
                                                        event);
        if (!event.IsValid())
=======

        listener.StartListeningForEventClass(m_debugger, 
                                         SBTarget::GetBroadcasterClassName(), 
                                         SBTarget::eBroadcastBitBreakpointChanged);
        listener.StartListeningForEventClass(m_debugger, 
                                         SBThread::GetBroadcasterClassName(),
                                         SBThread::eBroadcastBitStackChanged);
        listener.StartListeningForEvents (*m_io_channel_ap,
                                          IOChannel::eBroadcastBitHasUserInput |
                                          IOChannel::eBroadcastBitUserInterrupt |
                                          IOChannel::eBroadcastBitThreadShouldExit |
                                          IOChannel::eBroadcastBitThreadDidStart |
                                          IOChannel::eBroadcastBitThreadDidExit);

        if (m_io_channel_ap->Start ())
>>>>>>> .merge-right.r165938
        {
<<<<<<< .working
            // Send end EOF to the driver file descriptor
            m_io_channel_ap->Stop();
=======
            bool iochannel_thread_exited = false;

            listener.StartListeningForEvents (sb_interpreter.GetBroadcaster(),
                                              SBCommandInterpreter::eBroadcastBitQuitCommandReceived |
                                              SBCommandInterpreter::eBroadcastBitAsynchronousOutputData |
                                              SBCommandInterpreter::eBroadcastBitAsynchronousErrorData);

            // Before we handle any options from the command line, we parse the
            // .lldbinit file in the user's home directory.
            SBCommandReturnObject result;
            sb_interpreter.SourceInitFileInHomeDirectory(result);
            if (GetDebugMode())
            {
                result.PutError (m_debugger.GetErrorFileHandle());
                result.PutOutput (m_debugger.GetOutputFileHandle());
            }

            // Now we handle options we got from the command line
            char command_string[PATH_MAX * 2];
            const size_t num_source_command_files = GetNumSourceCommandFiles();
            if (num_source_command_files > 0)
            {
                for (size_t i=0; i < num_source_command_files; ++i)
                {
                    const char *command_file = GetSourceCommandFileAtIndex(i);
                    ::snprintf (command_string, sizeof(command_string), "command source '%s'", command_file);
                    m_debugger.GetCommandInterpreter().HandleCommand (command_string, result, false);
                    if (GetDebugMode())
                    {
                        result.PutError (m_debugger.GetErrorFileHandle());
                        result.PutOutput (m_debugger.GetOutputFileHandle());
                    }
                }
            }

            // Was there a core file specified?
            std::string core_file_spec("");
            if (!m_option_data.m_core_file.empty())
                core_file_spec.append("--core ").append(m_option_data.m_core_file);

            const size_t num_args = m_option_data.m_args.size();
            if (num_args > 0)
            {
                char arch_name[64];
                if (m_debugger.GetDefaultArchitecture (arch_name, sizeof (arch_name)))
                    ::snprintf (command_string, 
                                sizeof (command_string), 
                                "target create --arch=%s %s \"%s\"", 
                                arch_name,
                                core_file_spec.c_str(),
                                m_option_data.m_args[0].c_str());
                else
                    ::snprintf (command_string, 
                                sizeof(command_string), 
                                "target create %s \"%s\"", 
                                core_file_spec.c_str(),
                                m_option_data.m_args[0].c_str());

                m_debugger.HandleCommand (command_string);
                
                if (num_args > 1)
                {
                    m_debugger.HandleCommand ("settings clear target.run-args");
                    char arg_cstr[1024];
                    for (size_t arg_idx = 1; arg_idx < num_args; ++arg_idx)
                    {
                        ::snprintf (arg_cstr, 
                                    sizeof(arg_cstr), 
                                    "settings append target.run-args \"%s\"", 
                                    m_option_data.m_args[arg_idx].c_str());
                        m_debugger.HandleCommand (arg_cstr);
                    }
                }
            }
            else if (!core_file_spec.empty())
            {
                ::snprintf (command_string, 
                            sizeof(command_string), 
                            "target create %s", 
                            core_file_spec.c_str());
                m_debugger.HandleCommand (command_string);;
            }

            // Now that all option parsing is done, we try and parse the .lldbinit
            // file in the current working directory
            sb_interpreter.SourceInitFileInCurrentWorkingDirectory (result);
            if (GetDebugMode())
            {
                result.PutError(m_debugger.GetErrorFileHandle());
                result.PutOutput(m_debugger.GetOutputFileHandle());
            }

            SBEvent event;

            // Make sure the IO channel is started up before we try to tell it we
            // are ready for input
            listener.WaitForEventForBroadcasterWithType (UINT32_MAX, 
                                                         *m_io_channel_ap,
                                                         IOChannel::eBroadcastBitThreadDidStart, 
                                                         event);
            // If we were asked to attach, then do that here:
            // I'm going to use the command string rather than directly
            // calling the API's because then I don't have to recode the
            // event handling here.
            if (!m_option_data.m_process_name.empty()
                || m_option_data.m_process_pid != LLDB_INVALID_PROCESS_ID)
            {
                std::string command_str("process attach ");
                if (m_option_data.m_process_pid != LLDB_INVALID_PROCESS_ID)
                {
                    command_str.append("-p ");
                    char pid_buffer[32];
                    ::snprintf (pid_buffer, sizeof(pid_buffer), "%llu", m_option_data.m_process_pid);
                    command_str.append(pid_buffer);
                }
                else 
                {
                    command_str.append("-n \"");
                    command_str.append(m_option_data.m_process_name);
                    command_str.push_back('\"');
                    if (m_option_data.m_wait_for)
                        command_str.append(" -w");
                }
                
                if (m_debugger.GetOutputFileHandle())
                    ::fprintf (m_debugger.GetOutputFileHandle(), 
                               "Attaching to process with:\n    %s\n", 
                               command_str.c_str());
                                               
                // Force the attach to be synchronous:
                bool orig_async = m_debugger.GetAsync();
                m_debugger.SetAsync(true);
                m_debugger.HandleCommand(command_str.c_str());
                m_debugger.SetAsync(orig_async);                
            }
                        
            ReadyForCommand ();

            while (!GetIsDone())
            {
                listener.WaitForEvent (UINT32_MAX, event);
                if (event.IsValid())
                {
                    if (event.GetBroadcaster().IsValid())
                    {
                        uint32_t event_type = event.GetType();
                        if (event.BroadcasterMatchesRef (*m_io_channel_ap))
                        {
                            if ((event_type & IOChannel::eBroadcastBitThreadShouldExit) ||
                                (event_type & IOChannel::eBroadcastBitThreadDidExit))
                            {
                                SetIsDone();
                                if (event_type & IOChannel::eBroadcastBitThreadDidExit)
                                    iochannel_thread_exited = true;
                            }
                            else
                            {
                                if (HandleIOEvent (event))
                                    SetIsDone();
                            }
                        }
                        else if (SBProcess::EventIsProcessEvent (event))
                        {
                            HandleProcessEvent (event);
                        }
                        else if (SBBreakpoint::EventIsBreakpointEvent (event))
                        {
                            HandleBreakpointEvent (event);
                        }
                        else if (SBThread::EventIsThreadEvent (event))
                        {
                            HandleThreadEvent (event);
                        }
                        else if (event.BroadcasterMatchesRef (sb_interpreter.GetBroadcaster()))
                        {
                            // TODO: deprecate the eBroadcastBitQuitCommandReceived event
                            // now that we have SBCommandInterpreter::SetCommandOverrideCallback()
                            // that can take over a command
                            if (event_type & SBCommandInterpreter::eBroadcastBitQuitCommandReceived)
                            {
                                SetIsDone();
                            }
                            else if (event_type & SBCommandInterpreter::eBroadcastBitAsynchronousErrorData)
                            {
                                const char *data = SBEvent::GetCStringFromEvent (event);
                                m_io_channel_ap->ErrWrite (data, strlen(data), ASYNC);
                            }
                            else if (event_type & SBCommandInterpreter::eBroadcastBitAsynchronousOutputData)
                            {
                                const char *data = SBEvent::GetCStringFromEvent (event);
                                m_io_channel_ap->OutWrite (data, strlen(data), ASYNC);
                            }
                        }
                    }
                }
            }

            editline_output_pty.CloseMasterFileDescriptor();
            master_out_comm.Disconnect();
            out_comm_2.Disconnect();
            reset_stdin_termios();
            fclose (stdin);

            CloseIOChannelFile ();

            if (!iochannel_thread_exited)
            {
                event.Clear();
                listener.GetNextEventForBroadcasterWithType (*m_io_channel_ap,
                                                             IOChannel::eBroadcastBitThreadDidExit,
                                                             event);
                if (!event.IsValid())
                {
                    // Send end EOF to the driver file descriptor
                    m_io_channel_ap->Stop();
                }
            }

            SBDebugger::Destroy (m_debugger);
>>>>>>> .merge-right.r165938
        }
    }
	SBDebugger::Destroy (m_debugger);
}


void
Driver::ReadyForCommand ()
{
    if (m_waiting_for_command == false)
    {
        m_waiting_for_command = true;
        BroadcastEventByType (Driver::eBroadcastBitReadyForInput, true);
    }
}

// defined in DriverPosix.cpp
void SetupPosixSignals();

int
main (int argc, char const *argv[], const char *envp[])
{
#if 1 // Enable for debug logging
    lldb::StreamSP logStream(new lldb_private::StreamCallback(LogOutput, 0));
    const char* logCategories[] = { 0 };
    lldb::LogSP log = lldb_private::EnableLog(logStream, 0, logCategories, 0);
    log->GetMask().Reset(LIBLLDB_LOG_ALL);
#endif
    SBDebugger::Initialize();
    
    SBHostOS::ThreadCreated ("<lldb.driver.main-thread>");

	SetupPosixSignals();
    // Create a scope for driver so that the driver object will destroy itself
    // before SBDebugger::Terminate() is called.
    {
        Driver driver;

        bool exit = false;
        SBError error = driver.ParseArgs (argc, argv, stdout, exit);
        if (error.Fail())
        {
            const char *error_cstr = error.GetCString ();
            if (error_cstr)
                ::fprintf (stderr, "error: %s\n", error_cstr);
        }
        else if (!exit)
        {
            driver.Initialize();
        }
    }

    SBDebugger::Terminate();
    return 0;
}
