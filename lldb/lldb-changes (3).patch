Index: .
===================================================================
--- .	(revision 163322)
+++ .	(working copy)

Property changes on: .
___________________________________________________________________
Added: svn:ignore
## -0,0 +1 ##
+build
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 0)
+++ CMakeLists.txt	(working copy)
@@ -0,0 +1,158 @@
+# If we are not building as a part of LLVM, build LLDB as an
+# standalone project, using LLVM as an external library:
+if (CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)
+  project(lldb)
+  cmake_minimum_required(VERSION 2.8)
+
+  set(LLDB_PATH_TO_LLVM_SOURCE "" CACHE PATH
+    "Path to LLVM source code. Not necessary if using an installed LLVM.")
+  set(LLDB_PATH_TO_LLVM_BUILD "" CACHE PATH
+    "Path to the directory where LLVM was built or installed.")
+    
+  set(LLDB_PATH_TO_CLANG_SOURCE "" CACHE PATH
+    "Path to Clang source code. Not necessary if using an installed Clang.")
+  set(LLDB_PATH_TO_CLANG_BUILD "" CACHE PATH
+    "Path to the directory where Clang was built or installed.")    
+
+  set(LLDB_DISABLE_PYTHON 1 BOOL "Disables the Python scripting integration.")
+
+  if (LLDB_PATH_TO_LLVM_SOURCE)
+    if (NOT EXISTS "${LLDB_PATH_TO_LLVM_SOURCE}/cmake/config-ix.cmake")
+      message(FATAL_ERROR "Please set LLDB_PATH_TO_LLVM_SOURCE to the root "
+              "directory of LLVM source code.")
+    else()
+      get_filename_component(LLVM_MAIN_SRC_DIR ${LLDB_PATH_TO_LLVM_SOURCE}
+                             ABSOLUTE)
+      list(APPEND CMAKE_MODULE_PATH "${LLVM_MAIN_SRC_DIR}/cmake/modules")
+    endif()
+  endif()
+  
+  if (LLDB_PATH_TO_CLANG_SOURCE)
+      get_filename_component(CLANG_MAIN_SRC_DIR ${LLDB_PATH_TO_CLANG_SOURCE}
+                             ABSOLUTE)
+  endif()  
+
+  list(APPEND CMAKE_MODULE_PATH "${LLDB_PATH_TO_LLVM_BUILD}/share/llvm/cmake")
+
+  get_filename_component(PATH_TO_LLVM_BUILD ${LLDB_PATH_TO_LLVM_BUILD}
+                         ABSOLUTE)
+                         
+  get_filename_component(PATH_TO_CLANG_BUILD ${LLDB_PATH_TO_CLANG_BUILD}
+                         ABSOLUTE)                         
+                         
+  include(AddLLVM)
+  include("${LLDB_PATH_TO_LLVM_BUILD}/share/llvm/cmake/LLVMConfig.cmake")
+  include(HandleLLVMOptions)
+
+  set(PACKAGE_VERSION "${LLVM_PACKAGE_VERSION}")
+
+  set(LLVM_MAIN_INCLUDE_DIR "${LLVM_MAIN_SRC_DIR}/include")
+  set(LLVM_BINARY_DIR ${CMAKE_BINARY_DIR})
+  
+  set(CLANG_MAIN_INCLUDE_DIR "${CLANG_MAIN_SRC_DIR}/include")
+
+  set(CMAKE_INCLUDE_CURRENT_DIR ON)
+  include_directories("${PATH_TO_LLVM_BUILD}/include"
+                      "${LLVM_MAIN_INCLUDE_DIR}"
+                      "${PATH_TO_CLANG_BUILD}/include"
+                      "${CLANG_MAIN_INCLUDE_DIR}"
+                      "${CMAKE_CURRENT_SOURCE_DIR}/source")
+  link_directories("${PATH_TO_LLVM_BUILD}/lib")
+
+  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
+  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
+  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
+
+  set(LLDB_BUILT_STANDALONE 1)
+  
+  if (LLDB_DISABLE_PYTHON)
+    add_definitions( -DLLDB_DISABLE_PYTHON )
+  endif() 
+endif()
+
+macro(add_lldb_definitions)
+  # We don't want no semicolons on LLDB_DEFINITIONS:
+  foreach(arg ${ARGN})
+    set(LLDB_DEFINITIONS "${LLVM_DEFINITIONS} ${arg}")
+  endforeach(arg)
+  add_definitions( ${ARGN} )
+endmacro(add_lldb_definitions)
+
+# Disable MSVC warnings
+if( MSVC )
+  add_lldb_definitions(
+    -wd4018 # Suppress 'warning C4018: '>=' : signed/unsigned mismatch'
+    -wd4068 # Suppress 'warning C4068: unknown pragma'
+    -wd4150 # Suppress 'warning C4150: deletion of pointer to incomplete type'
+    -wd4521 # Suppress 'warning C4521: 'type' : multiple copy constructors specified'
+  )
+endif() 
+
+set(LLDB_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR})
+set(LLDB_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR})
+
+if (CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
+  message(FATAL_ERROR "In-source builds are not allowed. CMake would overwrite "
+"the makefiles distributed with LLDB. Please create a directory and run cmake "
+"from there, passing the path to this source directory as the last argument. "
+"This process created the file `CMakeCache.txt' and the directory "
+"`CMakeFiles'. Please delete them.")
+endif()
+
+macro(add_lldb_library name)
+  llvm_process_sources(srcs ${ARGN})
+  if (MSVC_IDE OR XCODE)
+    string(REGEX MATCHALL "/[^/]+" split_path ${CMAKE_CURRENT_SOURCE_DIR})
+    list(GET split_path -1 dir)
+    file(GLOB_RECURSE headers
+      ../../include/lldb${dir}/*.h)
+    set(srcs ${srcs} ${headers})
+  endif()
+  if (MODULE)
+    set(libkind MODULE)
+  elseif (SHARED_LIBRARY)
+    set(libkind SHARED)
+  else()
+    set(libkind)
+  endif()
+  add_library(${name} ${libkind} ${srcs})
+  if (LLVM_COMMON_DEPENDS)
+    add_dependencies(${name} ${LLVM_COMMON_DEPENDS})
+  endif()
+
+  target_link_libraries(${name} ${LLVM_USED_LIBS})
+  llvm_config(${name} ${LLVM_LINK_COMPONENTS})
+  target_link_libraries(${name} ${LLVM_COMMON_LIBS})
+  #target_link_libraries(${name} ${CLANG_USED_LIBS})
+  link_system_libs(${name})
+
+  install(TARGETS ${name}
+    LIBRARY DESTINATION lib${LLVM_LIBDIR_SUFFIX}
+    ARCHIVE DESTINATION lib${LLVM_LIBDIR_SUFFIX})
+  set_target_properties(${name} PROPERTIES FOLDER "lldb libraries")
+endmacro(add_lldb_library)
+
+macro(add_lldb_executable name)
+  add_llvm_executable(${name} ${ARGN})
+  target_link_libraries(${name} ${LLDB_USED_LIBS})
+  target_link_libraries(${name} ${CLANG_USED_LIBS})
+  set_target_properties(${name} PROPERTIES FOLDER "lldb executables")
+endmacro(add_lldb_executable)
+
+include_directories(BEFORE
+  ${CMAKE_CURRENT_BINARY_DIR}/include
+  ${CMAKE_CURRENT_SOURCE_DIR}/include
+  )
+
+install(DIRECTORY include/
+  DESTINATION include
+  FILES_MATCHING
+  PATTERN "*.h"
+  PATTERN ".svn" EXCLUDE
+  )
+
+#add_subdirectory(include)
+#add_subdirectory(scripts)
+add_subdirectory(source)
+#add_subdirectory(test)
+add_subdirectory(tools)
Index: include/dirent.h
===================================================================
--- include/dirent.h	(revision 0)
+++ include/dirent.h	(working copy)
@@ -0,0 +1,395 @@
+/*****************************************************************************
+ * dirent.h - dirent API for Microsoft Visual Studio
+ *
+ * Copyright (C) 2006 Toni Ronkko
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * ``Software''), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL TONI RONKKO BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Aug 11, 2010, Toni Ronkko
+ * Added d_type and d_namlen fields to dirent structure.  The former is
+ * especially useful for determining whether directory entry represents a
+ * file or a directory.  For more information, see
+ * http://www.delorie.com/gnu/docs/glibc/libc_270.html
+ *
+ * Aug 11, 2010, Toni Ronkko
+ * Improved conformance to the standards.  For example, errno is now set
+ * properly on failure and assert() is never used.  Thanks to Peter Brockam
+ * for suggestions.
+ *
+ * Aug 11, 2010, Toni Ronkko
+ * Fixed a bug in rewinddir(): when using relative directory names, change
+ * of working directory no longer causes rewinddir() to fail.
+ *
+ * Dec 15, 2009, John Cunningham
+ * Added rewinddir member function
+ *
+ * Jan 18, 2008, Toni Ronkko
+ * Using FindFirstFileA and WIN32_FIND_DATAA to avoid converting string
+ * between multi-byte and unicode representations.  This makes the
+ * code simpler and also allows the code to be compiled under MingW.  Thanks
+ * to Azriel Fasten for the suggestion.
+ *
+ * Mar 4, 2007, Toni Ronkko
+ * Bug fix: due to the strncpy_s() function this file only compiled in
+ * Visual Studio 2005.  Using the new string functions only when the
+ * compiler version allows.
+ *
+ * Nov  2, 2006, Toni Ronkko
+ * Major update: removed support for Watcom C, MS-DOS and Turbo C to
+ * simplify the file, updated the code to compile cleanly on Visual
+ * Studio 2005 with both unicode and multi-byte character strings,
+ * removed rewinddir() as it had a bug.
+ *
+ * Aug 20, 2006, Toni Ronkko
+ * Removed all remarks about MSVC 1.0, which is antiqued now.  Simplified
+ * comments by removing SGML tags.
+ *
+ * May 14 2002, Toni Ronkko
+ * Embedded the function definitions directly to the header so that no
+ * source modules need to be included in the Visual Studio project.  Removed
+ * all the dependencies to other projects so that this very header can be
+ * used independently.
+ *
+ * May 28 1998, Toni Ronkko
+ * First version.
+ *****************************************************************************/
+#ifndef DIRENT_H
+#define DIRENT_H
+
+#define NOMINMAX
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+
+/* File type and permission flags for stat() */
+#if defined(_MSC_VER)  &&  !defined(S_IREAD)
+# define S_IFMT   _S_IFMT                      /* file type mask */
+# define S_IFDIR  _S_IFDIR                     /* directory */
+# define S_IFCHR  _S_IFCHR                     /* character device */
+# define S_IFFIFO _S_IFFIFO                    /* pipe */
+# define S_IFREG  _S_IFREG                     /* regular file */
+# define S_IREAD  _S_IREAD                     /* read permission */
+# define S_IWRITE _S_IWRITE                    /* write permission */
+# define S_IEXEC  _S_IEXEC                     /* execute permission */
+#endif
+
+#ifndef S_IFBLK
+#define S_IFBLK   0060000                            /* block device */
+#endif
+
+#ifndef S_IFLNK
+#define S_IFLNK   0120000                            /* link */
+#endif
+
+#ifndef S_IFSOCK
+#define S_IFSOCK  0140000                            /* socket */
+#endif
+
+#ifndef S_IFIFO
+#define S_IFIFO   0010000                            /* fifo */
+#endif
+
+#if defined(_MSC_VER)
+# define S_IRUSR  S_IREAD                      /* read, user */
+# define S_IWUSR  S_IWRITE                     /* write, user */
+# define S_IXUSR  0                            /* execute, user */
+# define S_IRGRP  0                            /* read, group */
+# define S_IWGRP  0                            /* write, group */
+# define S_IXGRP  0                            /* execute, group */
+# define S_IROTH  0                            /* read, others */
+# define S_IWOTH  0                            /* write, others */
+# define S_IXOTH  0                            /* execute, others */
+#endif
+
+/* Indicates that d_type field is available in dirent structure */
+#define _DIRENT_HAVE_D_TYPE
+
+/* File type flags for d_type */
+#define DT_UNKNOWN  0
+#define DT_REG      S_IFREG
+#define DT_DIR      S_IFDIR
+#define DT_FIFO     S_IFIFO
+#define DT_SOCK     S_IFSOCK
+#define DT_CHR      S_IFCHR
+#define DT_BLK      S_IFBLK
+#define DT_LNK      S_IFLNK
+
+/* Macros for converting between st_mode and d_type */
+#define IFTODT(mode) ((mode) & S_IFMT)
+#define DTTOIF(type) (type)
+
+/*
+ * File type macros.  Note that block devices, sockets and links cannot be
+ * distinguished on Windows and the macros S_ISBLK, S_ISSOCK and S_ISLNK are
+ * only defined for compatibility.  These macros should always return false
+ * on Windows.
+ */
+ 
+#ifndef S_ISFIFO
+#define	S_ISFIFO(mode) (((mode) & S_IFMT) == S_IFFIFO)
+#endif
+
+#ifndef S_ISDIR
+#define	S_ISDIR(mode)  (((mode) & S_IFMT) == S_IFDIR)
+#endif
+
+#ifndef S_ISREG
+#define	S_ISREG(mode)  (((mode) & S_IFMT) == S_IFREG)
+#endif
+
+#define	S_ISLNK(mode)  (((mode) & S_IFMT) == S_IFLNK)
+#define	S_ISSOCK(mode) (((mode) & S_IFMT) == S_IFSOCK)
+
+#ifndef S_ISCHR
+#define	S_ISCHR(mode)  (((mode) & S_IFMT) == S_IFCHR)
+#endif
+
+#ifndef S_ISBLK
+#define	S_ISBLK(mode)  (((mode) & S_IFMT) == S_IFBLK)
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+typedef struct dirent
+{
+   char d_name[MAX_PATH + 1];                  /* File name */
+   size_t d_namlen;                            /* Length of name without \0 */
+   int d_type;                                 /* File type */
+} dirent;
+
+
+typedef struct DIR
+{
+   dirent           curentry;                  /* Current directory entry */
+   WIN32_FIND_DATAA find_data;                 /* Private file data */
+   int              cached;                    /* True if data is valid */
+   HANDLE           search_handle;             /* Win32 search handle */
+   char             patt[MAX_PATH + 3];        /* Initial directory name */
+} DIR;
+
+
+/* Forward declarations */
+static DIR *opendir(const char *dirname);
+static struct dirent *readdir(DIR *dirp);
+static int closedir(DIR *dirp);
+static void rewinddir(DIR* dirp);
+
+
+/* Use the new safe string functions introduced in Visual Studio 2005 */
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+# define DIRENT_STRNCPY(dest,src,size) strncpy_s((dest),(size),(src),_TRUNCATE)
+#else
+# define DIRENT_STRNCPY(dest,src,size) strncpy((dest),(src),(size))
+#endif
+
+/* Set errno variable */
+#if defined(_MSC_VER)
+#define DIRENT_SET_ERRNO(x) _set_errno (x)
+#else
+#define DIRENT_SET_ERRNO(x) (errno = (x))
+#endif
+
+
+/*****************************************************************************
+ * Open directory stream DIRNAME for read and return a pointer to the
+ * internal working area that is used to retrieve individual directory
+ * entries.
+ */
+static DIR *opendir(const char *dirname)
+{
+   DIR *dirp;
+
+   /* ensure that the resulting search pattern will be a valid file name */
+   if (dirname == NULL) {
+      DIRENT_SET_ERRNO (ENOENT);
+      return NULL;
+   }
+   if (strlen (dirname) + 3 >= MAX_PATH) {
+      DIRENT_SET_ERRNO (ENAMETOOLONG);
+      return NULL;
+   }
+
+   /* construct new DIR structure */
+   dirp = (DIR*) malloc (sizeof (struct DIR));
+   if (dirp != NULL) {
+      int error;
+
+      /*
+       * Convert relative directory name to an absolute directory one.  This
+       * allows rewinddir() to function correctly when the current working
+       * directory is changed between opendir() and rewinddir().
+       */
+      if (GetFullPathNameA (dirname, MAX_PATH, dirp->patt, NULL)) {
+         char *p;
+
+         /* append the search pattern "\\*\0" to the directory name */
+         p = strchr (dirp->patt, '\0');
+         if (dirp->patt < p  &&  *(p-1) != '\\'  &&  *(p-1) != ':') {
+           *p++ = '\\';
+         }
+         *p++ = '*';
+         *p = '\0';
+
+         /* open directory stream and retrieve the first entry */
+         dirp->search_handle = FindFirstFileA (dirp->patt, &dirp->find_data);
+         if (dirp->search_handle != INVALID_HANDLE_VALUE) {
+            /* a directory entry is now waiting in memory */
+            dirp->cached = 1;
+            error = 0;
+         } else {
+            /* search pattern is not a directory name? */
+            DIRENT_SET_ERRNO (ENOENT);
+            error = 1;
+         }
+      } else {
+         /* buffer too small */
+         DIRENT_SET_ERRNO (ENOMEM);
+         error = 1;
+      }
+
+      if (error) {
+         free (dirp);
+         dirp = NULL;
+      }
+   }
+
+   return dirp;
+}
+
+
+/*****************************************************************************
+ * Read a directory entry, and return a pointer to a dirent structure
+ * containing the name of the entry in d_name field.  Individual directory
+ * entries returned by this very function include regular files,
+ * sub-directories, pseudo-directories "." and "..", but also volume labels,
+ * hidden files and system files may be returned.
+ */
+static struct dirent *readdir(DIR *dirp)
+{
+   DWORD attr;
+   if (dirp == NULL) {
+      /* directory stream did not open */
+      DIRENT_SET_ERRNO (EBADF);
+      return NULL;
+   }
+
+   /* get next directory entry */
+   if (dirp->cached != 0) {
+      /* a valid directory entry already in memory */
+      dirp->cached = 0;
+   } else {
+      /* get the next directory entry from stream */
+      if (dirp->search_handle == INVALID_HANDLE_VALUE) {
+         return NULL;
+      }
+      if (FindNextFileA (dirp->search_handle, &dirp->find_data) == FALSE) {
+         /* the very last entry has been processed or an error occured */
+         FindClose (dirp->search_handle);
+         dirp->search_handle = INVALID_HANDLE_VALUE;
+         return NULL;
+      }
+   }
+
+   /* copy as a multibyte character string */
+   DIRENT_STRNCPY ( dirp->curentry.d_name,
+             dirp->find_data.cFileName,
+             sizeof(dirp->curentry.d_name) );
+   dirp->curentry.d_name[MAX_PATH] = '\0';
+
+   /* compute the length of name */
+   dirp->curentry.d_namlen = strlen (dirp->curentry.d_name);
+
+   /* determine file type */
+   attr = dirp->find_data.dwFileAttributes;
+   if ((attr & FILE_ATTRIBUTE_DEVICE) != 0) {
+      dirp->curentry.d_type = DT_CHR;
+   } else if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0) {
+      dirp->curentry.d_type = DT_DIR;
+   } else {
+      dirp->curentry.d_type = DT_REG;
+   }
+   return &dirp->curentry;
+}
+
+
+/*****************************************************************************
+ * Close directory stream opened by opendir() function.  Close of the
+ * directory stream invalidates the DIR structure as well as any previously
+ * read directory entry.
+ */
+static int closedir(DIR *dirp)
+{
+   if (dirp == NULL) {
+      /* invalid directory stream */
+      DIRENT_SET_ERRNO (EBADF);
+      return -1;
+   }
+
+   /* release search handle */
+   if (dirp->search_handle != INVALID_HANDLE_VALUE) {
+      FindClose (dirp->search_handle);
+      dirp->search_handle = INVALID_HANDLE_VALUE;
+   }
+
+   /* release directory structure */
+   free (dirp);
+   return 0;
+}
+
+
+/*****************************************************************************
+ * Resets the position of the directory stream to which dirp refers to the
+ * beginning of the directory.  It also causes the directory stream to refer
+ * to the current state of the corresponding directory, as a call to opendir()
+ * would have done.  If dirp does not refer to a directory stream, the effect
+ * is undefined.
+ */
+static void rewinddir(DIR* dirp)
+{
+   if (dirp != NULL) {
+      /* release search handle */
+      if (dirp->search_handle != INVALID_HANDLE_VALUE) {
+         FindClose (dirp->search_handle);
+      }
+
+      /* open new search handle and retrieve the first entry */
+      dirp->search_handle = FindFirstFileA (dirp->patt, &dirp->find_data);
+      if (dirp->search_handle != INVALID_HANDLE_VALUE) {
+         /* a directory entry is now waiting in memory */
+         dirp->cached = 1;
+      } else {
+         /* failed to re-open directory: no directory entry in memory */
+         dirp->cached = 0;
+      }
+   }
+}
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /*DIRENT_H*/
Index: include/lldb/API/SBCommandReturnObject.h
===================================================================
--- include/lldb/API/SBCommandReturnObject.h	(revision 163322)
+++ include/lldb/API/SBCommandReturnObject.h	(working copy)
@@ -87,7 +87,7 @@
     PutCString(const char* string, int len = -1);
     
     size_t
-    Printf(const char* format, ...)  __attribute__ ((format (printf, 2, 3)));
+    Printf(const char* format, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
     
 protected:
     friend class SBCommandInterpreter;
Index: include/lldb/API/SBError.h
===================================================================
--- include/lldb/API/SBError.h	(revision 163322)
+++ include/lldb/API/SBError.h	(working copy)
@@ -56,7 +56,7 @@
     SetErrorString (const char *err_str);
 
     int
-    SetErrorStringWithFormat (const char *format, ...) __attribute__ ((format (printf, 2, 3)));
+    SetErrorStringWithFormat (const char *format, ...) LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     bool
     IsValid () const;
Index: include/lldb/API/SBHostOS.h
===================================================================
--- include/lldb/API/SBHostOS.h	(revision 163322)
+++ include/lldb/API/SBHostOS.h	(working copy)
@@ -27,7 +27,7 @@
 
     static lldb::thread_t
     ThreadCreate (const char *name,
-                  void *(*thread_function)(void *),
+                  thread_func_t thread_function,
                   void *thread_arg,
                   lldb::SBError *err);
 
@@ -40,7 +40,7 @@
                   lldb::SBError *err);
     static bool
     ThreadJoin (lldb::thread_t thread,
-                void **result,
+                thread_result_t *result,
                 lldb::SBError *err);
 
 
Index: include/lldb/API/SBStream.h
===================================================================
--- include/lldb/API/SBStream.h	(revision 163322)
+++ include/lldb/API/SBStream.h	(working copy)
@@ -39,7 +39,7 @@
     GetSize();
 
     void
-    Printf (const char *format, ...)  __attribute__ ((format (printf, 2, 3)));
+    Printf (const char *format, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     void
     RedirectToFile (const char *path, bool append);
Index: include/lldb/Breakpoint/BreakpointLocation.h
===================================================================
--- include/lldb/Breakpoint/BreakpointLocation.h	(revision 163322)
+++ include/lldb/Breakpoint/BreakpointLocation.h	(working copy)
@@ -320,7 +320,7 @@
 
 protected:
     friend class BreakpointLocationList;
-    friend class CommandObjectBreakpointCommandAdd;
+    //friend class CommandObjectBreakpointCommandAdd;
     friend class Process;
 
     //------------------------------------------------------------------
Index: include/lldb/Core/ConnectionFileDescriptor.h
===================================================================
--- include/lldb/Core/ConnectionFileDescriptor.h	(revision 163322)
+++ include/lldb/Core/ConnectionFileDescriptor.h	(working copy)
@@ -11,9 +11,11 @@
 #define liblldb_ConnectionFileDescriptor_h_
 
 // C Includes
+#ifdef _POSIX_SOURCE
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <netinet/in.h>
+#endif
 
 // C++ Includes
 // Other libraries and framework includes
Index: include/lldb/Core/CXXFormatterFunctions.h
===================================================================
--- include/lldb/Core/CXXFormatterFunctions.h	(revision 163322)
+++ include/lldb/Core/CXXFormatterFunctions.h	(working copy)
@@ -11,6 +11,9 @@
 #define liblldb_CXXFormatterFunctions_h_
 
 #include "lldb/lldb-forward.h"
+#ifdef _MSC_VER
+typedef unsigned __int64 uint64_t;
+#endif
 
 namespace lldb_private {
     namespace formatters
@@ -39,16 +42,16 @@
         bool
         NSString_SummaryProvider (ValueObject& valobj, Stream& stream);
         
-        extern template bool
+        template bool
         NSDictionary_SummaryProvider<true> (ValueObject&, Stream&) ;
         
-        extern template bool
+        template bool
         NSDictionary_SummaryProvider<false> (ValueObject&, Stream&) ;
         
-        extern template bool
+        template bool
         NSData_SummaryProvider<true> (ValueObject&, Stream&) ;
         
-        extern template bool
+        template bool
         NSData_SummaryProvider<false> (ValueObject&, Stream&) ;
         
     }
Index: include/lldb/Core/Debugger.h
===================================================================
--- include/lldb/Core/Debugger.h	(revision 163322)
+++ include/lldb/Core/Debugger.h	(working copy)
@@ -13,7 +13,6 @@
 
 
 #include <stdint.h>
-#include <unistd.h>
 
 #include <stack>
 
Index: include/lldb/Core/dwarf.h
===================================================================
--- include/lldb/Core/dwarf.h	(revision 163322)
+++ include/lldb/Core/dwarf.h	(working copy)
@@ -11,7 +11,6 @@
 #define DebugBase_dwarf_h_
 
 #include <stdint.h>
-#include <stdbool.h>
 
 // Get the DWARF constant defintions from llvm
 #include "llvm/Support/Dwarf.h"
Index: include/lldb/Core/Error.h
===================================================================
--- include/lldb/Core/Error.h	(revision 163322)
+++ include/lldb/Core/Error.h	(working copy)
@@ -175,7 +175,7 @@
     ///     format string \a format.
     //------------------------------------------------------------------
     void
-    PutToLog (Log *log, const char *format, ...)  __attribute__ ((format (printf, 3, 4)));
+    PutToLog (Log *log, const char *format, ...)  LLDB_ATTR(__attribute__ ((format (printf, 3, 4))));
 
     //------------------------------------------------------------------
     /// Log an error to Log() if the error value is an error.
@@ -196,7 +196,7 @@
     ///     format string \a format.
     //------------------------------------------------------------------
     void
-    LogIfError (Log *log, const char *format, ...)  __attribute__ ((format (printf, 3, 4)));
+    LogIfError (Log *log, const char *format, ...)  LLDB_ATTR(__attribute__ ((format (printf, 3, 4))));
 
     //------------------------------------------------------------------
     /// Set accessor from a kern_return_t.
@@ -266,7 +266,7 @@
     ///     A printf style format string
     //------------------------------------------------------------------
     int
-    SetErrorStringWithFormat (const char *format, ...) __attribute__ ((format (printf, 2, 3)));
+    SetErrorStringWithFormat (const char *format, ...) LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     int
     SetErrorStringWithVarArg (const char *format, va_list args);
Index: include/lldb/Core/Flags.h
===================================================================
--- include/lldb/Core/Flags.h	(revision 163322)
+++ include/lldb/Core/Flags.h	(working copy)
@@ -13,7 +13,6 @@
 
 
 #include <stdint.h>
-#include <unistd.h>
 
 namespace lldb_private {
 
Index: include/lldb/Core/FormatClasses.h
===================================================================
--- include/lldb/Core/FormatClasses.h	(revision 163322)
+++ include/lldb/Core/FormatClasses.h	(working copy)
@@ -12,7 +12,6 @@
 
 // C Includes
 #include <stdint.h>
-#include <unistd.h>
 
 // C++ Includes
 #include <string>
Index: include/lldb/Core/FormatManager.h
===================================================================
--- include/lldb/Core/FormatManager.h	(revision 163322)
+++ include/lldb/Core/FormatManager.h	(working copy)
@@ -718,7 +718,11 @@
     void
     Changed ()
     {
+#ifdef _MSC_VER
+        InterlockedIncrement(&m_last_revision);
+#else
         __sync_add_and_fetch(&m_last_revision, +1);
+#endif
     }
     
     uint32_t
@@ -767,10 +771,8 @@
     void
     LoadSystemFormatters();
     
-#ifndef LLDB_DISABLE_PYTHON
     void
     LoadObjCFormatters();
-#endif
 };
     
 } // namespace lldb_private
Index: include/lldb/Core/Log.h
===================================================================
--- include/lldb/Core/Log.h	(revision 163322)
+++ include/lldb/Core/Log.h	(working copy)
@@ -11,11 +11,9 @@
 #define liblldb_Log_h_
 
 // C Includes
-#include <stdbool.h>
 #include <stdint.h>
 #include <signal.h>
 #include <stdio.h>
-#include <unistd.h>
 
 // C++ Includes
 // Other libraries and framework includes
@@ -126,37 +124,37 @@
     PutCString (const char *cstr);
 
     void
-    Printf (const char *format, ...)  __attribute__ ((format (printf, 2, 3)));
+    Printf (const char *format, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     void
     VAPrintf (const char *format, va_list args);
 
     void
-    PrintfWithFlags( uint32_t flags, const char *format, ...)  __attribute__ ((format (printf, 3, 4)));
+    PrintfWithFlags( uint32_t flags, const char *format, ...)  LLDB_ATTR(__attribute__ ((format (printf, 3, 4))));
 
     void
-    LogIf (uint32_t mask, const char *fmt, ...)  __attribute__ ((format (printf, 3, 4)));
+    LogIf (uint32_t mask, const char *fmt, ...)  LLDB_ATTR(__attribute__ ((format (printf, 3, 4))));
 
     void
-    Debug (const char *fmt, ...)  __attribute__ ((format (printf, 2, 3)));
+    Debug (const char *fmt, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     void
-    DebugVerbose (const char *fmt, ...)  __attribute__ ((format (printf, 2, 3)));
+    DebugVerbose (const char *fmt, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     void
-    Error (const char *fmt, ...)  __attribute__ ((format (printf, 2, 3)));
+    Error (const char *fmt, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     void
-    FatalError (int err, const char *fmt, ...)  __attribute__ ((format (printf, 3, 4)));
+    FatalError (int err, const char *fmt, ...)  LLDB_ATTR(__attribute__ ((format (printf, 3, 4))));
 
     void
-    Verbose (const char *fmt, ...)  __attribute__ ((format (printf, 2, 3)));
+    Verbose (const char *fmt, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     void
-    Warning (const char *fmt, ...)  __attribute__ ((format (printf, 2, 3)));
+    Warning (const char *fmt, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     void
-    WarningVerbose (const char *fmt, ...)  __attribute__ ((format (printf, 2, 3)));
+    WarningVerbose (const char *fmt, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     Flags &
     GetOptions();
Index: include/lldb/Core/Module.h
===================================================================
--- include/lldb/Core/Module.h	(revision 163322)
+++ include/lldb/Core/Module.h	(working copy)
@@ -760,21 +760,21 @@
     // This centralizes code so that everyone doesn't need to format their error and log messages on
     // their own and keeps the output a bit more consistent.
     void                    
-    LogMessage (Log *log, const char *format, ...) __attribute__ ((format (printf, 3, 4)));
+    LogMessage (Log *log, const char *format, ...) LLDB_ATTR(__attribute__ ((format (printf, 3, 4))));
 
     void                    
-    LogMessageVerboseBacktrace (Log *log, const char *format, ...) __attribute__ ((format (printf, 3, 4)));
+    LogMessageVerboseBacktrace (Log *log, const char *format, ...) LLDB_ATTR(__attribute__ ((format (printf, 3, 4))));
     
     void
-    ReportWarning (const char *format, ...) __attribute__ ((format (printf, 2, 3)));
+    ReportWarning (const char *format, ...) LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     void
-    ReportError (const char *format, ...) __attribute__ ((format (printf, 2, 3)));
+    ReportError (const char *format, ...) LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     // Only report an error once when the module is first detected to be modified
     // so we don't spam the console with many messages.
     void
-    ReportErrorIfModifyDetected (const char *format, ...) __attribute__ ((format (printf, 2, 3)));
+    ReportErrorIfModifyDetected (const char *format, ...) LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     //------------------------------------------------------------------
     // Return true if the file backing this module has changed since the
Index: include/lldb/Core/RegularExpression.h
===================================================================
--- include/lldb/Core/RegularExpression.h	(revision 163322)
+++ include/lldb/Core/RegularExpression.h	(working copy)
@@ -11,7 +11,9 @@
 #define liblldb_DBRegex_h_
 #if defined(__cplusplus)
 
-#include <regex.h>
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/Support/Regex.h"
 #include <stdint.h>
 
 #include <string>
@@ -123,8 +125,8 @@
     bool
     Execute (const char* string, size_t match_count = 0, int execute_flags = 0) const;
 
-    size_t
-    GetErrorAsCString (char *err_str, size_t err_str_max_len) const;
+    std::string
+    GetErrorAsCString () const;
 
     bool
     GetMatchAtIndex (const char* s, uint32_t idx, std::string& match_str) const;
@@ -168,21 +170,6 @@
     bool
     IsValid () const;
     
-    void
-    Clear ()
-    {
-        Free();
-        m_re.clear();
-        m_compile_flags = 0;
-        m_comp_err = 1;
-    }
-    
-    int
-    GetErrorCode() const
-    {
-        return m_comp_err;
-    }
-
     bool
     operator < (const RegularExpression& rhs) const;
 
@@ -190,12 +177,14 @@
     //------------------------------------------------------------------
     // Member variables
     //------------------------------------------------------------------
-    std::string m_re;   ///< A copy of the original regular expression text
-    int m_comp_err;     ///< Error code for the regular expression compilation
-    regex_t m_preg;     ///< The compiled regular expression
+    mutable std::string m_re;   ///< A copy of the original regular expression text
+    mutable llvm::Regex m_regex;     ///< The compiled regular expression
     int     m_compile_flags; ///< Stores the flags from the last compile.
-    mutable std::vector<regmatch_t> m_matches; ///< Where parenthesized subexpressions results are stored
-    
+
+    typedef llvm::SmallVectorImpl<llvm::StringRef> MatchVectorImpl;
+    typedef llvm::SmallVector<llvm::StringRef, 1>  MatchVector;
+    mutable MatchVector m_matches;
+
 };
 
 } // namespace lldb_private
Index: include/lldb/Core/Stream.h
===================================================================
--- include/lldb/Core/Stream.h	(revision 163322)
+++ include/lldb/Core/Stream.h	(working copy)
@@ -126,7 +126,7 @@
     ///     The number of bytes that were appended to the stream.
     //------------------------------------------------------------------
     int
-    PrintfAsRawHex8 (const char *format, ...)  __attribute__ ((format (printf, 2, 3)));
+    PrintfAsRawHex8 (const char *format, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     //------------------------------------------------------------------
     /// Format a C string from a printf style format and variable
@@ -518,7 +518,7 @@
     ///     format string \a format.
     //------------------------------------------------------------------
     int
-    Printf (const char *format, ...)  __attribute__ ((format (printf, 2, 3)));
+    Printf (const char *format, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     int
     PrintfVarArg(const char *format, va_list args);
Index: include/lldb/Core/StreamCallback.h
===================================================================
--- include/lldb/Core/StreamCallback.h	(revision 163322)
+++ include/lldb/Core/StreamCallback.h	(working copy)
@@ -11,6 +11,7 @@
 #define liblldb_StreamCallback_h_
 
 #include <string>
+#include <map>
 
 #include "lldb/Core/Stream.h"
 #include "lldb/Core/StreamString.h"
Index: include/lldb/Core/Timer.h
===================================================================
--- include/lldb/Core/Timer.h	(revision 163322)
+++ include/lldb/Core/Timer.h	(working copy)
@@ -39,7 +39,7 @@
     //--------------------------------------------------------------
     /// Default constructor.
     //--------------------------------------------------------------
-    Timer(const char *category, const char *format, ...)  __attribute__ ((format (printf, 3, 4)));
+    Timer(const char *category, const char *format, ...)  LLDB_ATTR(__attribute__ ((format (printf, 3, 4))));
 
     //--------------------------------------------------------------
     /// Desstructor
Index: include/lldb/Expression/DWARFExpression.h
===================================================================
--- include/lldb/Expression/DWARFExpression.h	(revision 163322)
+++ include/lldb/Expression/DWARFExpression.h	(working copy)
@@ -17,11 +17,10 @@
 #include "lldb/Core/Error.h"
 #include "lldb/Core/Scalar.h"
 
+namespace lldb_private {
+
 class ClangExpressionVariable;
 class ClangExpressionVariableList;
-
-namespace lldb_private {
-
 class ClangExpressionDeclMap;
 
 //----------------------------------------------------------------------
Index: include/lldb/Expression/RecordingMemoryManager.h
===================================================================
--- include/lldb/Expression/RecordingMemoryManager.h	(revision 163322)
+++ include/lldb/Expression/RecordingMemoryManager.h	(working copy)
@@ -84,6 +84,15 @@
     //------------------------------------------------------------------
     /// Passthrough interface stub
     //------------------------------------------------------------------
+    virtual void *getPointerToNamedFunction(const std::string &Name,
+                                          bool AbortOnFailure = true)
+    {
+        return m_default_mm_ap->getPointerToNamedFunction(Name, AbortOnFailure);
+    }
+
+    //------------------------------------------------------------------
+    /// Passthrough interface stub
+    //------------------------------------------------------------------
     virtual void AllocateGOT()
     {
         m_default_mm_ap->AllocateGOT();
Index: include/lldb/Host/Condition.h
===================================================================
--- include/lldb/Host/Condition.h	(revision 163322)
+++ include/lldb/Host/Condition.h	(working copy)
@@ -11,8 +11,11 @@
 #define liblldb_DBCondition_h_
 #if defined(__cplusplus)
 
+#ifdef _POSIX_SOURCE
+#include <pthread.h>
+#endif
 
-#include <pthread.h>
+#include "lldb/lldb-types.h"
 #include "lldb/Host/Mutex.h"
 
 namespace lldb_private {
@@ -102,6 +105,8 @@
     Wait (Mutex &mutex, const TimeValue *abstime = NULL, bool *timed_out = NULL);
 
 protected:
+
+#ifdef _POSIX_SOURCE
     //------------------------------------------------------------------
     // Member variables
     //------------------------------------------------------------------
@@ -115,6 +120,11 @@
     //------------------------------------------------------------------
     pthread_cond_t *
     GetCondition ();
+#else
+
+    lldb::condition_t m_condition;
+
+#endif
 };
 
 } // namespace lldb_private
Index: include/lldb/Host/Config.h
===================================================================
--- include/lldb/Host/Config.h	(revision 163322)
+++ include/lldb/Host/Config.h	(working copy)
@@ -26,6 +26,10 @@
 
 #include "lldb/Host/mingw/Config.h"
 
+#elif defined(_WIN32) || defined(_WIN64)
+
+//#include "lldb/Host/windows/Config.h"
+
 #else
 
 #error undefined platform
Index: include/lldb/Host/File.h
===================================================================
--- include/lldb/Host/File.h	(revision 163322)
+++ include/lldb/Host/File.h	(working copy)
@@ -458,7 +458,7 @@
     ///     format string \a format.
     //------------------------------------------------------------------
     int
-    Printf (const char *format, ...)  __attribute__ ((format (printf, 2, 3)));
+    Printf (const char *format, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
     
     int
     PrintfVarArg(const char *format, va_list args);
Index: include/lldb/Host/Host.h
===================================================================
--- include/lldb/Host/Host.h	(revision 163322)
+++ include/lldb/Host/Host.h	(working copy)
@@ -138,7 +138,7 @@
     };
 
     static void
-    SystemLog (SystemLogType type, const char *format, ...) __attribute__ ((format (printf, 2, 3)));
+    SystemLog (SystemLogType type, const char *format, ...) LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     static void
     SystemLog (SystemLogType type, const char *format, va_list args);
@@ -396,7 +396,7 @@
     ///     description string.
     //------------------------------------------------------------------
     static void
-    SetCrashDescriptionWithFormat (const char *format, ...)  __attribute__ ((format (printf, 1, 2)));
+    SetCrashDescriptionWithFormat (const char *format, ...)  LLDB_ATTR(__attribute__ ((format (printf, 1, 2))));
 
     static void
     SetCrashDescription (const char *description);
Index: include/lldb/Host/Mutex.h
===================================================================
--- include/lldb/Host/Mutex.h	(revision 163322)
+++ include/lldb/Host/Mutex.h	(working copy)
@@ -11,7 +11,12 @@
 #define liblldb_Mutex_h_
 #if defined(__cplusplus)
 
+#include "llvm\Support\Mutex.h"
+
+#ifdef _POSIX_SOURCE
 #include <pthread.h>
+#endif
+
 #include <assert.h>
 
 #ifdef LLDB_CONFIGURATION_DEBUG
@@ -125,10 +130,10 @@
         ///     returns \b false otherwise.
         //--------------------------------------------------------------
         bool
-        TryLock (Mutex &mutex, const char *failure_message = NULL);
+        TryLock (Mutex &mutex, const char *failure_message = 0);
         
         bool
-        TryLock (Mutex *mutex, const char *failure_message = NULL)
+        TryLock (Mutex *mutex, const char *failure_message = 0)
         {
             if (mutex)
                 return TryLock(*mutex, failure_message);
@@ -210,7 +215,7 @@
     virtual
 #endif
     int
-    TryLock(const char *failure_message = NULL);
+    TryLock(const char *failure_message = 0);
 
     //------------------------------------------------------------------
     /// Unlock the mutex.
@@ -230,14 +235,17 @@
     Unlock();
 
 protected:
+#ifdef _POSIX_SOURCE
     //------------------------------------------------------------------
     // Member variables
     //------------------------------------------------------------------
     // TODO: Hide the mutex in the implementation file in case we ever need to port to an
     // architecture that doesn't have pthread mutexes.
     pthread_mutex_t m_mutex; ///< The pthread mutex object.
+#endif
 
 private:
+#ifdef _POSIX_SOURCE
     //------------------------------------------------------------------
     /// Mutex get accessor.
     ///
@@ -246,7 +254,12 @@
     //------------------------------------------------------------------
     pthread_mutex_t *
     GetMutex();
+#endif
 
+#ifndef _POSIX_SOURCE
+    llvm::sys::MutexImpl m_mutex;
+#endif
+
     Mutex(const Mutex&);
     const Mutex& operator=(const Mutex&);
 };
Index: include/lldb/Host/ReadWriteLock.h
===================================================================
--- include/lldb/Host/ReadWriteLock.h	(revision 163322)
+++ include/lldb/Host/ReadWriteLock.h	(working copy)
@@ -11,9 +11,17 @@
 #define liblldb_ReadWriteLock_h_
 #if defined(__cplusplus)
 
+#if defined(WIN32)
+#include "lldb/lldb-defines.h"
+#include <Windows.h>
+#undef interface
+#else
+#include <pthread.h>
+#endif
+
 #include "lldb/Host/Mutex.h"
 #include "lldb/Host/Condition.h"
-#include <pthread.h>
+
 #include <stdint.h>
 #include <time.h>
 
@@ -36,6 +44,16 @@
 class ReadWriteLock
 {
 public:
+#if defined(WIN32)
+    ReadWriteLock ();
+    ~ReadWriteLock ();
+    bool ReadLock ();
+    bool ReadTryLock ();
+    bool ReadUnlock ();
+    bool WriteLock ();
+    bool WriteTryLock ();
+    bool WriteUnlock ();
+#else
     ReadWriteLock () :
         m_rwlock()
     {
@@ -88,6 +106,7 @@
     {
         return ::pthread_rwlock_unlock (&m_rwlock) == 0;
     }
+#endif
 
     class ReadLocker
     {
@@ -229,7 +248,11 @@
     };
 
 protected:
+#if defined(WIN32)
+    void* m_data;
+#else
     pthread_rwlock_t m_rwlock;
+#endif
 private:
     DISALLOW_COPY_AND_ASSIGN(ReadWriteLock);
 };
Index: include/lldb/Host/SocketAddress.h
===================================================================
--- include/lldb/Host/SocketAddress.h	(revision 163322)
+++ include/lldb/Host/SocketAddress.h	(working copy)
@@ -12,17 +12,24 @@
 
 // C Includes
 #include <stdint.h>
+#ifdef _POSIX_SOURCE
 #include <sys/socket.h>
 #include <netdb.h>
 #include <netinet/in.h>
+#endif
 
 #if defined(__FreeBSD__)
 #include <sys/types.h>
 #endif
 
+#ifdef _WIN32
+#include <WS2tcpip.h>
+#endif
+
 // C++ Includes
 // Other libraries and framework includes
 // Project includes
+#include "lldb/lldb-private.h"
 
 namespace lldb_private {
 
Index: include/lldb/Host/Symbols.h
===================================================================
--- include/lldb/Host/Symbols.h	(revision 163322)
+++ include/lldb/Host/Symbols.h	(working copy)
@@ -12,7 +12,6 @@
 
 // C Includes
 #include <stdint.h>
-#include <sys/time.h>
 
 // C++ Includes
 // Other libraries and framework includes
Index: include/lldb/Host/TimeValue.h
===================================================================
--- include/lldb/Host/TimeValue.h	(revision 163322)
+++ include/lldb/Host/TimeValue.h	(working copy)
@@ -12,6 +12,8 @@
 
 // C Includes
 #include <stdint.h>
+
+#ifndef _MSC_VER
 #include <sys/time.h>
 
 // BEGIN: MinGW work around
@@ -19,6 +21,9 @@
 #include <pthread.h>
 #endif
 // END: MinGW work around
+#else
+#include <winsock2.h>
+#endif
 
 // C++ Includes
 // Other libraries and framework includes
@@ -61,8 +66,10 @@
     uint64_t
     GetAsSecondsSinceJan1_1970() const;
 
+#ifdef _POSIX_SOURCE
     struct timespec
     GetAsTimeSpec () const;
+#endif
 
     struct timeval
     GetAsTimeVal () const;
Index: include/lldb/Interpreter/Args.h
===================================================================
--- include/lldb/Interpreter/Args.h	(revision 163322)
+++ include/lldb/Interpreter/Args.h	(working copy)
@@ -10,9 +10,6 @@
 #ifndef liblldb_Command_h_
 #define liblldb_Command_h_
 
-// C Includes
-#include <getopt.h>
-
 // C++ Includes
 #include <list>
 #include <string>
Index: include/lldb/Interpreter/CommandReturnObject.h
===================================================================
--- include/lldb/Interpreter/CommandReturnObject.h	(revision 163322)
+++ include/lldb/Interpreter/CommandReturnObject.h	(working copy)
@@ -121,7 +121,7 @@
     AppendMessage (const char *in_string, int len = -1);
 
     void
-    AppendMessageWithFormat (const char *format, ...)  __attribute__ ((format (printf, 2, 3)));
+    AppendMessageWithFormat (const char *format, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     void
     AppendRawWarning (const char *in_string, int len = -1);
@@ -130,7 +130,7 @@
     AppendWarning (const char *in_string, int len = -1);
 
     void
-    AppendWarningWithFormat (const char *format, ...)  __attribute__ ((format (printf, 2, 3)));
+    AppendWarningWithFormat (const char *format, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     void
     AppendError (const char *in_string, int len = -1);
@@ -139,7 +139,7 @@
     AppendRawError (const char *in_string, int len = -1);
 
     void
-    AppendErrorWithFormat (const char *format, ...)  __attribute__ ((format (printf, 2, 3)));
+    AppendErrorWithFormat (const char *format, ...)  LLDB_ATTR(__attribute__ ((format (printf, 2, 3))));
 
     void
     SetError (const Error &error, 
Index: include/lldb/Interpreter/Options.h
===================================================================
--- include/lldb/Interpreter/Options.h	(revision 163322)
+++ include/lldb/Interpreter/Options.h	(working copy)
@@ -11,7 +11,9 @@
 #define liblldb_Options_h_
 
 // C Includes
+#ifdef _POSIX_SOURCE
 #include <getopt.h>
+#endif
 
 // C++ Includes
 #include <set>
Index: include/lldb/Interpreter/OptionValueEnumeration.h
===================================================================
--- include/lldb/Interpreter/OptionValueEnumeration.h	(revision 163322)
+++ include/lldb/Interpreter/OptionValueEnumeration.h	(working copy)
@@ -34,7 +34,7 @@
         const char *description;
     };
     typedef UniqueCStringMap<EnumeratorInfo> EnumerationMap;
-    typedef typename EnumerationMap::Entry EnumerationMapEntry;
+    typedef EnumerationMap::Entry EnumerationMapEntry;
 
     OptionValueEnumeration (const OptionEnumValueElement *enumerators, enum_type value);
     
Index: include/lldb/Interpreter/OptionValueRegex.h
===================================================================
--- include/lldb/Interpreter/OptionValueRegex.h	(revision 163322)
+++ include/lldb/Interpreter/OptionValueRegex.h	(working copy)
@@ -55,7 +55,7 @@
     virtual bool
     Clear ()
     {
-        m_regex.Clear();
+        m_regex.Free();
         m_value_was_set = false;
         return true;
     }
@@ -80,7 +80,7 @@
         if (value && value[0])
             m_regex.Compile (value, regex_flags);
         else
-            m_regex.Clear();
+            m_regex.Free();
     }
 
     bool
Index: include/lldb/lldb-defines.h
===================================================================
--- include/lldb/lldb-defines.h	(revision 163322)
+++ include/lldb/lldb-defines.h	(working copy)
@@ -105,6 +105,13 @@
 #define LLDB_OPT_SET_10                 (1U << 9)
 #define LLDB_OPT_SET_FROM_TO(A, B)      (((1U << (B)) - 1) ^ (((1U << (A))-1) >> 1))
 
+#ifdef _MSC_VER
+// ignore GCC function attributes
+#define LLDB_ATTR(X)
+#else
+#define LLDB_ATTR(X) X
+#endif
+
 #if defined(__cplusplus)
 
 //----------------------------------------------------------------------
Index: include/lldb/lldb-forward.h
===================================================================
--- include/lldb/lldb-forward.h	(revision 163322)
+++ include/lldb/lldb-forward.h	(working copy)
@@ -14,7 +14,7 @@
 
 #include <ciso646>  // detect C++ lib
 
-#ifdef _LIBCPP_VERSION
+#if defined(_LIBCPP_VERSION) || defined(_MSC_VER)
 #include <memory>
 #define STD_SHARED_PTR(T) std::shared_ptr<T>
 #define STD_WEAK_PTR(T) std::weak_ptr<T>
Index: include/lldb/lldb-private.h
===================================================================
--- include/lldb/lldb-private.h	(revision 163322)
+++ include/lldb/lldb-private.h	(working copy)
@@ -12,6 +12,10 @@
 
 #if defined(__cplusplus)
 
+#ifdef _MSC_VER
+#include "lldb/lldb-windows.h"
+#endif
+
 #include "lldb/lldb-public.h"
 #include "lldb/lldb-private-enumerations.h"
 #include "lldb/lldb-private-interfaces.h"
Index: include/lldb/lldb-types.h
===================================================================
--- include/lldb/lldb-types.h	(revision 163322)
+++ include/lldb/lldb-types.h	(working copy)
@@ -14,11 +14,8 @@
 #include "lldb/lldb-forward.h"
 
 #include <assert.h>
-#include <pthread.h>
 #include <signal.h>
 #include <stdint.h>
-#include <stdbool.h>
-#include <unistd.h>
 
 //----------------------------------------------------------------------
 // All host systems must define:
@@ -39,20 +36,46 @@
 // things should be defined. Currently MacOSX is being assumed by default
 // since that is what lldb was first developed for.
 
-namespace lldb {
-        //----------------------------------------------------------------------
-        // MacOSX Types
-        //----------------------------------------------------------------------
-        typedef ::pthread_mutex_t   mutex_t;
-        typedef pthread_cond_t      condition_t;
-        typedef pthread_t           thread_t;                   // Host thread type
-        typedef void *              thread_arg_t;               // Host thread argument type
-        typedef void *              thread_result_t;            // Host thread result type
-        typedef void *              (*thread_func_t)(void *);   // Host thread function type
-        typedef void                (*LogOutputCallback) (const char *, void *baton);
-        typedef bool                (*CommandOverrideCallback)(void *baton, const char **argv);
-} // namespace lldb
+#if defined(_WIN32) || defined(_WIN64)
 
+#define WIN32_LEAN_AND_MEAN
+#define NOMINMAX
+
+#include <Windows.h>
+#include <process.h>
+
+namespace lldb
+{
+    typedef CRITICAL_SECTION    mutex_t;
+    typedef CONDITION_VARIABLE  condition_t;
+    typedef uintptr_t           thread_t;                   // Host thread type
+    typedef void *              thread_arg_t;               // Host thread argument type
+    typedef unsigned            thread_result_t;            // Host thread result type
+    typedef thread_result_t     (*thread_func_t)(void *);   // Host thread function type
+    typedef void                (*LogOutputCallback) (const char *, void *baton);
+    typedef bool                (*CommandOverrideCallback)(void *baton, const char **argv);
+}
+
+#else
+
+#include <stdbool.h>
+#include <unistd.h>
+#include <pthread.h>
+
+namespace lldb
+{
+    typedef ::pthread_mutex_t   mutex_t;
+    typedef pthread_cond_t      condition_t;
+    typedef pthread_t           thread_t;                   // Host thread type
+    typedef void *              thread_arg_t;               // Host thread argument type
+    typedef void *              thread_result_t;            // Host thread result type
+    typedef void *              (*thread_func_t)(void *);   // Host thread function type
+    typedef void                (*LogOutputCallback) (const char *, void *baton);
+    typedef bool                (*CommandOverrideCallback)(void *baton, const char **argv);
+}
+
+#endif
+
 #if defined(__MINGW32__)
 
 const lldb::thread_t lldb_invalid_host_thread_const = { NULL, 0 } ;
Index: include/lldb/lldb-windows.h
===================================================================
--- include/lldb/lldb-windows.h	(revision 0)
+++ include/lldb/lldb-windows.h	(working copy)
@@ -0,0 +1,101 @@
+//===-- lldb-windows.h ------------------------------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef lldb_lldb_windows_h_
+#define lldb_lldb_windows_h_
+
+#if defined(__cplusplus)
+
+#ifdef _MSC_VER
+
+#define WIN32_LEAN_AND_MEAN
+#define NOMINMAX
+#include <Windows.h>
+
+// posix utilities
+#define snprintf _snprintf
+int vasprintf(char **ret, const char *fmt, va_list ap);
+
+int strcasecmp(const char* s1, const char* s2);
+int strncasecmp(const char* s1, const char* s2, size_t n);
+char * strcasestr(const char *s, const char* find);
+
+long long int strtoll(const char *nptr, char **endptr, int base);
+unsigned long long int strtoull(const char *nptr, char **endptr, int base);
+
+// missing posix declarations
+enum {
+  PATH_MAX = MAX_PATH
+};
+
+enum {
+  REG_EXTENDED
+};
+
+enum {
+  STDIN_FILENO = 0,
+  STDOUT_FILENO,
+  STDERR_FILENO
+};
+
+enum {
+  O_NOCTTY
+};
+
+enum {
+  SIGKILL
+};
+
+// missing socket types
+typedef short sa_family_t;
+typedef unsigned short in_port_t;
+
+// getopt()
+enum {
+  no_argument = 0,
+  required_argument,
+  optional_argument
+};
+
+struct option {
+    /* name of long option */
+    const char *name;
+    /*
+     * one of no_argument, required_argument, and optional_argument:
+     * whether option takes an argument
+     */
+    int has_arg;
+    /* if not NULL, set *flag to val when option found */
+    int *flag;
+    /* if flag not NULL, value to set *flag to; else return value */
+    int val;
+};
+
+int getopt(int argc, char * const argv[],
+    const char *optstring);
+
+extern char *optarg;
+extern int optind, opterr, optopt;
+
+int getopt_long(int argc, char * const *argv,
+    const char *optstring,
+    const struct option *longopts, int *longindex);
+
+extern int optreset;
+
+// missing macros 
+#define __PRETTY_FUNCTION__ __FUNCSIG__
+#define va_copy(d,s) ((d) = (s))
+
+#endif
+
+#endif  // defined(__cplusplus)
+
+
+#endif  // lldb_lldb_windows_h_
Index: include/lldb/Symbol/ClangNamespaceDecl.h
===================================================================
--- include/lldb/Symbol/ClangNamespaceDecl.h	(revision 163322)
+++ include/lldb/Symbol/ClangNamespaceDecl.h	(working copy)
@@ -10,6 +10,7 @@
 #ifndef liblldb_ClangNamespaceDecl_h_
 #define liblldb_ClangNamespaceDecl_h_
 
+#include <string>
 #include "lldb/lldb-public.h"
 #include "lldb/Core/ClangForward.h"
 
Index: include/lldb/Target/Process.h
===================================================================
--- include/lldb/Target/Process.h	(revision 163322)
+++ include/lldb/Target/Process.h	(working copy)
@@ -12,7 +12,10 @@
 
 // C Includes
 #include <limits.h>
+
+#ifdef _POSIX_SOURCE
 #include <spawn.h>
+#endif
 
 // C++ Includes
 #include <list>
@@ -22,6 +25,7 @@
 // Other libraries and framework includes
 // Project includes
 #include "lldb/lldb-private.h"
+#include "lldb/lldb-types.h"
 #include "lldb/Core/ArchSpec.h"
 #include "lldb/Core/Broadcaster.h"
 #include "lldb/Core/Communication.h"
@@ -428,11 +432,13 @@
         bool
         Open (int fd, const char *path, bool read, bool write);
         
+#ifdef _POSIX_SOURCE
         static bool
         AddPosixSpawnFileAction (posix_spawn_file_actions_t *file_actions,
                                  const FileAction *info,
                                  Log *log, 
                                  Error& error);
+#endif
 
         int
         GetFD () const
@@ -1306,7 +1312,7 @@
 {
 friend class ThreadList;
 friend class ClangFunction; // For WaitForStateChangeEventsPrivate
-friend class CommandObjectProcessLaunch;
+//friend class CommandObjectProcessLaunch;
 friend class ProcessEventData;
 friend class CommandObjectBreakpointCommand;
 friend class StopInfo;
@@ -3412,7 +3418,7 @@
     void
     ResumePrivateStateThread ();
 
-    static void *
+    static lldb::thread_result_t
     PrivateStateThread (void *arg);
 
     void *
Index: include/lldb/Utility/RefCounter.h
===================================================================
--- include/lldb/Utility/RefCounter.h	(revision 163322)
+++ include/lldb/Utility/RefCounter.h	(working copy)
@@ -10,6 +10,12 @@
 #ifndef liblldb_RefCounter_h_
 #define liblldb_RefCounter_h_
 
+#ifdef _MSC_VER
+#define WIN32_LEAN_AND_MEAN
+#define NOMINMAX
+#include <Windows.h>
+#endif
+
 #include "lldb/lldb-public.h"
 
 namespace lldb_utility {
@@ -39,14 +45,22 @@
     inline T
     increment(T* t)
     {
-        return __sync_fetch_and_add(t, 1);
+#ifdef _MSC_VER
+    return InterlockedIncrement((LONG*)&t);
+#else
+    return __sync_add_and_fetch(&t, 1);
+#endif
     }
     
     template <class T>
     inline T
     decrement(T* t)
     {
-        return __sync_fetch_and_add(t, -1);
+#ifdef _MSC_VER
+    return InterlockedIncrement((LONG*)&t);
+#else
+    return __sync_add_and_fetch(&t, 1);
+#endif
     }
     
 };
Index: include/lldb/Utility/SharingPtr.h
===================================================================
--- include/lldb/Utility/SharingPtr.h	(revision 163322)
+++ include/lldb/Utility/SharingPtr.h	(working copy)
@@ -13,6 +13,12 @@
 #include <algorithm>
 #include <memory>
 
+#ifdef _MSC_VER
+#define WIN32_LEAN_AND_MEAN
+#define NOMINMAX
+#include <Windows.h>
+#endif
+
 //#define ENABLE_SP_LOGGING 1 // DON'T CHECK THIS LINE IN UNLESS COMMENTED OUT
 #if defined (ENABLE_SP_LOGGING)
 
@@ -28,14 +34,22 @@
 inline T
 increment(T& t)
 {
+#ifdef _MSC_VER
+    return InterlockedIncrement(&t);
+#else
     return __sync_add_and_fetch(&t, 1);
+#endif
 }
 
 template <class T>
 inline T
 decrement(T& t)
 {
+#ifdef _MSC_VER
+     return InterlockedDecrement(&t);
+#else
     return __sync_add_and_fetch(&t, -1);
+#endif
 }
 
 class shared_count
Index: scripts/build-llvm.pl
===================================================================
--- scripts/build-llvm.pl	(revision 163322)
+++ scripts/build-llvm.pl	(working copy)
@@ -21,8 +21,8 @@
 
 our $llvm_configuration = $ENV{LLVM_CONFIGURATION};
 
-our $llvm_revision = "152265";
-our $clang_revision = "152265";
+our $llvm_revision = "163312";
+our $clang_revision = "163312";
 
 our $SRCROOT = "$ENV{SRCROOT}";
 our $llvm_dstroot_zip = "$SRCROOT/llvm.zip";
Index: scripts/CMakeLists.txt
===================================================================
--- scripts/CMakeLists.txt	(revision 0)
+++ scripts/CMakeLists.txt	(working copy)
@@ -0,0 +1,12 @@
+set(LLVM_NO_RTTI 1)
+
+add_custom_command(
+  OUTPUT ${LLDB_SOURCE_DIR}/source/LLDBWrapPython.cpp
+  DEPENDS ${LLDB_SOURCE_DIR}/scripts/lldb.swig
+  COMMAND swig -c++ -shadow -python -I${LLDB_SOURCE_DIR}/include -I./. -outdir ${LLDB_SOURCE_DIR}/scripts/Python  -o ${LLDB_SOURCE_DIR}/source/LLDBWrapPython.cpp ${LLDB_SOURCE_DIR}/scripts/lldb.swig
+  COMMENT "Building lldb pyhton wrapper")
+set_source_files_properties(${LLDB_SOURCE_DIR}/source/LLDBWrapPython.cpp PROPERTIES GENERATED 1)
+
+ADD_CUSTOM_TARGET(swig_wrapper ALL echo
+      DEPENDS ${LLDB_SOURCE_DIR}/source/LLDBWrapPython.cpp
+    )
Index: source/API/CMakeLists.txt
===================================================================
--- source/API/CMakeLists.txt	(revision 0)
+++ source/API/CMakeLists.txt	(working copy)
@@ -0,0 +1,48 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbAPI
+  SBAddress.cpp
+  SBBlock.cpp
+  SBBreakpoint.cpp
+  SBBreakpointLocation.cpp
+  SBBroadcaster.cpp
+  SBCommandInterpreter.cpp
+  SBCommandReturnObject.cpp
+  SBCommunication.cpp
+  SBCompileUnit.cpp
+  SBData.cpp
+  SBDebugger.cpp
+  SBError.cpp
+  SBEvent.cpp
+  SBFileSpec.cpp
+  SBFileSpecList.cpp
+  SBFrame.cpp
+  SBFunction.cpp
+  SBHostOS.cpp
+  SBInputReader.cpp
+  SBInstruction.cpp
+  SBInstructionList.cpp
+  SBLineEntry.cpp
+  SBListener.cpp
+  SBModule.cpp
+  SBProcess.cpp
+  SBSection.cpp
+  SBSourceManager.cpp
+  SBStream.cpp
+  SBStringList.cpp
+  SBSymbol.cpp
+  SBSymbolContext.cpp
+  SBSymbolContextList.cpp
+  SBTarget.cpp
+  SBThread.cpp
+  SBType.cpp
+  SBTypeCategory.cpp
+  SBTypeFilter.cpp
+  SBTypeFormat.cpp
+  SBTypeNameSpecifier.cpp
+  SBTypeSummary.cpp
+  SBTypeSynthetic.cpp
+  SBValue.cpp
+  SBValueList.cpp
+  SBWatchpoint.cpp
+  )
Index: source/API/SBDebugger.cpp
===================================================================
--- source/API/SBDebugger.cpp	(revision 163322)
+++ source/API/SBDebugger.cpp	(working copy)
@@ -464,7 +464,7 @@
 const char *
 SBDebugger::GetVersionString ()
 {
-    return GetVersion();
+    return lldb_private::GetVersion();
 }
 
 const char *
Index: source/API/SBHostOS.cpp
===================================================================
--- source/API/SBHostOS.cpp	(revision 163322)
+++ source/API/SBHostOS.cpp	(working copy)
@@ -30,7 +30,7 @@
 SBHostOS::ThreadCreate
 (
     const char *name,
-    void *(*thread_function)(void *),
+    thread_func_t thread_function,
     void *thread_arg,
     SBError *error_ptr
 )
@@ -65,7 +65,7 @@
 }
 
 bool
-SBHostOS::ThreadJoin (lldb::thread_t thread, void **result, SBError *error_ptr)
+SBHostOS::ThreadJoin (lldb::thread_t thread, thread_result_t *result, SBError *error_ptr)
 {
     return Host::ThreadJoin (thread, result, error_ptr ? error_ptr->get() : NULL);
 }
Index: source/Breakpoint/CMakeLists.txt
===================================================================
--- source/Breakpoint/CMakeLists.txt	(revision 0)
+++ source/Breakpoint/CMakeLists.txt	(working copy)
@@ -0,0 +1,25 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbBreakpoint
+  Breakpoint.cpp
+  BreakpointID.cpp
+  BreakpointIDList.cpp
+  BreakpointList.cpp
+  BreakpointLocation.cpp
+  BreakpointLocationCollection.cpp
+  BreakpointLocationList.cpp
+  BreakpointOptions.cpp
+  BreakpointResolver.cpp
+  BreakpointResolverAddress.cpp
+  BreakpointResolverFileLine.cpp
+  BreakpointResolverFileRegex.cpp
+  BreakpointResolverName.cpp
+  BreakpointSite.cpp
+  BreakpointSiteList.cpp
+  Stoppoint.cpp
+  StoppointCallbackContext.cpp
+  StoppointLocation.cpp
+  Watchpoint.cpp
+  WatchpointList.cpp
+  WatchpointOptions.cpp
+  )
Index: source/CMakeLists.txt
===================================================================
--- source/CMakeLists.txt	(revision 0)
+++ source/CMakeLists.txt	(working copy)
@@ -0,0 +1,16 @@
+add_subdirectory(API)
+add_subdirectory(Breakpoint)
+add_subdirectory(Commands)
+add_subdirectory(Core)
+add_subdirectory(Expression)
+add_subdirectory(Host)
+add_subdirectory(Interpreter)
+add_subdirectory(Plugins)
+add_subdirectory(Symbol)
+add_subdirectory(Target)
+add_subdirectory(Utility)
+
+add_lldb_library(lldbInitAndLog
+  lldb.cpp
+  lldb-log.cpp
+  )
Index: source/Commands/CMakeLists.txt
===================================================================
--- source/Commands/CMakeLists.txt	(revision 0)
+++ source/Commands/CMakeLists.txt	(working copy)
@@ -0,0 +1,31 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbCommands
+  CommandCompletions.cpp
+  CommandObjectApropos.cpp
+  CommandObjectArgs.cpp
+  CommandObjectBreakpoint.cpp
+  CommandObjectBreakpointCommand.cpp
+  CommandObjectCommands.cpp
+  CommandObjectCrossref.cpp
+  CommandObjectDisassemble.cpp
+  CommandObjectExpression.cpp
+  CommandObjectFrame.cpp
+  CommandObjectHelp.cpp
+  CommandObjectLog.cpp
+  CommandObjectMemory.cpp
+  CommandObjectMultiword.cpp
+  CommandObjectPlatform.cpp
+  CommandObjectProcess.cpp
+  CommandObjectQuit.cpp
+  CommandObjectRegister.cpp
+  CommandObjectSettings.cpp
+  CommandObjectSource.cpp
+  CommandObjectSyntax.cpp
+  CommandObjectTarget.cpp
+  CommandObjectThread.cpp
+  CommandObjectType.cpp
+  CommandObjectVersion.cpp
+  CommandObjectWatchpoint.cpp
+  CommandObjectWatchpointCommand.cpp
+  )
Index: source/Commands/CommandObjectBreakpoint.cpp
===================================================================
--- source/Commands/CommandObjectBreakpoint.cpp	(revision 163322)
+++ source/Commands/CommandObjectBreakpoint.cpp	(working copy)
@@ -435,10 +435,8 @@
                     RegularExpression regexp(m_options.m_func_regexp.c_str());
                     if (!regexp.IsValid())
                     {
-                        char err_str[1024];
-                        regexp.GetErrorAsCString(err_str, sizeof(err_str));
                         result.AppendErrorWithFormat("Function name regular expression could not be compiled: \"%s\"",
-                                                     err_str);
+                                                     regexp.GetErrorAsCString().c_str());
                         result.SetStatus (eReturnStatusFailed);
                         return false;
                     }
@@ -472,10 +470,8 @@
                     RegularExpression regexp(m_options.m_source_text_regexp.c_str());
                     if (!regexp.IsValid())
                     {
-                        char err_str[1024];
-                        regexp.GetErrorAsCString(err_str, sizeof(err_str));
                         result.AppendErrorWithFormat("Source text regular expression could not be compiled: \"%s\"",
-                                                     err_str);
+                                                     regexp.GetErrorAsCString().c_str());
                         result.SetStatus (eReturnStatusFailed);
                         return false;
                     }
Index: source/Commands/CommandObjectFrame.cpp
===================================================================
--- source/Commands/CommandObjectFrame.cpp	(revision 163322)
+++ source/Commands/CommandObjectFrame.cpp	(working copy)
@@ -475,8 +475,8 @@
                         }
                         else
                         {
-                            char regex_error[1024];
-                            if (regex.GetErrorAsCString(regex_error, sizeof(regex_error)))
+                            std::string regex_error = regex.GetErrorAsCString();
+                            if (!regex_error.empty())
                                 result.GetErrorStream().Printf ("error: %s\n", regex_error);
                             else
                                 result.GetErrorStream().Printf ("error: unkown regex error when compiling '%s'\n", name_cstr);
Index: source/Core/AddressResolverName.cpp
===================================================================
--- source/Core/AddressResolverName.cpp	(revision 163322)
+++ source/Core/AddressResolverName.cpp	(working copy)
@@ -35,12 +35,15 @@
 {
     if (m_match_type == AddressResolver::Regexp)
     {
-        if (!m_regex.Compile (m_func_name.AsCString()))
+        m_regex = RegularExpression(m_func_name.AsCString());
+        if (!m_regex.IsValid())
         {
             LogSP log(lldb_private::GetLogIfAllCategoriesSet (LIBLLDB_LOG_BREAKPOINTS));
 
             if (log)
-                log->Warning ("function name regexp: \"%s\" did not compile.", m_func_name.AsCString());
+                log->Warning ("function name regexp: \"%s\" did not compile: %s.",
+                              m_func_name.AsCString(),
+                              m_regex.GetErrorAsCString().c_str());
         }
     }
 }
Index: source/Core/CMakeLists.txt
===================================================================
--- source/Core/CMakeLists.txt	(revision 0)
+++ source/Core/CMakeLists.txt	(working copy)
@@ -0,0 +1,79 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbCore
+  Address.cpp
+  AddressRange.cpp
+  AddressResolver.cpp
+  AddressResolverFileLine.cpp
+  AddressResolverName.cpp
+  ArchSpec.cpp
+  Baton.cpp
+  Broadcaster.cpp
+  Communication.cpp
+  Connection.cpp
+  ConnectionFileDescriptor.cpp
+  ConnectionMachPort.cpp
+  ConnectionSharedMemory.cpp
+  ConstString.cpp
+  cxa_demangle.cpp  
+  CXXFormatterFunctions.cpp
+  DataBufferHeap.cpp
+  DataBufferMemoryMap.cpp
+  DataEncoder.cpp
+  DataExtractor.cpp
+  DataVisualization.cpp
+  Debugger.cpp
+  Disassembler.cpp
+  DynamicLoader.cpp
+  EmulateInstruction.cpp
+  Error.cpp
+  Event.cpp
+  FileLineResolver.cpp
+  FileSpecList.cpp
+  FormatClasses.cpp
+  FormatManager.cpp
+  History.cpp
+  InputReader.cpp
+  InputReaderEZ.cpp
+  InputReaderStack.cpp
+  Language.cpp
+  Listener.cpp
+  Log.cpp
+  Mangled.cpp
+  Module.cpp
+  ModuleChild.cpp
+  ModuleList.cpp
+  Opcode.cpp
+  PluginManager.cpp
+  RegisterValue.cpp
+  RegularExpression.cpp
+  Scalar.cpp
+  SearchFilter.cpp
+  Section.cpp
+  SourceManager.cpp
+  State.cpp
+  Stream.cpp
+  StreamAsynchronousIO.cpp
+  StreamCallback.cpp
+  StreamFile.cpp
+  StreamString.cpp
+  StringList.cpp
+  Timer.cpp
+  UserID.cpp
+  UserSettingsController.cpp
+  UUID.cpp
+  Value.cpp
+  ValueObject.cpp
+  ValueObjectChild.cpp
+  ValueObjectConstResult.cpp
+  ValueObjectConstResultChild.cpp
+  ValueObjectConstResultImpl.cpp
+  ValueObjectDynamicValue.cpp
+  ValueObjectList.cpp
+  ValueObjectMemory.cpp
+  ValueObjectRegister.cpp
+  ValueObjectSyntheticFilter.cpp
+  ValueObjectVariable.cpp
+  VMRange.cpp
+  Windows.cpp
+  )
Index: source/Core/Communication.cpp
===================================================================
--- source/Core/Communication.cpp	(revision 163322)
+++ source/Core/Communication.cpp	(working copy)
@@ -333,7 +333,7 @@
     return m_read_thread_enabled;
 }
 
-void *
+thread_result_t
 Communication::ReadThread (void *p)
 {
     Communication *comm = (Communication *)p;
Index: source/Core/ConnectionFileDescriptor.cpp
===================================================================
--- source/Core/ConnectionFileDescriptor.cpp	(revision 163322)
+++ source/Core/ConnectionFileDescriptor.cpp	(working copy)
@@ -12,6 +12,7 @@
 // C Includes
 #include <errno.h>
 #include <fcntl.h>
+#ifdef _POSIX_SOURCE
 #include <arpa/inet.h>
 #include <netdb.h>
 #include <netinet/in.h>
@@ -22,6 +23,7 @@
 #include <string.h>
 #include <stdlib.h>
 #include <unistd.h>
+#endif
 
 // C++ Includes
 // Other libraries and framework includes
@@ -123,7 +125,11 @@
     LogSP log(lldb_private::GetLogIfAnyCategoriesSet (LIBLLDB_LOG_CONNECTION |  LIBLLDB_LOG_OBJECT));
     // Make the command file descriptor here:
     int filedes[2];
-    int result = pipe (filedes);
+#ifdef _POSIX_SOURCE
+     int result = pipe (filedes);
+#else
+    int result = -1;
+#endif
     if (result != 0)
     {
         if (log)
@@ -143,13 +149,17 @@
 {
     if (m_pipe_read != -1)
     {
+#ifdef _POSIX_SOURCE	
         close (m_pipe_read);
+#endif
         m_pipe_read = -1;
     }
     
     if (m_pipe_write != -1)
     {
+#ifdef _POSIX_SOURCE	
         close (m_pipe_write);
+#endif
         m_pipe_write = -1;
     }
 }
@@ -211,7 +221,11 @@
                 // get the flags from the file descriptor and making sure it 
                 // isn't a bad fd.
                 errno = 0;
-                int flags = ::fcntl (m_fd_send, F_GETFL, 0);
+#ifdef _POSIX_SOURCE
+                 int flags = ::fcntl (m_fd_send, F_GETFL, 0);
+#else
+                int flags = -1;
+#endif
                 if (flags == -1 || errno == EBADF)
                 {
                     if (error_ptr)
@@ -252,7 +266,9 @@
             const char *path = s + strlen("file://");
             do
             {
+#ifdef _POSIX_SOURCE
                 m_fd_send = m_fd_recv = ::open (path, O_RDWR);
+#endif				
             } while (m_fd_send == -1 && errno == EINTR);
             if (m_fd_send == -1)
             {
@@ -260,15 +276,20 @@
                     error_ptr->SetErrorToErrno();
                 return eConnectionStatusError;
             }
-
+#ifdef _POSIX_SOURCE
             int flags = ::fcntl (m_fd_send, F_GETFL, 0);
+#else
+			int flags = -1;
+#endif			
             if (flags >= 0)
             {
+#ifdef _POSIX_SOURCE			
                 if ((flags & O_NONBLOCK) == 0)
                 {
                     flags |= O_NONBLOCK;
                     ::fcntl (m_fd_send, F_SETFL, flags);
                 }
+#endif				
             }
             m_should_close_fd = true;
             return eConnectionStatusSuccess;
@@ -312,8 +333,10 @@
     {
         if (m_pipe_write != -1 )
         {
+#ifdef _POSIX_SOURCE
             write (m_pipe_write, "q", 1);
             close (m_pipe_write);
+#endif
             m_pipe_write = -1;
         }
         locker.Lock (m_mutex);
@@ -388,7 +411,9 @@
     {
         do
         {
+#ifdef _POSIX_SOURCE
             bytes_read = ::read (m_fd_recv, dst, dst_len);
+#endif			
         } while (bytes_read < 0 && errno == EINTR);
     }
 
@@ -490,6 +515,7 @@
 
     ssize_t bytes_sent = 0;
 
+#ifdef _POSIX_SOURCE
     switch (m_fd_send_type)
     {
         case eFDTypeFile:       // Other FD requireing read/write
@@ -519,6 +545,7 @@
             } while (bytes_sent < 0 && errno == EINTR);
             break;
     }
+#endif	
 
     if (bytes_sent < 0)
         error.SetErrorToErrno ();
@@ -677,7 +704,9 @@
                 
                 do
                 {
+#ifdef _POSIX_SOURCE
                     bytes_read = ::read (m_pipe_read, buffer, sizeof(buffer));
+#endif					
                 } while (bytes_read < 0 && errno == EINTR);
                 assert (bytes_read == 1 && buffer[0] == 'q');
                 
@@ -715,7 +744,9 @@
             if (log)
                 log->Printf ("%p ConnectionFileDescriptor::Close (fd = %i)", this,fd);
 
+#ifdef _POSIX_SOURCE
             success = ::close (fd) == 0;
+#endif			
             // A reference to a FD was passed in, set it to an invalid value
             fd = -1;
             if (!success && error_ptr)
@@ -736,6 +767,7 @@
 ConnectionStatus
 ConnectionFileDescriptor::NamedSocketAccept (const char *socket_name, Error *error_ptr)
 {
+#ifdef _POSIX_SOURCE
     ConnectionStatus result = eConnectionStatusError;
     struct sockaddr_un saddr_un;
 
@@ -780,11 +812,15 @@
     // We are done with the listen port
     Close (listen_socket, NULL);
     return result;
+#else
+    return eConnectionStatusError;
+#endif	
 }
 
 ConnectionStatus
 ConnectionFileDescriptor::NamedSocketConnect (const char *socket_name, Error *error_ptr)
 {
+#ifdef _POSIX_SOURCE
     Disconnect (NULL);
     m_fd_send_type = m_fd_recv_type = eFDTypeSocket;
 
@@ -815,11 +851,15 @@
     if (error_ptr)
         error_ptr->Clear();
     return eConnectionStatusSuccess;
+#else
+    return eConnectionStatusError;
+#endif
 }
 
 ConnectionStatus
 ConnectionFileDescriptor::SocketListen (uint16_t listen_port_num, Error *error_ptr)
 {
+#if _POSIX_SOURCE
     LogSP log(lldb_private::GetLogIfAnyCategoriesSet (LIBLLDB_LOG_CONNECTION));
     if (log)
         log->Printf ("%p ConnectionFileDescriptor::SocketListen (port = %i)", this, listen_port_num);
@@ -878,6 +918,9 @@
     if (error_ptr)
         error_ptr->Clear();
     return eConnectionStatusSuccess;
+#else
+    return eConnectionStatusError;
+#endif
 }
 
 ConnectionStatus
@@ -1051,7 +1094,7 @@
     return eConnectionStatusSuccess;
 }
 
-#if defined(__MINGW32__) || defined(__MINGW64__)
+#if defined(__MINGW32__) || defined(__MINGW64__) || defined(_MSC_VER)
 typedef const char * set_socket_option_arg_type;
 typedef char * get_socket_option_arg_type;
 #else // #if defined(__MINGW32__) || defined(__MINGW64__)
@@ -1062,7 +1105,7 @@
 int
 ConnectionFileDescriptor::GetSocketOption(int fd, int level, int option_name, int &option_value)
 {
-    get_socket_option_arg_type option_value_p = static_cast<get_socket_option_arg_type>(&option_value);
+    get_socket_option_arg_type option_value_p = reinterpret_cast<get_socket_option_arg_type>(&option_value);
     socklen_t option_value_size = sizeof(int);
 	return ::getsockopt(fd, level, option_name, option_value_p, &option_value_size);
 }
@@ -1070,10 +1113,17 @@
 int
 ConnectionFileDescriptor::SetSocketOption(int fd, int level, int option_name, int option_value)
 {
-    set_socket_option_arg_type option_value_p = static_cast<get_socket_option_arg_type>(&option_value);
+    set_socket_option_arg_type option_value_p = reinterpret_cast<get_socket_option_arg_type>(&option_value);
 	return ::setsockopt(fd, level, option_name, option_value_p, sizeof(option_value));
 }
 
+#ifdef _WIN32
+static unsigned long int tv2ms(struct timeval *a)
+{
+    return ((a->tv_sec * 1000) + (a->tv_usec / 1000));
+}
+#endif
+
 bool
 ConnectionFileDescriptor::SetSocketReceiveTimeout (uint32_t timeout_usec)
 {
@@ -1108,7 +1158,13 @@
                 timeout.tv_sec = timeout_usec / TimeValue::MicroSecPerSec;
                 timeout.tv_usec = timeout_usec % TimeValue::MicroSecPerSec;
             }
-            if (::setsockopt (m_fd_recv, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout)) == 0)
+#ifndef _WIN32
+            const void* timeopt = &timeout;
+#else
+            DWORD ms = tv2ms(&timeout);
+            const char* timeopt = reinterpret_cast<const char*>(ms);
+#endif
+            if (::setsockopt (m_fd_recv, SOL_SOCKET, SO_RCVTIMEO, timeopt, sizeof(timeopt)) == 0)
             {
                 m_socket_timeout_usec = timeout_usec;
                 return true;
Index: source/Core/ConnectionSharedMemory.cpp
===================================================================
--- source/Core/ConnectionSharedMemory.cpp	(revision 163322)
+++ source/Core/ConnectionSharedMemory.cpp	(working copy)
@@ -11,12 +11,16 @@
 
 // C Includes
 #include <errno.h>
+#ifdef LLDB_PTHREAD
 #include <pthread.h>
+#endif
 #include <stdlib.h>
+#ifdef _POSIX_SOURCE
 #include <sys/file.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#endif
 
 // C++ Includes
 // Other libraries and framework includes
@@ -70,12 +74,14 @@
 ConnectionStatus
 ConnectionSharedMemory::Disconnect (Error *error_ptr)
 {
+#ifdef _POSIX_SOURCE
     m_mmap.Clear();
     if (!m_name.empty())
     {
         shm_unlink (m_name.c_str());
         m_name.clear();
     }
+#endif
     return eConnectionStatusSuccess;
 }
 
@@ -106,6 +112,7 @@
 ConnectionStatus
 ConnectionSharedMemory::Open (bool create, const char *name, size_t size, Error *error_ptr)
 {
+#ifdef _POSIX_SOURCE
     if (m_fd != -1)
     {
         if (error_ptr)
@@ -126,6 +133,7 @@
         return eConnectionStatusSuccess;
 
     Disconnect(NULL);
+#endif
     return eConnectionStatusError;
 }
 
Index: source/Core/cxa_demangle.cpp
===================================================================
--- source/Core/cxa_demangle.cpp	(revision 163322)
+++ source/Core/cxa_demangle.cpp	(working copy)
@@ -7,6 +7,7 @@
 //
 //===----------------------------------------------------------------------===//
 
+#if defined(USE_BUILTIN_LIBCXXABI_DEMANGLER)
 #include "lldb/Core/cxa_demangle.h"
 
 #include <stdlib.h>
@@ -11009,3 +11010,5 @@
 //}  // extern "C"
 
 }  // lldb_cxxabiv1
+
+#endif
Index: source/Core/CXXFormatterFunctions.cpp
===================================================================
--- source/Core/CXXFormatterFunctions.cpp	(revision 163322)
+++ source/Core/CXXFormatterFunctions.cpp	(working copy)
@@ -666,7 +666,6 @@
     return true;
     
 }
-
 template bool
 lldb_private::formatters::NSDictionary_SummaryProvider<true> (ValueObject&, Stream&) ;
 
Index: source/Core/DataBufferMemoryMap.cpp
===================================================================
--- source/Core/DataBufferMemoryMap.cpp	(revision 163322)
+++ source/Core/DataBufferMemoryMap.cpp	(working copy)
@@ -12,7 +12,10 @@
 #include <fcntl.h>
 #include <limits.h>
 #include <sys/stat.h>
+
+#ifdef _POSIX_SOURCE
 #include <sys/mman.h>
+#endif
 
 #include "lldb/Core/DataBufferMemoryMap.h"
 #include "lldb/Core/Error.h"
@@ -80,7 +83,9 @@
 {
     if (m_mmap_addr != NULL)
     {
+#ifdef _POSIX_SOURCE
         ::munmap((void *)m_mmap_addr, m_mmap_size);
+#endif
         m_mmap_addr = NULL;
         m_mmap_size = 0;
         m_data = NULL;
@@ -152,6 +157,7 @@
         struct stat stat;
         if (::fstat(fd, &stat) == 0)
         {
+#ifdef _POSIX_SOURCE
             if (S_ISREG(stat.st_mode) && (stat.st_size > offset))
             {
                 const size_t max_bytes_available = stat.st_size - offset;
@@ -222,6 +228,7 @@
                     }
                 }
             }
+#endif
         }
     }
     return GetByteSize ();
Index: source/Core/FormatManager.cpp
===================================================================
--- source/Core/FormatManager.cpp	(revision 163322)
+++ source/Core/FormatManager.cpp	(working copy)
@@ -692,7 +692,7 @@
     LoadSystemFormatters();
     LoadSTLFormatters();
     LoadLibcxxFormatters();
-    LoadObjCFormatters();
+	LoadObjCFormatters();
     
     EnableCategory(m_objc_category_name,CategoryMap::Last);
     EnableCategory(m_corefoundation_category_name,CategoryMap::Last);
Index: source/Core/getopt.c
===================================================================
--- source/Core/getopt.c	(revision 0)
+++ source/Core/getopt.c	(working copy)
@@ -0,0 +1,511 @@
+/*  $OpenBSD: getopt_long.c,v 1.25 2011/03/05 22:10:11 guenther Exp $   */
+/*  $NetBSD: getopt_long.c,v 1.15 2002/01/31 22:43:40 tv Exp $  */
+
+/*
+ * Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Sponsored in part by the Defense Advanced Research Projects
+ * Agency (DARPA) and Air Force Research Laboratory, Air Force
+ * Materiel Command, USAF, under agreement number F39502-99-1-0512.
+ */
+/*-
+ * Copyright (c) 2000 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Dieter Baron and Thomas Klausner.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+int opterr = 1;     /* if error message should be printed */
+int optind = 1;     /* index into parent argv vector */
+int optopt = '?';   /* character checked for validity */
+int optreset;       /* reset getopt */
+char    *optarg;    /* argument associated with option */
+
+#define PRINT_ERROR ((opterr) && (*options != ':'))
+
+#define FLAG_PERMUTE    0x01    /* permute non-options to the end of argv */
+#define FLAG_ALLARGS    0x02    /* treat non-options as args to option "-1" */
+#define FLAG_LONGONLY   0x04    /* operate as getopt_long_only */
+
+/* return values */
+#define BADCH       (int)'?'
+#define BADARG      ((*options == ':') ? (int)':' : (int)'?')
+#define INORDER     (int)1
+
+#define EMSG        ""
+
+static int getopt_internal(int, char * const *, const char *,
+               const struct option *, int *, int);
+static int parse_long_options(char * const *, const char *,
+                  const struct option *, int *, int);
+static int gcd(int, int);
+static void permute_args(int, int, int, char * const *);
+
+static char *place = EMSG; /* option letter processing */
+
+/* XXX: set optreset to 1 rather than these two */
+static int nonopt_start = -1; /* first non option argument (for permute) */
+static int nonopt_end = -1;   /* first option after non options (for permute) */
+
+/* Error messages */
+static const char recargchar[] = "option requires an argument -- %c";
+static const char recargstring[] = "option requires an argument -- %s";
+static const char ambig[] = "ambiguous option -- %.*s";
+static const char noarg[] = "option doesn't take an argument -- %.*s";
+static const char illoptchar[] = "unknown option -- %c";
+static const char illoptstring[] = "unknown option -- %s";
+
+/*
+ * Compute the greatest common divisor of a and b.
+ */
+static int
+gcd(int a, int b)
+{
+    int c;
+
+    c = a % b;
+    while (c != 0) {
+        a = b;
+        b = c;
+        c = a % b;
+    }
+
+    return (b);
+}
+
+static void pass() {}
+#define warnx(a, ...) pass();
+
+/*
+ * Exchange the block from nonopt_start to nonopt_end with the block
+ * from nonopt_end to opt_end (keeping the same order of arguments
+ * in each block).
+ */
+static void
+permute_args(int panonopt_start, int panonopt_end, int opt_end,
+    char * const *nargv)
+{
+    int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
+    char *swap;
+
+    /*
+     * compute lengths of blocks and number and size of cycles
+     */
+    nnonopts = panonopt_end - panonopt_start;
+    nopts = opt_end - panonopt_end;
+    ncycle = gcd(nnonopts, nopts);
+    cyclelen = (opt_end - panonopt_start) / ncycle;
+
+    for (i = 0; i < ncycle; i++) {
+        cstart = panonopt_end+i;
+        pos = cstart;
+        for (j = 0; j < cyclelen; j++) {
+            if (pos >= panonopt_end)
+                pos -= nnonopts;
+            else
+                pos += nopts;
+            swap = nargv[pos];
+            /* LINTED const cast */
+            ((char **) nargv)[pos] = nargv[cstart];
+            /* LINTED const cast */
+            ((char **)nargv)[cstart] = swap;
+        }
+    }
+}
+
+/*
+ * parse_long_options --
+ *  Parse long options in argc/argv argument vector.
+ * Returns -1 if short_too is set and the option does not match long_options.
+ */
+static int
+parse_long_options(char * const *nargv, const char *options,
+    const struct option *long_options, int *idx, int short_too)
+{
+    char *current_argv, *has_equal;
+    size_t current_argv_len;
+    int i, match;
+
+    current_argv = place;
+    match = -1;
+
+    optind++;
+
+    if ((has_equal = strchr(current_argv, '=')) != NULL) {
+        /* argument found (--option=arg) */
+        current_argv_len = has_equal - current_argv;
+        has_equal++;
+    } else
+        current_argv_len = strlen(current_argv);
+
+    for (i = 0; long_options[i].name; i++) {
+        /* find matching long option */
+        if (strncmp(current_argv, long_options[i].name,
+            current_argv_len))
+            continue;
+
+        if (strlen(long_options[i].name) == current_argv_len) {
+            /* exact match */
+            match = i;
+            break;
+        }
+        /*
+         * If this is a known short option, don't allow
+         * a partial match of a single character.
+         */
+        if (short_too && current_argv_len == 1)
+            continue;
+
+        if (match == -1)    /* partial match */
+            match = i;
+        else {
+            /* ambiguous abbreviation */
+            if (PRINT_ERROR)
+                warnx(ambig, (int)current_argv_len,
+                     current_argv);
+            optopt = 0;
+            return (BADCH);
+        }
+    }
+    if (match != -1) {      /* option found */
+        if (long_options[match].has_arg == no_argument
+            && has_equal) {
+            if (PRINT_ERROR)
+                warnx(noarg, (int)current_argv_len,
+                     current_argv);
+            /*
+             * XXX: GNU sets optopt to val regardless of flag
+             */
+            if (long_options[match].flag == NULL)
+                optopt = long_options[match].val;
+            else
+                optopt = 0;
+            return (BADARG);
+        }
+        if (long_options[match].has_arg == required_argument ||
+            long_options[match].has_arg == optional_argument) {
+            if (has_equal)
+                optarg = has_equal;
+            else if (long_options[match].has_arg ==
+                required_argument) {
+                /*
+                 * optional argument doesn't use next nargv
+                 */
+                optarg = nargv[optind++];
+            }
+        }
+        if ((long_options[match].has_arg == required_argument)
+            && (optarg == NULL)) {
+            /*
+             * Missing argument; leading ':' indicates no error
+             * should be generated.
+             */
+            if (PRINT_ERROR)
+                warnx(recargstring,
+                    current_argv);
+            /*
+             * XXX: GNU sets optopt to val regardless of flag
+             */
+            if (long_options[match].flag == NULL)
+                optopt = long_options[match].val;
+            else
+                optopt = 0;
+            --optind;
+            return (BADARG);
+        }
+    } else {            /* unknown option */
+        if (short_too) {
+            --optind;
+            return (-1);
+        }
+        if (PRINT_ERROR)
+            warnx(illoptstring, current_argv);
+        optopt = 0;
+        return (BADCH);
+    }
+    if (idx)
+        *idx = match;
+    if (long_options[match].flag) {
+        *long_options[match].flag = long_options[match].val;
+        return (0);
+    } else
+        return (long_options[match].val);
+}
+
+/*
+ * getopt_internal --
+ *  Parse argc/argv argument vector.  Called by user level routines.
+ */
+static int
+getopt_internal(int nargc, char * const *nargv, const char *options,
+    const struct option *long_options, int *idx, int flags)
+{
+    const char *oli;                /* option letter list index */
+    int optchar, short_too;
+    static int posixly_correct = -1;
+
+    if (options == NULL)
+        return (-1);
+
+    /*
+     * XXX Some GNU programs (like cvs) set optind to 0 instead of
+     * XXX using optreset.  Work around this braindamage.
+     */
+    if (optind == 0)
+        optind = optreset = 1;
+
+    /*
+     * Disable GNU extensions if POSIXLY_CORRECT is set or options
+     * string begins with a '+'.
+     */
+    if (posixly_correct == -1 || optreset)
+        posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);
+    if (*options == '-')
+        flags |= FLAG_ALLARGS;
+    else if (posixly_correct || *options == '+')
+        flags &= ~FLAG_PERMUTE;
+    if (*options == '+' || *options == '-')
+        options++;
+
+    optarg = NULL;
+    if (optreset)
+        nonopt_start = nonopt_end = -1;
+start:
+    if (optreset || !*place) {      /* update scanning pointer */
+        optreset = 0;
+        if (optind >= nargc) {          /* end of argument vector */
+            place = EMSG;
+            if (nonopt_end != -1) {
+                /* do permutation, if we have to */
+                permute_args(nonopt_start, nonopt_end,
+                    optind, nargv);
+                optind -= nonopt_end - nonopt_start;
+            }
+            else if (nonopt_start != -1) {
+                /*
+                 * If we skipped non-options, set optind
+                 * to the first of them.
+                 */
+                optind = nonopt_start;
+            }
+            nonopt_start = nonopt_end = -1;
+            return (-1);
+        }
+        if (*(place = nargv[optind]) != '-' ||
+            (place[1] == '\0' && strchr(options, '-') == NULL)) {
+            place = EMSG;       /* found non-option */
+            if (flags & FLAG_ALLARGS) {
+                /*
+                 * GNU extension:
+                 * return non-option as argument to option 1
+                 */
+                optarg = nargv[optind++];
+                return (INORDER);
+            }
+            if (!(flags & FLAG_PERMUTE)) {
+                /*
+                 * If no permutation wanted, stop parsing
+                 * at first non-option.
+                 */
+                return (-1);
+            }
+            /* do permutation */
+            if (nonopt_start == -1)
+                nonopt_start = optind;
+            else if (nonopt_end != -1) {
+                permute_args(nonopt_start, nonopt_end,
+                    optind, nargv);
+                nonopt_start = optind -
+                    (nonopt_end - nonopt_start);
+                nonopt_end = -1;
+            }
+            optind++;
+            /* process next argument */
+            goto start;
+        }
+        if (nonopt_start != -1 && nonopt_end == -1)
+            nonopt_end = optind;
+
+        /*
+         * If we have "-" do nothing, if "--" we are done.
+         */
+        if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {
+            optind++;
+            place = EMSG;
+            /*
+             * We found an option (--), so if we skipped
+             * non-options, we have to permute.
+             */
+            if (nonopt_end != -1) {
+                permute_args(nonopt_start, nonopt_end,
+                    optind, nargv);
+                optind -= nonopt_end - nonopt_start;
+            }
+            nonopt_start = nonopt_end = -1;
+            return (-1);
+        }
+    }
+
+    /*
+     * Check long options if:
+     *  1) we were passed some
+     *  2) the arg is not just "-"
+     *  3) either the arg starts with -- we are getopt_long_only()
+     */
+    if (long_options != NULL && place != nargv[optind] &&
+        (*place == '-' || (flags & FLAG_LONGONLY))) {
+        short_too = 0;
+        if (*place == '-')
+            place++;        /* --foo long option */
+        else if (*place != ':' && strchr(options, *place) != NULL)
+            short_too = 1;      /* could be short option too */
+
+        optchar = parse_long_options(nargv, options, long_options,
+            idx, short_too);
+        if (optchar != -1) {
+            place = EMSG;
+            return (optchar);
+        }
+    }
+
+    if ((optchar = (int)*place++) == (int)':' ||
+        (optchar == (int)'-' && *place != '\0') ||
+        (oli = strchr(options, optchar)) == NULL) {
+        /*
+         * If the user specified "-" and  '-' isn't listed in
+         * options, return -1 (non-option) as per POSIX.
+         * Otherwise, it is an unknown option character (or ':').
+         */
+        if (optchar == (int)'-' && *place == '\0')
+            return (-1);
+        if (!*place)
+            ++optind;
+        if (PRINT_ERROR)
+            warnx(illoptchar, optchar);
+        optopt = optchar;
+        return (BADCH);
+    }
+    if (long_options != NULL && optchar == 'W' && oli[1] == ';') {
+        /* -W long-option */
+        if (*place)         /* no space */
+            /* NOTHING */;
+        else if (++optind >= nargc) {   /* no arg */
+            place = EMSG;
+            if (PRINT_ERROR)
+                warnx(recargchar, optchar);
+            optopt = optchar;
+            return (BADARG);
+        } else              /* white space */
+            place = nargv[optind];
+        optchar = parse_long_options(nargv, options, long_options,
+            idx, 0);
+        place = EMSG;
+        return (optchar);
+    }
+    if (*++oli != ':') {            /* doesn't take argument */
+        if (!*place)
+            ++optind;
+    } else {                /* takes (optional) argument */
+        optarg = NULL;
+        if (*place)         /* no white space */
+            optarg = place;
+        else if (oli[1] != ':') {   /* arg not optional */
+            if (++optind >= nargc) {    /* no arg */
+                place = EMSG;
+                if (PRINT_ERROR)
+                    warnx(recargchar, optchar);
+                optopt = optchar;
+                return (BADARG);
+            } else
+                optarg = nargv[optind];
+        }
+        place = EMSG;
+        ++optind;
+    }
+    /* dump back option letter */
+    return (optchar);
+}
+
+/*
+ * getopt --
+ *  Parse argc/argv argument vector.
+ *
+ * [eventually this will replace the BSD getopt]
+ */
+int
+getopt(int nargc, char * const *nargv, const char *options)
+{
+
+    /*
+     * We don't pass FLAG_PERMUTE to getopt_internal() since
+     * the BSD getopt(3) (unlike GNU) has never done this.
+     *
+     * Furthermore, since many privileged programs call getopt()
+     * before dropping privileges it makes sense to keep things
+     * as simple (and bug-free) as possible.
+     */
+    return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));
+}
+
+/*
+ * getopt_long --
+ *  Parse argc/argv argument vector.
+ */
+int
+getopt_long(int nargc, char * const *nargv, const char *options,
+    const struct option *long_options, int *idx)
+{
+    return (getopt_internal(nargc, nargv, options, long_options, idx,
+        FLAG_PERMUTE));
+}
+
+/*
+ * getopt_long_only --
+ *  Parse argc/argv argument vector.
+ */
+int
+getopt_long_only(int nargc, char * const *nargv, const char *options,
+    const struct option *long_options, int *idx)
+{
+
+    return (getopt_internal(nargc, nargv, options, long_options, idx,
+        FLAG_PERMUTE|FLAG_LONGONLY));
+}
\ No newline at end of file
Index: source/Core/Log.cpp
===================================================================
--- source/Core/Log.cpp	(revision 163322)
+++ source/Core/Log.cpp	(working copy)
@@ -8,11 +8,19 @@
 //===----------------------------------------------------------------------===//
 
 // C Includes
-#include <pthread.h>
 #include <stdio.h>
 #include <stdarg.h>
 #include <stdlib.h>
+#include <time.h>
+#ifdef _POSIX_SOURCE
+#include <pthread.h>
 #include <unistd.h>
+#endif
+#ifdef _WIN32
+#define NOMINMAX
+#include <Winsock2.h>
+#undef interface
+#endif
 
 // C++ Includes
 #include <map>
Index: source/Core/Mangled.cpp
===================================================================
--- source/Core/Mangled.cpp	(revision 163322)
+++ source/Core/Mangled.cpp	(working copy)
@@ -15,8 +15,10 @@
 #if defined(USE_BUILTIN_LIBCXXABI_DEMANGLER)
 #include "lldb/Core/cxa_demangle.h"
 #else
+#ifdef LLDB_LIBCXXABI
 #include <cxxabi.h>
 #endif
+#endif
 
 
 #include "llvm/ADT/DenseMap.h"
@@ -207,8 +209,12 @@
 #if defined(USE_BUILTIN_LIBCXXABI_DEMANGLER)
                 char *demangled_name = lldb_cxxabiv1::__cxa_demangle (mangled_cstr, NULL, NULL, NULL);
 #else
+#ifdef LLDB_LIBCXXABI
                 char *demangled_name = abi::__cxa_demangle (mangled_cstr, NULL, NULL, NULL);
+#else
+                char *demangled_name = 0;
 #endif
+#endif
 
                 if (demangled_name)
                 {
Index: source/Core/RegularExpression.cpp
===================================================================
--- source/Core/RegularExpression.cpp	(revision 163322)
+++ source/Core/RegularExpression.cpp	(working copy)
@@ -16,13 +16,9 @@
 // Default constructor
 //----------------------------------------------------------------------
 RegularExpression::RegularExpression() :
-    m_re(),
-    m_comp_err (1),
-    m_preg(),
-    m_compile_flags(REG_EXTENDED),
-    m_matches()
+	m_re(),
+	m_regex(llvm::StringRef())
 {
-    memset(&m_preg,0,sizeof(m_preg));
 }
 
 //----------------------------------------------------------------------
@@ -30,12 +26,9 @@
 // resulting compiled regular expression into this object.
 //----------------------------------------------------------------------
 RegularExpression::RegularExpression(const char* re, int flags) :
-    m_re(),
-    m_comp_err (1),
-    m_preg(),
-    m_compile_flags(flags)
+	m_re(),
+    m_regex(llvm::StringRef())
 {
-    memset(&m_preg,0,sizeof(m_preg));
     Compile(re);
 }
 
@@ -45,20 +38,18 @@
 //----------------------------------------------------------------------
 RegularExpression::RegularExpression(const char* re) :
     m_re(),
-    m_comp_err (1),
-    m_preg(),
-    m_compile_flags(REG_EXTENDED)
+    m_regex(llvm::StringRef())
 {
-    memset(&m_preg,0,sizeof(m_preg));
     Compile(re);
 }
 
-RegularExpression::RegularExpression(const RegularExpression &rhs)
-{
-    memset(&m_preg,0,sizeof(m_preg));
-    Compile(rhs.GetText(), rhs.GetCompileFlags());
-}
+RegularExpression::RegularExpression(const RegularExpression &rhs) :
+    m_regex(llvm::StringRef())
+ {
+     Compile(rhs.GetText(), rhs.GetCompileFlags());
+ }
 
+
 const RegularExpression &
 RegularExpression::operator= (const RegularExpression &rhs)
 {
@@ -76,7 +67,7 @@
 //----------------------------------------------------------------------
 RegularExpression::~RegularExpression()
 {
-    Free();
+
 }
 
 //----------------------------------------------------------------------
@@ -102,19 +93,10 @@
 {
     Free();
     m_compile_flags = flags;
-    
-    if (re && re[0])
-    {
-        m_re = re;
-        m_comp_err = ::regcomp (&m_preg, re, flags);
-    }
-    else
-    {
-        // No valid regular expression
-        m_comp_err = 1;
-    }
-
-    return m_comp_err == 0;
+    m_re = re;
+    m_regex = llvm::Regex(llvm::StringRef(re));
+ 
+    return IsValid();
 }
 
 //----------------------------------------------------------------------
@@ -128,40 +110,16 @@
 bool
 RegularExpression::Execute(const char* s, size_t num_matches, int execute_flags) const
 {
-    int match_result = 1;
-    if (m_comp_err == 0)
-    {
-        if (num_matches > 0)
-            m_matches.resize(num_matches + 1);
-        else
-            m_matches.clear();
-
-        match_result = ::regexec (&m_preg,
-                                  s,
-                                  m_matches.size(),
-                                  &m_matches[0],
-                                  execute_flags);
-    }
-    return match_result == 0;
+    return m_regex.match(llvm::StringRef(s), &m_matches);
 }
 
 bool
 RegularExpression::GetMatchAtIndex (const char* s, uint32_t idx, std::string& match_str) const
 {
-    if (idx <= m_preg.re_nsub && idx < m_matches.size())
+    if (idx < m_matches.size())
     {
-        if (m_matches[idx].rm_eo == m_matches[idx].rm_so)
-        {
-            // Matched the empty string...
-            match_str.clear();
-            return true;
-        }
-        else if (m_matches[idx].rm_eo > m_matches[idx].rm_so)
-        {
-            match_str.assign (s + m_matches[idx].rm_so,
-                              m_matches[idx].rm_eo - m_matches[idx].rm_so);
-            return true;
-        }
+        match_str = m_matches[idx];
+        return true;
     }
     return false;
 }
@@ -174,7 +132,8 @@
 bool
 RegularExpression::IsValid () const
 {
-    return m_comp_err == 0;
+    std::string err;
+    return m_regex.isValid(err);
 }
 
 //----------------------------------------------------------------------
@@ -195,26 +154,17 @@
 void
 RegularExpression::Free()
 {
-    if (m_comp_err == 0)
-    {
-        m_re.clear();
-        regfree(&m_preg);
-        // Set a compile error since we no longer have a valid regex
-        m_comp_err = 1;
-    }
+    m_re.clear();
+    m_regex = llvm::Regex(llvm::StringRef());
+    m_matches.clear();
 }
 
-size_t
-RegularExpression::GetErrorAsCString (char *err_str, size_t err_str_max_len) const
+std::string
+RegularExpression::GetErrorAsCString () const
 {
-    if (m_comp_err == 0)
-    {
-        if (err_str && err_str_max_len) 
-            *err_str = '\0';
-        return 0;
-    }
-    
-    return ::regerror (m_comp_err, &m_preg, err_str, err_str_max_len);
+    std::string err;
+    m_regex.isValid(err);
+    return err;
 }
 
 bool
Index: source/Core/Scalar.cpp
===================================================================
--- source/Core/Scalar.cpp	(revision 163322)
+++ source/Core/Scalar.cpp	(working copy)
@@ -17,7 +17,7 @@
 #include "lldb/Core/DataExtractor.h"
 #include "lldb/Host/Endian.h"
 
-#include "Plugins/Process/Utility/InstructionUtils.h"
+//#include "Plugins/Process/Utility/InstructionUtils.h"
 
 using namespace lldb;
 using namespace lldb_private;
@@ -2019,6 +2019,18 @@
     return bytes_copied;
 }
 
+int SignedBits(int data, uint32_t a, uint32_t b)
+{
+    // TODO
+    return 0;
+}
+
+int UnsignedBits(int data, uint32_t a, uint32_t b)
+{
+    // TODO
+    return 0;
+}
+
 bool
 Scalar::ExtractBitfield (uint32_t bit_size, 
                          uint32_t bit_offset)
Index: source/Core/Timer.cpp
===================================================================
--- source/Core/Timer.cpp	(revision 163322)
+++ source/Core/Timer.cpp	(working copy)
@@ -26,7 +26,12 @@
 FILE * Timer::g_file = NULL;
 typedef std::vector<Timer *> TimerStack;
 typedef std::map<const char *, uint64_t> CategoryMap;
+
+#ifdef _POSIX_SOURCE
 static pthread_key_t g_key;
+#else
+static DWORD g_key;
+#endif
 
 static Mutex &
 GetCategoryMutex()
@@ -46,6 +51,7 @@
 static TimerStack *
 GetTimerStackForCurrentThread ()
 {
+#ifdef _POSIX_SOURCE
     void *timer_stack = ::pthread_getspecific (g_key);
     if (timer_stack == NULL)
     {
@@ -53,6 +59,15 @@
         timer_stack = ::pthread_getspecific (g_key);
     }
     return (TimerStack *)timer_stack;
+#else
+    void *timer_stack = ::TlsGetValue  (g_key);
+    if (timer_stack == NULL)
+    {
+        ::TlsSetValue  (g_key, new TimerStack);
+        timer_stack = ::TlsGetValue (g_key);
+    }
+    return (TimerStack *)timer_stack;
+#endif
 }
 
 void
@@ -71,8 +86,11 @@
 Timer::Initialize ()
 {
     Timer::g_file = stdout;
+#ifdef _POSIX_SOURCE
     ::pthread_key_create (&g_key, ThreadSpecificCleanup);
-
+#else
+    g_key = ::TlsAlloc();
+#endif
 }
 
 Timer::Timer (const char *category, const char *format, ...) :
Index: source/Core/Windows.cpp
===================================================================
--- source/Core/Windows.cpp	(revision 0)
+++ source/Core/Windows.cpp	(working copy)
@@ -0,0 +1,191 @@
+//===-- Windows.cpp ---------------------------------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+// This file provides Windows support functions
+
+#include <ctype.h>
+#include <cstring>
+#include <cstdarg>
+#include <cstdlib>
+#include <cstdio>
+#include <cerrno>
+
+int strcasecmp(const char* s1, const char* s2)
+{
+  while (*s1 != '\0' && tolower(*s1) == tolower(*s2))
+    {
+      s1++;
+      s2++;
+    }
+
+  return tolower(*(unsigned char *) s1) - tolower(*(unsigned char *) s2);
+}
+
+int strncasecmp(const char* s1, const char* s2, size_t n)
+{
+  if (n == 0)
+    return 0;
+
+  while (n-- != 0 && tolower(*s1) == tolower(*s2))
+    {
+      if (n == 0 || *s1 == '\0' || *s2 == '\0')
+        break;
+      s1++;
+      s2++;
+    }
+
+  return tolower(*(unsigned char *) s1) - tolower(*(unsigned char *) s2);
+}
+
+char * strcasestr(const char *s, const char* find)
+{
+    char c, sc;
+    size_t len;
+
+    if ((c = *find++) != 0) {
+        c = tolower((unsigned char)c);
+        len = strlen(find);
+        do {
+            do {
+                if ((sc = *s++) == 0)
+                    return 0;
+            } while ((char)tolower((unsigned char)sc) != c);
+        } while (strncasecmp(s, find, len) != 0);
+        s--;
+    }
+    return ((char *)s);
+}
+
+int vasprintf(char **ret, const char *fmt, va_list ap)
+{
+    char *buf;
+    int len;
+    size_t buflen;
+    va_list ap2;
+    
+#if defined(_MSC_VER) || defined(__MINGW64)
+    ap2 = ap;
+    len = _vscprintf(fmt, ap2);
+#else
+    va_copy(ap2, ap);
+    len = vsnprintf(NULL, 0, fmt, ap2);
+#endif
+    
+    if (len >= 0 && (buf = (char*) malloc ((buflen = (size_t) (len + 1)))) != NULL) {
+        len = vsnprintf(buf, buflen, fmt, ap);
+        *ret = buf;
+    } else {
+        *ret = NULL;
+        len = -1;
+    }
+    
+    va_end(ap2);
+    return len;
+}
+
+int access(const char *path, int amode)
+{
+    return 0;
+}
+
+char* __cdecl realpath( const char * name, char * resolved )
+{
+  char *retname = NULL;  /* we will return this, if we fail */
+
+  /* SUSv3 says we must set `errno = EINVAL', and return NULL,
+   * if `name' is passed as a NULL pointer.
+   */
+
+  if( name == NULL )
+    errno = EINVAL;
+
+  /* Otherwise, `name' must refer to a readable filesystem object,
+   * if we are going to resolve its absolute path name.
+   */
+
+  else if( access( name, 4 ) == 0 )
+  {
+    /* If `name' didn't point to an existing entity,
+     * then we don't get to here; we simply fall past this block,
+     * returning NULL, with `errno' appropriately set by `access'.
+     *
+     * When we _do_ get to here, then we can use `_fullpath' to
+     * resolve the full path for `name' into `resolved', but first,
+     * check that we have a suitable buffer, in which to return it.
+     */
+
+    if( (retname = resolved) == NULL )
+    {
+      /* Caller didn't give us a buffer, so we'll exercise the
+       * option granted by SUSv3, and allocate one.
+       *
+       * `_fullpath' would do this for us, but it uses `malloc', and
+       * Microsoft's implementation doesn't set `errno' on failure.
+       * If we don't do this explicitly ourselves, then we will not
+       * know if `_fullpath' fails on `malloc' failure, or for some
+       * other reason, and we want to set `errno = ENOMEM' for the
+       * `malloc' failure case.
+       */
+
+      retname = (char*) malloc( _MAX_PATH );
+    }
+
+    /* By now, we should have a valid buffer.
+     * If we don't, then we know that `malloc' failed,
+     * so we can set `errno = ENOMEM' appropriately.
+     */
+
+    if( retname == NULL )
+      errno = ENOMEM;
+
+    /* Otherwise, when we do have a valid buffer,
+     * `_fullpath' should only fail if the path name is too long.
+     */
+
+    else if( (retname = _fullpath( retname, name, _MAX_PATH )) == NULL )
+      errno = ENAMETOOLONG;
+  }
+
+  /* By the time we get to here,
+   * `retname' either points to the required resolved path name,
+   * or it is NULL, with `errno' set appropriately, either of which
+   * is our required return condition.
+   */
+  
+  return retname;
+}
+
+long long int strtoll(const char *nptr, char **endptr, int base)
+{
+    return 0;
+}
+
+unsigned long long int strtoull(const char *nptr, char **endptr, int base)
+{
+    return 0;
+}
+
+//char* realpath( const char * name, char * resolved )
+//{
+//    return 0;
+//}
+
+char* basename(char *path)
+{
+    return 0;
+}
+
+char *dirname(char *path)
+{
+    return 0;
+}
+
+#include "lldb/lldb-windows.h"
+
+#include "getopt.c"
Index: source/Expression/ClangExpressionDeclMap.cpp
===================================================================
--- source/Expression/ClangExpressionDeclMap.cpp	(revision 163322)
+++ source/Expression/ClangExpressionDeclMap.cpp	(working copy)
@@ -13,6 +13,7 @@
 // C++ Includes
 // Other libraries and framework includes
 // Project includes
+#include "clang/AST/ASTContext.h"
 #include "clang/AST/DeclarationName.h"
 #include "clang/AST/Decl.h"
 #include "lldb/lldb-private.h"
@@ -1595,7 +1596,7 @@
     if (!var_sp)
     {
         err.SetErrorString("Invalid persistent variable");
-        return LLDB_INVALID_ADDRESS;
+        return /*LLDB_INVALID_ADDRESS*/false;
     }
     
     const size_t pvar_byte_size = var_sp->GetByteSize();
Index: source/Expression/ClangExpressionParser.cpp
===================================================================
--- source/Expression/ClangExpressionParser.cpp	(revision 163322)
+++ source/Expression/ClangExpressionParser.cpp	(working copy)
@@ -43,7 +43,12 @@
 #include "clang/Frontend/TextDiagnosticPrinter.h"
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Parse/ParseAST.h"
+#include "clang/Basic/Version.h"
+#if CLANG_VERSION_MAJOR > 3 || (CLANG_VERSION_MAJOR == 3 && CLANG_VERSION_MINOR  >= 2)
+#include "clang/Rewrite/Frontend/FrontendActions.h"
+#else
 #include "clang/Rewrite/FrontendActions.h"
+#endif
 #include "clang/Sema/SemaConsumer.h"
 #include "clang/StaticAnalyzer/Frontend/FrontendActions.h"
 
@@ -246,8 +251,10 @@
         {
             if (process_sp->GetObjCLanguageRuntime()->GetRuntimeVersion() == eAppleObjC_V2)
             {
+#if CLANG_MAJOR_VERSION == 3 && CLANG_MINOR_VERSION < 2
                 m_compiler->getLangOpts().ObjCNonFragileABI = true;     // NOT i386
                 m_compiler->getLangOpts().ObjCNonFragileABI2 = true;    // NOT i386
+#endif
             }
             
             if (process_sp->GetObjCLanguageRuntime()->HasNewLiteralsAndIndexing())
Index: source/Expression/CMakeLists.txt
===================================================================
--- source/Expression/CMakeLists.txt	(revision 0)
+++ source/Expression/CMakeLists.txt	(working copy)
@@ -0,0 +1,22 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbExpression
+  ASTDumper.cpp
+  ASTResultSynthesizer.cpp
+  ASTStructExtractor.cpp
+  ClangASTSource.cpp
+  ClangExpressionDeclMap.cpp
+  ClangExpressionParser.cpp
+  ClangExpressionVariable.cpp
+  ClangFunction.cpp
+  ClangPersistentVariables.cpp
+  ClangUserExpression.cpp
+  ClangUtilityFunction.cpp
+  DWARFExpression.cpp
+  ExpressionSourceCode.cpp
+  IRDynamicChecks.cpp
+  IRForTarget.cpp
+  IRInterpreter.cpp
+  ProcessDataAllocator.cpp
+  RecordingMemoryManager.cpp
+  )
Index: source/Expression/IRForTarget.cpp
===================================================================
--- source/Expression/IRForTarget.cpp	(revision 163322)
+++ source/Expression/IRForTarget.cpp	(working copy)
@@ -2679,7 +2679,7 @@
                                                    Constant::getNullValue(intptr_ty),
                                                    "reloc_placeholder",
                                                    NULL /* InsertBefore */,
-                                                   false /* ThreadLocal */,
+                                                   GlobalVariable::NotThreadLocal /* ThreadLocal */,
                                                    0 /* AddressSpace */);
         
     Function::iterator bbi;
Index: source/Expression/IRInterpreter.cpp
===================================================================
--- source/Expression/IRInterpreter.cpp	(revision 163322)
+++ source/Expression/IRInterpreter.cpp	(working copy)
@@ -1003,6 +1003,12 @@
     return true;
 }
 
+#ifdef _MSC_VER
+#define LLDB_ULL
+#else
+#define LLDB_ULL ull
+#endif
+
 bool 
 IRInterpreter::runOnFunction (lldb::ClangExpressionVariableSP &result,
                               const lldb_private::ConstString &result_name,
@@ -1032,12 +1038,12 @@
         err.SetErrorString(interpreter_initialization_error);
         return false;    
     case 4:
-        alloc_min = 0x00001000llu;
-        alloc_max = 0x0000ffffllu;
+        alloc_min = 0x00001000 LLDB_ULL;
+        alloc_max = 0x0000ffff LLDB_ULL;
         break;
     case 8:
-        alloc_min = 0x0000000000001000llu;
-        alloc_max = 0x000000000000ffffllu;
+        alloc_min = 0x0000000000001000 LLDB_ULL;
+        alloc_max = 0x000000000000ffff LLDB_ULL;
         break;
     }
     
Index: source/Host/CMakeLists.txt
===================================================================
--- source/Host/CMakeLists.txt	(revision 0)
+++ source/Host/CMakeLists.txt	(working copy)
@@ -0,0 +1,3 @@
+add_subdirectory(common)
+#add_subdirectory(linux)
+add_subdirectory(windows)
Index: source/Host/common/CMakeLists.txt
===================================================================
--- source/Host/common/CMakeLists.txt	(revision 0)
+++ source/Host/common/CMakeLists.txt	(working copy)
@@ -0,0 +1,13 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbHostCommon
+  Condition.cpp
+  File.cpp
+  FileSpec.cpp
+  Host.cpp
+  Mutex.cpp
+  SocketAddress.cpp
+  Symbols.cpp
+  Terminal.cpp
+  TimeValue.cpp
+  )
Index: source/Host/common/Condition.cpp
===================================================================
--- source/Host/common/Condition.cpp	(revision 163322)
+++ source/Host/common/Condition.cpp	(working copy)
@@ -24,7 +24,11 @@
 Condition::Condition () :
     m_condition()
 {
+#ifdef _WIN32
+    InitializeConditionVariable(&m_condition);
+#else
     ::pthread_cond_init (&m_condition, NULL);
+#endif
 }
 
 //----------------------------------------------------------------------
@@ -34,7 +38,9 @@
 //----------------------------------------------------------------------
 Condition::~Condition ()
 {
+#ifndef _WIN32
     ::pthread_cond_destroy (&m_condition);
+#endif
 }
 
 //----------------------------------------------------------------------
@@ -43,9 +49,14 @@
 int
 Condition::Broadcast ()
 {
+#ifdef _WIN32
+    WakeAllConditionVariable(&m_condition);
+    return 0;
+#else
     return ::pthread_cond_broadcast (&m_condition);
+#endif
 }
-
+#ifndef _WIN32
 //----------------------------------------------------------------------
 // Get accessor to the pthread condition object
 //----------------------------------------------------------------------
@@ -54,14 +65,19 @@
 {
     return &m_condition;
 }
-
+#endif
 //----------------------------------------------------------------------
 // Unblocks one thread waiting for the condition variable
 //----------------------------------------------------------------------
 int
 Condition::Signal ()
 {
+#ifdef _WIN32
+    WakeConditionVariable(&m_condition);
+    return 0;
+#else
     return ::pthread_cond_signal (&m_condition);
+#endif
 }
 
 //----------------------------------------------------------------------
@@ -77,9 +93,33 @@
 //
 // The current thread re-acquires the lock on "mutex".
 //----------------------------------------------------------------------
+
+/* convert struct timeval to ms(milliseconds) */
+static unsigned long int tv2ms(struct timeval a) {
+    return ((a.tv_sec * 1000) + (a.tv_usec / 1000));
+}
+
 int
 Condition::Wait (Mutex &mutex, const TimeValue *abstime, bool *timed_out)
 {
+#ifdef _WIN32
+    DWORD wait = INFINITE;
+    if (abstime != NULL)
+        wait = tv2ms(abstime->GetAsTimeVal());
+
+    int err = SleepConditionVariableCS(&m_condition, (PCRITICAL_SECTION)&mutex,
+        wait);
+
+    if (timed_out != NULL)
+    {
+        if ((err == 0) && GetLastError() == ERROR_TIMEOUT)
+            *timed_out = true;
+        else
+            *timed_out = false;
+    }
+
+    return err != 0;
+#else
     int err = 0;
     do
     {
@@ -100,7 +140,7 @@
             *timed_out = false;
     }
 
-
     return err;
+#endif
 }
 
Index: source/Host/common/File.cpp
===================================================================
--- source/Host/common/File.cpp	(revision 163322)
+++ source/Host/common/File.cpp	(working copy)
@@ -16,6 +16,11 @@
 #include <stdarg.h>
 #include <sys/stat.h>
 
+#ifdef _WIN32
+#include <io.h>
+typedef uint32_t mode_t;
+#endif
+
 #include "lldb/Core/DataBufferHeap.h"
 #include "lldb/Core/Error.h"
 #include "lldb/Host/Config.h"
@@ -167,7 +172,11 @@
 
     if (rhs.DescriptorIsValid())
     {
+#ifdef _WIN32
+        m_descriptor = ::_dup(rhs.GetDescriptor());
+#else
         m_descriptor = ::fcntl(rhs.GetDescriptor(), F_DUPFD);
+#endif
         if (!DescriptorIsValid())
             error.SetErrorToErrno();
         else
@@ -217,10 +226,13 @@
         oflag |= O_RDONLY;
     }
     
+#ifndef _WIN32
     if (options & eOpenOptionNonBlocking)
         oflag |= O_NONBLOCK;
+#endif
 
     mode_t mode = 0;
+#ifndef _WIN32
     if (oflag & O_CREAT)
     {
         if (permissions & ePermissionsUserRead)     mode |= S_IRUSR;
@@ -233,6 +245,7 @@
         if (permissions & ePermissionsWorldWrite)   mode |= S_IWOTH;
         if (permissions & ePermissionsWorldExecute) mode |= S_IXOTH;
     }
+#endif
 
     do
     {
@@ -401,6 +414,11 @@
     Error error;
     if (DescriptorIsValid())
     {
+#ifdef _WIN32
+        int err = FlushFileBuffers((HANDLE)_get_osfhandle(m_descriptor));
+        if (err == 0)
+            error.SetErrorToGenericError();
+#else
         int err = 0;
         do
         {
@@ -409,6 +427,7 @@
         
         if (err == -1)
             error.SetErrorToErrno();
+#endif
     }
     else 
     {
@@ -508,6 +527,7 @@
 Error
 File::Read (void *buf, size_t &num_bytes, off_t &offset)
 {
+#ifndef _WIN32
     Error error;
     int fd = GetDescriptor();
     if (fd != kInvalidDescriptor)
@@ -535,6 +555,13 @@
         error.SetErrorString("invalid file handle");
     }
     return error;
+#else
+    long cur = ::lseek(m_descriptor, 0, SEEK_CUR);
+    Error error = Read(buf, num_bytes);
+    if (!error.Fail())
+        SeekFromStart(cur);
+    return error;
+#endif
 }
 
 Error
@@ -597,6 +624,7 @@
     int fd = GetDescriptor();
     if (fd != kInvalidDescriptor)
     {
+#ifndef _WIN32
         ssize_t bytes_written = -1;
         do
         {
@@ -613,6 +641,17 @@
             offset += bytes_written;
             num_bytes = bytes_written;
         }
+#else
+        long cur = ::lseek(m_descriptor, 0, SEEK_CUR);
+        error = Write(buf, num_bytes);
+        long after = ::lseek(m_descriptor, 0, SEEK_CUR);
+        
+        if (!error.Fail())
+            SeekFromStart(cur);
+        
+        ssize_t bytes_written = after - cur;
+        offset = after;
+#endif
     }
     else 
     {
Index: source/Host/common/FileSpec.cpp
===================================================================
--- source/Host/common/FileSpec.cpp	(revision 163322)
+++ source/Host/common/FileSpec.cpp	(working copy)
@@ -10,8 +10,12 @@
 
 #include <dirent.h>
 #include <fcntl.h>
+
+#ifdef _POSIX_SOURCE
 #include <libgen.h>
 #include <sys/stat.h>
+#endif
+
 #include <string.h>
 #include <fstream>
 
@@ -46,6 +50,13 @@
     return false;
 }
 
+#ifdef _WIN32
+char* realpath( const char * name, char * resolved );
+char* basename(char *path);
+char *dirname(char *path);
+typedef uint32_t mode_t;
+#endif
+
 #ifdef LLDB_CONFIG_TILDE_RESOLVES_TO_USER
 
 static const char*
@@ -917,9 +928,11 @@
                 case DT_REG:        file_type = eFileTypeRegular;       call_callback = find_files;         break;
                 case DT_LNK:        file_type = eFileTypeSymbolicLink;  call_callback = find_other;         break;
                 case DT_SOCK:       file_type = eFileTypeSocket;        call_callback = find_other;         break;
+#ifndef _WIN32
 #if !defined(__OpenBSD__)
                 case DT_WHT:        file_type = eFileTypeOther;         call_callback = find_other;         break;
 #endif
+#endif
                 }
 
                 if (call_callback)
@@ -990,7 +1003,7 @@
     if (extension)
     {
         static RegularExpression g_source_file_regex ("^(c|m|mm|cpp|c\\+\\+|cxx|cc|cp|s|asm|f|f77|f90|f95|f03|for|ftn|fpp|ada|adb|ads)$",
-                                                      REG_EXTENDED | REG_ICASE);
+                                                      llvm::Regex::IgnoreCase);
         return g_source_file_regex.Execute (extension.GetCString());
     }
     return false;
Index: source/Host/common/Host.cpp
===================================================================
--- source/Host/common/Host.cpp	(revision 163322)
+++ source/Host/common/Host.cpp	(working copy)
@@ -25,15 +25,18 @@
 #include "llvm/Support/Host.h"
 #include "llvm/Support/MachO.h"
 
+#include <errno.h>
+#include <limits.h>
+
+#ifdef __unix__
 #include <dlfcn.h>
-#include <errno.h>
 #include <grp.h>
-#include <limits.h>
 #include <netdb.h>
 #include <pwd.h>
+#endif
+
 #include <sys/types.h>
 
-
 #if defined (__APPLE__)
 
 #include <dispatch/dispatch.h>
@@ -67,7 +70,7 @@
     bool monitor_signals;                       // If true, call the callback when "pid" gets signaled.
 };
 
-static void *
+static thread_result_t
 MonitorChildProcessThreadFunction (void *arg);
 
 lldb::thread_t
@@ -102,6 +105,7 @@
 // constructed, and exception safely restore the previous value it
 // when it goes out of scope.
 //------------------------------------------------------------------
+#ifndef _WIN32
 class ScopedPThreadCancelDisabler
 {
 public:
@@ -124,8 +128,8 @@
 private:
     int m_old_state;    // Save the old cancelability state.
 };
-
-static void *
+#endif
+static thread_result_t
 MonitorChildProcessThreadFunction (void *arg)
 {
     LogSP log(lldb_private::GetLogIfAllCategoriesSet (LIBLLDB_LOG_PROCESS));
@@ -144,6 +148,8 @@
 
     int status = -1;
     const int options = 0;
+
+#ifndef _WIN32
     while (1)
     {
         log = lldb_private::GetLogIfAllCategoriesSet (LIBLLDB_LOG_PROCESS);
@@ -224,12 +230,16 @@
             }
         }
     }
-
+#endif
     log = lldb_private::GetLogIfAllCategoriesSet (LIBLLDB_LOG_PROCESS);
     if (log)
         log->Printf ("%s (arg = %p) thread exiting...", __FUNCTION__, arg);
 
+#ifdef _WIN32
+    return 0;
+#else
     return NULL;
+#endif
 }
 
 
@@ -253,7 +263,18 @@
 size_t
 Host::GetPageSize()
 {
+#ifdef _WIN32
+    static long g_pagesize = 0;
+    if (!g_pagesize)
+    {
+        SYSTEM_INFO systemInfo;
+        GetNativeSystemInfo(&systemInfo);
+        g_pagesize = systemInfo.dwPageSize;
+    }
+    return g_pagesize;
+#else
     return ::getpagesize();
+#endif
 }
 
 const ArchSpec &
@@ -427,6 +448,8 @@
     return ::mach_thread_self();
 #elif defined(__FreeBSD__)
     return lldb::tid_t(pthread_getthreadid_np());
+#elif defined(_WIN32)
+    return lldb::tid_t(::GetCurrentThreadId());
 #else
     return lldb::tid_t(pthread_self());
 #endif
@@ -435,12 +458,17 @@
 lldb::thread_t
 Host::GetCurrentThread ()
 {
+#ifdef _WIN32
+    return lldb::thread_t(::GetCurrentThread());
+#else
     return lldb::thread_t(pthread_self());
+#endif
 }
 
 const char *
 Host::GetSignalAsCString (int signo)
 {
+#ifndef _WIN32
     switch (signo)
     {
     case SIGHUP:    return "SIGHUP";    // 1    hangup
@@ -486,6 +514,7 @@
     default:
         break;
     }
+#endif
     return NULL;
 }
 
@@ -530,6 +559,9 @@
 };
 
 static thread_result_t
+#ifdef _WIN32
+__stdcall
+#endif
 ThreadCreateTrampoline (thread_arg_t arg)
 {
     HostThreadCreateInfo *info = (HostThreadCreateInfo *)arg;
@@ -559,7 +591,13 @@
     // Host::ThreadCreateTrampoline will delete this pointer for us.
     HostThreadCreateInfo *info_ptr = new HostThreadCreateInfo (thread_name, thread_fptr, thread_arg);
     
+#ifdef _WIN32
+    thread = ::_beginthreadex(0, 0, ThreadCreateTrampoline, info_ptr, 0, NULL);
+    int err = thread;
+#else
     int err = ::pthread_create (&thread, NULL, ThreadCreateTrampoline, info_ptr);
+#endif
+
     if (err == 0)
     {
         if (error)
@@ -576,28 +614,41 @@
 bool
 Host::ThreadCancel (lldb::thread_t thread, Error *error)
 {
+#ifdef _WIN32
+    int err = ::TerminateThread((HANDLE)thread, 0);
+#else
     int err = ::pthread_cancel (thread);
     if (error)
         error->SetError(err, eErrorTypePOSIX);
+#endif
     return err == 0;
 }
 
 bool
 Host::ThreadDetach (lldb::thread_t thread, Error *error)
 {
+#ifdef _WIN32
+    return ThreadCancel(thread, error);
+#else
     int err = ::pthread_detach (thread);
     if (error)
         error->SetError(err, eErrorTypePOSIX);
     return err == 0;
+#endif
 }
 
 bool
 Host::ThreadJoin (lldb::thread_t thread, thread_result_t *thread_result_ptr, Error *error)
 {
+#ifdef _WIN32
+    WaitForSingleObject((HANDLE) thread, INFINITE);
+    return true;
+#else
     int err = ::pthread_join (thread, thread_result_ptr);
     if (error)
         error->SetError(err, eErrorTypePOSIX);
     return err == 0;
+#endif
 }
 
 // rdar://problem/8153284
@@ -609,7 +660,9 @@
 // Another approach is to introduce a static guard object which monitors its
 // own destruction and raises a flag, but this incurs more overhead.
 
+#ifndef _WIN32
 static pthread_once_t g_thread_map_once = PTHREAD_ONCE_INIT;
+#endif
 static ThreadSafeSTLMap<uint64_t, std::string> *g_thread_names_map_ptr;
 
 static void
@@ -625,9 +678,11 @@
 static const char *
 ThreadNameAccessor (bool get, lldb::pid_t pid, lldb::tid_t tid, const char *name)
 {
+#ifndef _WIN32
     int success = ::pthread_once (&g_thread_map_once, InitThreadNamesMap);
     if (success != 0)
         return NULL;
+#endif
     
     uint64_t pid_tid = ((uint64_t)pid << 32) | (uint64_t)tid;
 
@@ -753,12 +808,14 @@
 Host::GetModuleFileSpecForHostAddress (const void *host_addr)
 {
     FileSpec module_filespec;
+#ifdef __unix__
     Dl_info info;
     if (::dladdr (host_addr, &info))
     {
         if (info.dli_fname)
             module_filespec.SetFile(info.dli_fname, true);
     }
+#endif
     return module_filespec;
 }
 
@@ -796,6 +853,7 @@
 void *
 Host::DynamicLibraryOpen (const FileSpec &file_spec, uint32_t options, Error &error)
 {
+#ifndef _WIN32
     char path[PATH_MAX];
     if (file_spec.GetPath(path, sizeof(path)))
     {
@@ -833,6 +891,7 @@
     {
         error.SetErrorString("failed to extract path");
     }
+#endif
     return NULL;
 }
 
@@ -840,6 +899,7 @@
 Host::DynamicLibraryClose (void *opaque)
 {
     Error error;
+#ifndef _WIN32
     if (opaque == NULL)
     {
         error.SetErrorString ("invalid dynamic library handle");
@@ -856,6 +916,7 @@
         dylib_info->handle = 0;
         delete dylib_info;
     }
+#endif
     return error;
 }
 
@@ -869,7 +930,7 @@
     else
     {
         DynamicLibraryInfo *dylib_info = (DynamicLibraryInfo *) opaque;
-
+#ifndef _WIN32
         void *symbol_addr = ::dlsym (dylib_info->handle, symbol_name);
         if (symbol_addr)
         {
@@ -898,6 +959,7 @@
         {
             error.SetErrorString(::dlerror());
         }
+#endif
     }
     return NULL;
 }
@@ -1116,6 +1178,7 @@
 const char *
 Host::GetUserName (uint32_t uid, std::string &user_name)
 {
+#ifndef _WIN32
     struct passwd user_info;
     struct passwd *user_info_ptr = &user_info;
     char user_buffer[PATH_MAX];
@@ -1133,12 +1196,14 @@
         }
     }
     user_name.clear();
+#endif
     return NULL;
 }
 
 const char *
 Host::GetGroupName (uint32_t gid, std::string &group_name)
 {
+#ifndef _WIN32
     char group_buffer[PATH_MAX];
     size_t group_buffer_size = sizeof(group_buffer);
     struct group group_info;
@@ -1169,6 +1234,7 @@
         }
     }
     group_name.clear();
+#endif
     return NULL;
 }
 
@@ -1191,25 +1257,41 @@
 uint32_t
 Host::GetUserID ()
 {
+#ifdef _WIN32
+    return 0;
+#else
     return getuid();
+#endif
 }
 
 uint32_t
 Host::GetGroupID ()
 {
+#ifdef _WIN32
+    return 0;
+#else
     return getgid();
+#endif
 }
 
 uint32_t
 Host::GetEffectiveUserID ()
 {
+#ifdef _WIN32
+    return 0;
+#else
     return geteuid();
+#endif
 }
 
 uint32_t
 Host::GetEffectiveGroupID ()
 {
+#ifdef _WIN32
+    return 0;
+#else
     return getegid();
+#endif
 }
 
 #if !defined (__APPLE__)
@@ -1287,8 +1369,10 @@
     // Now wait for a handshake back from that thread running Host::RunShellCommand
     // so we know that we can delete shell_info_ptr
     shell_info->can_delete.WaitForValueEqualTo(true);
+#ifdef _POSIX_SOURCE
     // Sleep a bit to allow the shell_info->can_delete.SetValue() to complete...
     usleep(1000);
+#endif
     // Now delete the shell info that was passed into this function
     delete shell_info;
     return true;
@@ -1357,9 +1441,10 @@
         if (timed_out)
         {
             error.SetErrorString("timed out waiting for shell command to complete");
-            
+#ifdef _POSIX_SOURCE
             // Kill the process since it didn't complete withint the timeout specified
             ::kill (pid, SIGKILL);
+#endif
             // Wait for the monitor callback to get the message
             timeout_time = TimeValue::Now();
             timeout_time.OffsetWithSeconds(1);
Index: source/Host/common/Mutex.cpp
===================================================================
--- source/Host/common/Mutex.cpp	(revision 163322)
+++ source/Host/common/Mutex.cpp	(working copy)
@@ -12,7 +12,6 @@
 
 #include <string.h>
 #include <stdio.h>
-#include <unistd.h>
 
 #if 0
 // This logging is way too verbose to enable even for a log channel. 
@@ -184,6 +183,7 @@
 Mutex::Mutex () :
     m_mutex()
 {
+#ifdef _POSIX_SOURCE
     int err;
     err = ::pthread_mutex_init (&m_mutex, NULL);
 #if ENABLE_MUTEX_ERROR_CHECKING
@@ -191,6 +191,7 @@
         error_check_mutex (&m_mutex, eMutexActionInitialized);
 #endif
     assert(err == 0);
+#endif;
 }
 
 //----------------------------------------------------------------------
@@ -201,6 +202,7 @@
 Mutex::Mutex (Mutex::Type type) :
     m_mutex()
 {
+#ifdef _POSIX_SOURCE
     int err;
     ::pthread_mutexattr_t attr;
     err = ::pthread_mutexattr_init (&attr);
@@ -232,6 +234,7 @@
     assert(err == 0);
     err = ::pthread_mutexattr_destroy (&attr);
     assert(err == 0);
+#endif
 }
 
 //----------------------------------------------------------------------
@@ -241,6 +244,7 @@
 //----------------------------------------------------------------------
 Mutex::~Mutex()
 {
+#ifdef _POSIX_SOURCE
     int err;
     err = ::pthread_mutex_destroy (&m_mutex);
 #if ENABLE_MUTEX_ERROR_CHECKING
@@ -253,17 +257,19 @@
     }
     memset (&m_mutex, '\xba', sizeof(m_mutex));
 #endif
+#endif
 }
 
 //----------------------------------------------------------------------
 // Mutex get accessor.
 //----------------------------------------------------------------------
+#ifdef _POSIX_SOURCE
 pthread_mutex_t *
 Mutex::GetMutex()
 {
     return &m_mutex;
 }
-
+#endif
 //----------------------------------------------------------------------
 // Locks the mutex owned by this object, if the mutex is already
 // locked, the calling thread will block until the mutex becomes
@@ -275,6 +281,7 @@
 int
 Mutex::Lock()
 {
+#ifdef _POSIX_SOURCE
     DEBUG_LOG ("[%4.4llx/%4.4llx] pthread_mutex_lock (%p)...\n", Host::GetCurrentProcessID(), Host::GetCurrentThreadID(), &m_mutex);
 
 #if ENABLE_MUTEX_ERROR_CHECKING
@@ -293,6 +300,8 @@
 #endif
     DEBUG_LOG ("[%4.4llx/%4.4llx] pthread_mutex_lock (%p) => %i\n", Host::GetCurrentProcessID(), Host::GetCurrentThreadID(), &m_mutex, err);
     return err;
+#endif
+    return m_mutex.acquire();
 }
 
 //----------------------------------------------------------------------
@@ -306,6 +315,7 @@
 int
 Mutex::TryLock(const char *failure_message)
 {
+#ifdef _POSIX_SOURCE
 #if ENABLE_MUTEX_ERROR_CHECKING
     error_check_mutex (&m_mutex, eMutexActionAssertInitialized);
 #endif
@@ -313,6 +323,8 @@
     int err = ::pthread_mutex_trylock (&m_mutex);
     DEBUG_LOG ("[%4.4llx/%4.4llx] pthread_mutex_trylock (%p) => %i\n", Host::GetCurrentProcessID(), Host::GetCurrentThreadID(), &m_mutex, err);
     return err;
+#endif
+    return m_mutex.tryacquire();
 }
 
 //----------------------------------------------------------------------
@@ -327,6 +339,7 @@
 int
 Mutex::Unlock()
 {
+#ifdef _POSIX_SOURCE
 #if ENABLE_MUTEX_ERROR_CHECKING
     error_check_mutex (&m_mutex, eMutexActionAssertInitialized);
 #endif
@@ -342,6 +355,8 @@
 #endif
     DEBUG_LOG ("[%4.4llx/%4.4llx] pthread_mutex_unlock (%p) => %i\n", Host::GetCurrentProcessID(), Host::GetCurrentThreadID(), &m_mutex, err);
     return err;
+#endif
+    return m_mutex.release();
 }
 
 #ifdef LLDB_CONFIGURATION_DEBUG
Index: source/Host/common/Terminal.cpp
===================================================================
--- source/Host/common/Terminal.cpp	(revision 163322)
+++ source/Host/common/Terminal.cpp	(working copy)
@@ -11,7 +11,6 @@
 #include "lldb/Host/Config.h"
 
 #include <fcntl.h>
-#include <unistd.h>
 #include <signal.h>
 
 #ifdef LLDB_CONFIG_TERMIOS_SUPPORTED
@@ -24,7 +23,11 @@
 bool
 Terminal::IsATerminal () const
 {
+#ifdef _POSIX_SOURCE
     return m_fd >= 0 && ::isatty (m_fd);
+#else
+    return false;
+#endif
 }
     
 
@@ -131,7 +134,10 @@
     m_tty.SetFileDescriptor(fd);
     if (m_tty.IsATerminal())
     {
+#ifdef _POSIX_SOURCE
         m_tflags = ::fcntl (fd, F_GETFL, 0);
+#endif
+
 #ifdef LLDB_CONFIG_TERMIOS_SUPPORTED
         if (m_termios_ap.get() == NULL)
             m_termios_ap.reset (new struct termios);
@@ -139,9 +145,11 @@
         if (err != 0)
             m_termios_ap.reset();
 #endif // #ifdef LLDB_CONFIG_TERMIOS_SUPPORTED
+#ifdef _POSIX_SOURCE
         if (save_process_group)
             m_process_group = ::tcgetpgrp (0);
         else
+#endif
             m_process_group = -1;
     }
     else
@@ -164,8 +172,10 @@
     if (IsValid())
     {
         const int fd = m_tty.GetFileDescriptor();
+#ifdef _POSIX_SOURCE
         if (TFlagsIsValid())
             fcntl (fd, F_SETFL, m_tflags);
+#endif
 
 #ifdef LLDB_CONFIG_TERMIOS_SUPPORTED
         if (TTYStateIsValid())
@@ -174,6 +184,7 @@
 
         if (ProcessGroupIsValid())
         {
+#ifdef _POSIX_SOURCE
             // Save the original signal handler.
             void (*saved_sigttou_callback) (int) = NULL;
             saved_sigttou_callback = (void (*)(int)) signal (SIGTTOU, SIG_IGN);
@@ -181,6 +192,7 @@
             tcsetpgrp (fd, m_process_group);
             // Restore the original signal handler.
             signal (SIGTTOU, saved_sigttou_callback);
+#endif
         }
         return true;
     }
Index: source/Host/common/TimeValue.cpp
===================================================================
--- source/Host/common/TimeValue.cpp	(revision 163322)
+++ source/Host/common/TimeValue.cpp	(working copy)
@@ -37,11 +37,12 @@
 {
 }
 
+#ifdef _POSIX_SOURCE
 TimeValue::TimeValue(const struct timespec& ts) :
     m_nano_seconds ((uint64_t) ts.tv_sec * NanoSecPerSec + ts.tv_nsec)
 {
 }
-
+#endif
 TimeValue::TimeValue(const struct timeval& tv) :
     m_nano_seconds ((uint64_t) tv.tv_sec * NanoSecPerSec + (uint64_t) tv.tv_usec * NanoSecPerMicroSec)
 {
@@ -73,8 +74,7 @@
     return m_nano_seconds / NanoSecPerSec;
 }
 
-
-
+#ifdef _POSIX_SOURCE
 struct timespec
 TimeValue::GetAsTimeSpec () const
 {
@@ -83,6 +83,7 @@
     ts.tv_nsec = m_nano_seconds % NanoSecPerSec;
     return ts;
 }
+#endif
 
 struct timeval
 TimeValue::GetAsTimeVal () const
@@ -127,7 +128,9 @@
 TimeValue::Now()
 {
     struct timeval tv;
+#ifdef _POSIX_SOURCE
     gettimeofday(&tv, NULL);
+#endif
     TimeValue now(tv);
     return now;
 }
@@ -148,6 +151,7 @@
     if (s == NULL)
         return;
 
+#ifdef _POSIX_SOURCE
     char time_buf[32];
     time_t time = GetAsSecondsSinceJan1_1970();
     char *time_cstr = ::ctime_r(&time, time_buf);
@@ -163,6 +167,7 @@
     }
     else if (width > 0)
         s->Printf("%-*s", width, "");
+#endif
 }
 
 bool
Index: source/Host/linux/CMakeLists.txt
===================================================================
--- source/Host/linux/CMakeLists.txt	(revision 0)
+++ source/Host/linux/CMakeLists.txt	(working copy)
@@ -0,0 +1,5 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbHostLinux
+  Host.cpp
+  )
Index: source/Host/windows/CMakeLists.txt
===================================================================
--- source/Host/windows/CMakeLists.txt	(revision 0)
+++ source/Host/windows/CMakeLists.txt	(working copy)
@@ -0,0 +1,6 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbHostWindows
+  Host.cpp
+  ReadWriteLock.cpp
+  )
Index: source/Host/windows/Host.cpp
===================================================================
--- source/Host/windows/Host.cpp	(revision 0)
+++ source/Host/windows/Host.cpp	(working copy)
@@ -0,0 +1,59 @@
+//===-- source/Host/linux/Host.cpp ------------------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+// C Includes
+#include <stdio.h>
+
+// C++ Includes
+// Other libraries and framework includes
+// Project includes
+#include "lldb/Core/Error.h"
+#include "lldb/Target/Process.h"
+
+#include "lldb/Host/Host.h"
+#include "lldb/Core/DataBufferHeap.h"
+#include "lldb/Core/DataExtractor.h"
+
+using namespace lldb;
+using namespace lldb_private;
+
+bool
+Host::GetOSVersion(uint32_t &major, 
+                   uint32_t &minor, 
+                   uint32_t &update)
+{
+    OSVERSIONINFOEX info;
+    
+    ZeroMemory(&info, sizeof(OSVERSIONINFOEX));
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
+    
+    if (GetVersionEx((LPOSVERSIONINFO) &info) == 0) {
+        return false;
+    }
+
+    major = (uint32_t) info.dwMajorVersion;
+    minor = (uint32_t) info.dwMinorVersion;
+    update = (uint32_t) info.wServicePackMajor;
+
+    return true;
+}
+
+Error
+Host::LaunchProcess (ProcessLaunchInfo &launch_info)
+{
+    Error error;
+    assert(!"Not implemented yet!!!");
+    return error;
+}
+
+lldb::DataBufferSP
+Host::GetAuxvData(lldb_private::Process *process)
+{
+    return 0;
+}
Index: source/Host/windows/ReadWriteLock.cpp
===================================================================
--- source/Host/windows/ReadWriteLock.cpp	(revision 0)
+++ source/Host/windows/ReadWriteLock.cpp	(working copy)
@@ -0,0 +1,173 @@
+#include "lldb/Host/ReadWriteLock.h"
+
+namespace lldb_private {
+
+// Windows has slim read-writer lock support on Vista and higher, so we
+// will attempt to load the APIs.  If they exist, we will use them, and
+// if not, we will fall back on critical sections.  When we drop support
+// for XP, we can stop lazy-loading these APIs and just use them directly.
+#if defined(__MINGW32__)
+  // Taken from WinNT.h
+  typedef struct _RTL_SRWLOCK {
+    PVOID Ptr;
+  } RTL_SRWLOCK, *PRTL_SRWLOCK;
+
+  // Taken from WinBase.h
+  typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;
+#endif
+
+
+typedef struct Win32RWLOCK {
+        unsigned long int readlockcount;
+        HANDLE writable;
+        CRITICAL_SECTION writelock;
+} Win32RWLOCK;
+
+typedef Win32RWLOCK* PWin32RWLOCK; 
+
+static VOID (WINAPI *fpInitializeSRWLock)(PSRWLOCK lock) = NULL;
+static VOID (WINAPI *fpAcquireSRWLockExclusive)(PSRWLOCK lock) = NULL;
+static VOID (WINAPI *fpAcquireSRWLockShared)(PSRWLOCK lock) = NULL;
+static VOID (WINAPI *fpReleaseSRWLockExclusive)(PSRWLOCK lock) = NULL;
+static VOID (WINAPI *fpReleaseSRWLockShared)(PSRWLOCK lock) = NULL;
+static BOOL (WINAPI *fpTryAcquireSRWLockExclusive)(PSRWLOCK lock) = NULL;
+static BOOL (WINAPI *fpTryAcquireSRWLockShared)(PSRWLOCK lock) = NULL;
+
+static bool sHasSRW = false;
+
+static bool loadSRW() {
+  static bool sChecked = false;
+  if (!sChecked) {
+    sChecked = true;
+
+    HMODULE hLib = ::LoadLibrary(TEXT("Kernel32"));
+    if (hLib) {
+      fpInitializeSRWLock =
+        (VOID (WINAPI *)(PSRWLOCK))::GetProcAddress(hLib,
+                                               "InitializeSRWLock");
+      fpAcquireSRWLockExclusive =
+        (VOID (WINAPI *)(PSRWLOCK))::GetProcAddress(hLib,
+                                               "AcquireSRWLockExclusive");
+      fpAcquireSRWLockShared =
+        (VOID (WINAPI *)(PSRWLOCK))::GetProcAddress(hLib,
+                                               "AcquireSRWLockShared");
+      fpReleaseSRWLockExclusive =
+        (VOID (WINAPI *)(PSRWLOCK))::GetProcAddress(hLib,
+                                               "ReleaseSRWLockExclusive");
+      fpReleaseSRWLockShared =
+        (VOID (WINAPI *)(PSRWLOCK))::GetProcAddress(hLib,
+                                               "ReleaseSRWLockShared");
+      fpTryAcquireSRWLockExclusive =
+        (BOOL (WINAPI *)(PSRWLOCK))::GetProcAddress(hLib,
+                                               "TryAcquireSRWLockExclusive");
+      fpTryAcquireSRWLockShared =
+        (BOOL (WINAPI *)(PSRWLOCK))::GetProcAddress(hLib,
+                                               "TryAcquireSRWLockShared");      
+          
+      ::FreeLibrary(hLib);
+
+      if (fpInitializeSRWLock != NULL) {
+        sHasSRW = true;
+      }
+    }
+  }
+  return sHasSRW;
+}
+
+ReadWriteLock::ReadWriteLock () {
+    if (loadSRW()) {
+        m_data = calloc(1, sizeof(SRWLOCK));
+        fpInitializeSRWLock(static_cast<PSRWLOCK>(m_data));
+    } else {
+        m_data = calloc(1, sizeof(Win32RWLOCK));
+        static_cast<PWin32RWLOCK>(m_data)->readlockcount = 0;
+        static_cast<PWin32RWLOCK>(m_data)->writable = CreateEvent(NULL, true, true, NULL);
+        InitializeCriticalSection(&static_cast<PWin32RWLOCK>(m_data)->writelock);
+    }
+}
+
+ReadWriteLock::~ReadWriteLock () {
+    if (!sHasSRW) {
+        CloseHandle(static_cast<PWin32RWLOCK>(m_data)->writable);
+        DeleteCriticalSection(&static_cast<PWin32RWLOCK>(m_data)->writelock);
+    }
+    free(m_data);
+}
+
+bool ReadWriteLock::ReadLock () {
+    if (sHasSRW) {
+        fpAcquireSRWLockShared(static_cast<PSRWLOCK>(m_data));
+        return true;
+    } else {
+        EnterCriticalSection(&static_cast<PWin32RWLOCK>(m_data)->writelock);
+        InterlockedIncrement(&static_cast<PWin32RWLOCK>(m_data)->readlockcount);
+        ResetEvent(static_cast<PWin32RWLOCK>(m_data)->writable);
+        LeaveCriticalSection(&static_cast<PWin32RWLOCK>(m_data)->writelock);
+        return true;
+    }
+}
+
+bool ReadWriteLock::ReadTryLock () {
+    if (sHasSRW) {
+        return fpTryAcquireSRWLockShared(static_cast<PSRWLOCK>(m_data)) != 0;
+    } else {
+        if (TryEnterCriticalSection(&static_cast<PWin32RWLOCK>(m_data)->writelock)) {
+            InterlockedIncrement(&static_cast<PWin32RWLOCK>(m_data)->readlockcount);
+            ResetEvent(static_cast<PWin32RWLOCK>(m_data)->writable);
+            LeaveCriticalSection(&static_cast<PWin32RWLOCK>(m_data)->writelock);
+            return true;
+        }
+        return false;
+    }
+}
+
+bool ReadWriteLock::ReadUnlock () {
+    if (sHasSRW) {
+        fpReleaseSRWLockShared(static_cast<PSRWLOCK>(m_data));
+        return true;
+    } else {
+        if (InterlockedDecrement(&static_cast<PWin32RWLOCK>(m_data)->readlockcount) == 0)
+            SetEvent(static_cast<PWin32RWLOCK>(m_data)->writable);
+        return true;
+    }
+}
+
+bool ReadWriteLock::WriteLock () {
+    if (sHasSRW) {
+        fpAcquireSRWLockExclusive(static_cast<PSRWLOCK>(m_data));
+        return true;
+    } else {
+        EnterCriticalSection(&static_cast<PWin32RWLOCK>(m_data)->writelock);
+        WaitForSingleObject(static_cast<PWin32RWLOCK>(m_data)->writable, INFINITE);
+        return true;
+    }
+}
+
+bool ReadWriteLock::WriteTryLock () {
+    if (sHasSRW) {
+        return fpTryAcquireSRWLockExclusive(static_cast<PSRWLOCK>(m_data)) != 0;
+    } else {
+        if (TryEnterCriticalSection(&static_cast<PWin32RWLOCK>(m_data)->writelock)) {
+            if (!WaitForSingleObject(static_cast<PWin32RWLOCK>(m_data)->writable, 0)) {
+                LeaveCriticalSection(&static_cast<PWin32RWLOCK>(m_data)->writelock);
+                return false;
+            }
+            return true;
+        }
+        return false;
+    }
+}
+
+bool ReadWriteLock::WriteUnlock () {
+    if (sHasSRW) {
+        fpReleaseSRWLockExclusive(static_cast<PSRWLOCK>(m_data));
+        return true;
+    } else {
+        LeaveCriticalSection(&static_cast<PWin32RWLOCK>(m_data)->writelock);
+        return true;
+    }
+}
+
+
+
+}
Index: source/Interpreter/Args.cpp
===================================================================
--- source/Interpreter/Args.cpp	(revision 163322)
+++ source/Interpreter/Args.cpp	(working copy)
@@ -8,7 +8,9 @@
 //===----------------------------------------------------------------------===//
 
 // C Includes
+#ifdef _POSIX_SOURCE
 #include <getopt.h>
+#endif
 #include <cstdlib>
 // C++ Includes
 // Other libraries and framework includes
Index: source/Interpreter/CMakeLists.txt
===================================================================
--- source/Interpreter/CMakeLists.txt	(revision 0)
+++ source/Interpreter/CMakeLists.txt	(working copy)
@@ -0,0 +1,44 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbInterpreter
+  Args.cpp
+  CommandInterpreter.cpp
+  CommandObject.cpp
+  CommandObjectRegexCommand.cpp
+  CommandObjectScript.cpp
+  CommandReturnObject.cpp
+  OptionGroupArchitecture.cpp
+  OptionGroupBoolean.cpp
+  OptionGroupFile.cpp
+  OptionGroupFormat.cpp
+  OptionGroupOutputFile.cpp
+  OptionGroupPlatform.cpp
+  OptionGroupUInt64.cpp
+  OptionGroupUUID.cpp
+  OptionGroupValueObjectDisplay.cpp
+  OptionValue.cpp
+  OptionValueArch.cpp
+  OptionValueArgs.cpp
+  OptionValueArray.cpp
+  OptionValueBoolean.cpp
+  OptionValueDictionary.cpp
+  OptionValueEnumeration.cpp
+  OptionValueFileSpec.cpp
+  OptionValueFileSpecLIst.cpp
+  OptionValueFormat.cpp
+  OptionValuePathMappings.cpp
+  OptionValueProperties.cpp
+  OptionValueRegex.cpp
+  OptionValueSInt64.cpp
+  OptionValueString.cpp
+  OptionValueUInt64.cpp
+  OptionValueUUID.cpp
+  OptionGroupVariable.cpp
+  OptionGroupWatchpoint.cpp
+  Options.cpp
+  Property.cpp
+  PythonDataObjects.cpp
+  ScriptInterpreter.cpp
+  ScriptInterpreterNone.cpp
+  ScriptInterpreterPython.cpp
+  )
Index: source/Interpreter/CommandInterpreter.cpp
===================================================================
--- source/Interpreter/CommandInterpreter.cpp	(revision 163322)
+++ source/Interpreter/CommandInterpreter.cpp	(working copy)
@@ -10,7 +10,9 @@
 #include <string>
 #include <vector>
 
+#ifdef _POSIX_SOURCE
 #include <getopt.h>
+#endif
 #include <stdlib.h>
 
 #include "CommandObjectScript.h"
Index: source/Interpreter/CommandObject.cpp
===================================================================
--- source/Interpreter/CommandObject.cpp	(revision 163322)
+++ source/Interpreter/CommandObject.cpp	(working copy)
@@ -12,7 +12,9 @@
 #include <string>
 #include <map>
 
+#ifdef _POSIX_SOURCE
 #include <getopt.h>
+#endif
 #include <stdlib.h>
 #include <ctype.h>
 
Index: source/Interpreter/OptionValueProperties.cpp
===================================================================
--- source/Interpreter/OptionValueProperties.cpp	(revision 163322)
+++ source/Interpreter/OptionValueProperties.cpp	(working copy)
@@ -647,6 +647,7 @@
 OptionValueProperties::DeepCopy () const
 {
     assert(!"this shouldn't happen");
+    return NULL;
 }
 
 const Property *
Index: source/Interpreter/OptionValueRegex.cpp
===================================================================
--- source/Interpreter/OptionValueRegex.cpp	(revision 163322)
+++ source/Interpreter/OptionValueRegex.cpp	(working copy)
@@ -67,11 +67,7 @@
         }
         else
         {
-            char regex_error[1024];
-            if (m_regex.GetErrorAsCString(regex_error, sizeof(regex_error)))
-                error.SetErrorString (regex_error);
-            else
-                error.SetErrorStringWithFormat ("regex error %u", m_regex.GetErrorCode());
+			error.SetErrorString (m_regex.GetErrorAsCString().data());
         }
         break;
     }
Index: source/lldb.cpp
===================================================================
--- source/lldb.cpp	(revision 163322)
+++ source/lldb.cpp	(working copy)
@@ -22,8 +22,6 @@
 
 #include "llvm/ADT/StringRef.h"
 
-#include "Plugins/ABI/MacOSX-i386/ABIMacOSX_i386.h"
-#include "Plugins/ABI/MacOSX-arm/ABIMacOSX_arm.h"
 #include "Plugins/ABI/SysV-x86_64/ABISysV_x86_64.h"
 #include "Plugins/Disassembler/llvm/DisassemblerLLVM.h"
 #include "Plugins/Disassembler/llvm/DisassemblerLLVMC.h"
@@ -38,12 +36,12 @@
 #include "Plugins/UnwindAssembly/InstEmulation/UnwindAssemblyInstEmulation.h"
 #include "Plugins/ObjectFile/PECOFF/ObjectFilePECOFF.h"
 #include "Plugins/DynamicLoader/POSIX-DYLD/DynamicLoaderPOSIXDYLD.h"
-#include "Plugins/Platform/FreeBSD/PlatformFreeBSD.h"
-#include "Plugins/Platform/Linux/PlatformLinux.h"
 #ifndef LLDB_DISABLE_PYTHON
 #include "Plugins/OperatingSystem/Python/OperatingSystemPython.h"
 #endif
 #if defined (__APPLE__)
+#include "Plugins/ABI/MacOSX-i386/ABIMacOSX_i386.h"
+#include "Plugins/ABI/MacOSX-arm/ABIMacOSX_arm.h"
 #include "Plugins/DynamicLoader/MacOSX-DYLD/DynamicLoaderMacOSXDYLD.h"
 #include "Plugins/DynamicLoader/Darwin-Kernel/DynamicLoaderDarwinKernel.h"
 #include "Plugins/OperatingSystem/Darwin-Kernel/OperatingSystemDarwinKernel.h"
@@ -62,15 +60,21 @@
 #include "Plugins/Process/mach-core/ProcessMachCore.h"
 
 #if defined (__linux__)
+#include "Plugins/Platform/Linux/PlatformLinux.h"
 #include "Plugins/Process/Linux/ProcessLinux.h"
 #endif
 
 #if defined (__FreeBSD__)
+#include "Plugins/Platform/FreeBSD/PlatformFreeBSD.h"
 #include "Plugins/Process/gdb-remote/ProcessGDBRemote.h"
 #include "Plugins/Process/POSIX/ProcessPOSIX.h"
 #include "Plugins/Process/FreeBSD/ProcessFreeBSD.h"
 #endif
 
+#if defined(_WIN32) || defined(_WIN64)
+#include "Plugins/Platform/Windows/PlatformWindows.h"
+#endif
+
 #include "Plugins/Platform/gdb-server/PlatformRemoteGDBServer.h"
 #include "Plugins/DynamicLoader/Static/DynamicLoaderStatic.h"
 
@@ -92,6 +96,11 @@
         Timer::Initialize ();
         Timer scoped_timer (__PRETTY_FUNCTION__, __PRETTY_FUNCTION__);
         
+#ifdef _WIN32
+        PlatformWindows::Initialize();
+#endif
+
+#ifndef _WIN32
         ABIMacOSX_i386::Initialize();
         ABIMacOSX_arm::Initialize();
         ABISysV_x86_64::Initialize();
@@ -106,8 +115,7 @@
         EmulateInstructionARM::Initialize ();
         ObjectFilePECOFF::Initialize ();
         DynamicLoaderPOSIXDYLD::Initialize ();
-        PlatformFreeBSD::Initialize();
-        PlatformLinux::Initialize();
+#endif
 #ifndef LLDB_DISABLE_PYTHON
         OperatingSystemPython::Initialize();
 #endif
@@ -146,9 +154,12 @@
         //----------------------------------------------------------------------
         // Platform agnostic plugins
         //----------------------------------------------------------------------
+#ifndef _WIN32 // TODO: Enable this for Windows later
         PlatformRemoteGDBServer::Initialize ();
+#endif
+
         DynamicLoaderStatic::Initialize();
-
+      
         // Scan for any system or user LLDB plug-ins
         PluginManager::Initialize();
 
@@ -173,6 +184,7 @@
     // Terminate and unload and loaded system or user LLDB plug-ins
     PluginManager::Terminate();
 
+#ifndef _WIN32
     ABIMacOSX_i386::Terminate();
     ABIMacOSX_arm::Terminate();
     ABISysV_x86_64::Terminate();
@@ -187,8 +199,7 @@
     EmulateInstructionARM::Terminate ();
     ObjectFilePECOFF::Terminate ();
     DynamicLoaderPOSIXDYLD::Terminate ();
-    PlatformFreeBSD::Terminate();
-    PlatformLinux::Terminate();
+#endif
 #ifndef LLDB_DISABLE_PYTHON
     OperatingSystemPython::Terminate();
 #endif
@@ -215,10 +226,12 @@
     Debugger::SettingsTerminate ();
 
 #if defined (__linux__)
+	PlatformLinux::Terminate();
     ProcessLinux::Terminate();
 #endif
 
 #if defined (__FreeBSD__)
+	PlatformFreeBSD::Terminate();
     ProcessFreeBSD::Terminate();
     ProcessGDBRemote::Terminate();
 #endif
@@ -228,7 +241,13 @@
     Log::Terminate();
 }
 
-extern "C" const double liblldb_coreVersionNumber;
+#ifndef _WIN32
+ extern "C" const double liblldb_coreVersionNumber;
+#else
+const unsigned char liblldb_coreVersionString[] = "LLDB-win32-1";
+const double liblldb_coreVersionNumber = (double) 1.0;
+#endif
+
 const char *
 lldb_private::GetVersion ()
 {
Index: source/Plugins/ABI/CMakeLists.txt
===================================================================
--- source/Plugins/ABI/CMakeLists.txt	(revision 0)
+++ source/Plugins/ABI/CMakeLists.txt	(working copy)
@@ -0,0 +1 @@
+add_subdirectory(SysV-x86_64)
Index: source/Plugins/ABI/SysV-x86_64/CMakeLists.txt
===================================================================
--- source/Plugins/ABI/SysV-x86_64/CMakeLists.txt	(revision 0)
+++ source/Plugins/ABI/SysV-x86_64/CMakeLists.txt	(working copy)
@@ -0,0 +1,5 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginABISysV_x86_64
+  ABISysV_x86_64.cpp
+  )
Index: source/Plugins/CMakeLists.txt
===================================================================
--- source/Plugins/CMakeLists.txt	(revision 0)
+++ source/Plugins/CMakeLists.txt	(working copy)
@@ -0,0 +1,13 @@
+add_subdirectory(ABI)
+add_subdirectory(Disassembler)
+add_subdirectory(DynamicLoader)
+add_subdirectory(Instruction)
+add_subdirectory(LanguageRuntime)
+add_subdirectory(ObjectContainer)
+add_subdirectory(ObjectFile)
+add_subdirectory(OperatingSystem)
+add_subdirectory(Platform)
+add_subdirectory(Process)
+add_subdirectory(SymbolFile)
+add_subdirectory(SymbolVendor)
+add_subdirectory(UnwindAssembly)
Index: source/Plugins/Disassembler/CMakeLists.txt
===================================================================
--- source/Plugins/Disassembler/CMakeLists.txt	(revision 0)
+++ source/Plugins/Disassembler/CMakeLists.txt	(working copy)
@@ -0,0 +1 @@
+add_subdirectory(llvm)
Index: source/Plugins/Disassembler/llvm/CMakeLists.txt
===================================================================
--- source/Plugins/Disassembler/llvm/CMakeLists.txt	(revision 0)
+++ source/Plugins/Disassembler/llvm/CMakeLists.txt	(working copy)
@@ -0,0 +1,6 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginDisassemblerLLVM
+  DisassemblerLLVM.cpp
+  DisassemblerLLVMC.cpp
+  )
Index: source/Plugins/Disassembler/llvm/DisassemblerLLVMC.cpp
===================================================================
--- source/Plugins/Disassembler/llvm/DisassemblerLLVMC.cpp	(revision 163322)
+++ source/Plugins/Disassembler/llvm/DisassemblerLLVMC.cpp	(working copy)
@@ -23,7 +23,7 @@
 #include "lldb/Target/Target.h"
 #include "lldb/Target/StackFrame.h"
 
-#include <regex.h>
+#include "lldb/Core/RegularExpression.h"
 
 using namespace lldb;
 using namespace lldb_private;
@@ -303,7 +303,7 @@
                         m_does_branch = eLazyBoolNo;
                 }
             }
-            
+#if 0
             if (!s_regex_compiled)
             {
                 ::regcomp(&s_regex, "[ \t]*([^ ^\t]+)[ \t]*([^ ^\t].*)?", REG_EXTENDED);
@@ -319,6 +319,7 @@
                 if (matches[2].rm_so != -1)
                     m_mnemocics.assign(out_string + matches[2].rm_so, matches[2].rm_eo - matches[2].rm_so);
             }
+#endif
         }
     }
     
@@ -423,11 +424,11 @@
     LazyBool                m_does_branch;
     
     static bool             s_regex_compiled;
-    static ::regex_t        s_regex;
+    static lldb::RegularExpressionSP s_regex;
 };
 
 bool InstructionLLVMC::s_regex_compiled = false;
-::regex_t InstructionLLVMC::s_regex;
+lldb::RegularExpressionSP InstructionLLVMC::s_regex;
 
 Disassembler *
 DisassemblerLLVMC::CreateInstance (const ArchSpec &arch)
@@ -597,7 +598,7 @@
     default:
         break;
     case 1:
-        bzero (tag_bug, sizeof(::LLVMOpInfo1));
+        memset (tag_bug, '\0', sizeof(::LLVMOpInfo1));
         break;
     }
     return 0;
Index: source/Plugins/DynamicLoader/CMakeLists.txt
===================================================================
--- source/Plugins/DynamicLoader/CMakeLists.txt	(revision 0)
+++ source/Plugins/DynamicLoader/CMakeLists.txt	(working copy)
@@ -0,0 +1,4 @@
+#add_subdirectory(Darwin-Kernel)
+#add_subdirectory(MacOSX-DYLD)
+#add_subdirectory(POSIX-DYLD)
+add_subdirectory(Static)
Index: source/Plugins/DynamicLoader/Static/CMakeLists.txt
===================================================================
--- source/Plugins/DynamicLoader/Static/CMakeLists.txt	(revision 0)
+++ source/Plugins/DynamicLoader/Static/CMakeLists.txt	(working copy)
@@ -0,0 +1,5 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginDynamicLoaderStatic
+  DynamicLoaderStatic.cpp
+  )
Index: source/Plugins/Instruction/CMakeLists.txt
===================================================================
--- source/Plugins/Instruction/CMakeLists.txt	(revision 0)
+++ source/Plugins/Instruction/CMakeLists.txt	(working copy)
@@ -0,0 +1 @@
+#add_subdirectory(ARM)
Index: source/Plugins/LanguageRuntime/CMakeLists.txt
===================================================================
--- source/Plugins/LanguageRuntime/CMakeLists.txt	(revision 0)
+++ source/Plugins/LanguageRuntime/CMakeLists.txt	(working copy)
@@ -0,0 +1,2 @@
+add_subdirectory(CPlusPlus)
+#add_subdirectory(ObjC)
Index: source/Plugins/LanguageRuntime/CPlusPlus/CMakeLists.txt
===================================================================
--- source/Plugins/LanguageRuntime/CPlusPlus/CMakeLists.txt	(revision 0)
+++ source/Plugins/LanguageRuntime/CPlusPlus/CMakeLists.txt	(working copy)
@@ -0,0 +1,2 @@
+add_subdirectory(ItaniumABI)
+#add_subdirectory(MicrosoftABI)
Index: source/Plugins/LanguageRuntime/CPlusPlus/ItaniumABI/CMakeLists.txt
===================================================================
--- source/Plugins/LanguageRuntime/CPlusPlus/ItaniumABI/CMakeLists.txt	(revision 0)
+++ source/Plugins/LanguageRuntime/CPlusPlus/ItaniumABI/CMakeLists.txt	(working copy)
@@ -0,0 +1,5 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginCXXItaniumABI
+  ItaniumABILanguageRuntime.cpp
+  )
Index: source/Plugins/ObjectContainer/BSD-Archive/CMakeLists.txt
===================================================================
--- source/Plugins/ObjectContainer/BSD-Archive/CMakeLists.txt	(revision 0)
+++ source/Plugins/ObjectContainer/BSD-Archive/CMakeLists.txt	(working copy)
@@ -0,0 +1,5 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginObjectContainerBSDArchive
+  ObjectContainerBSDArchive.cpp
+  )
Index: source/Plugins/ObjectContainer/CMakeLists.txt
===================================================================
--- source/Plugins/ObjectContainer/CMakeLists.txt	(revision 0)
+++ source/Plugins/ObjectContainer/CMakeLists.txt	(working copy)
@@ -0,0 +1,2 @@
+#add_subdirectory(BSD-Archive)
+#add_subdirectory(Universal-Mach-O)
Index: source/Plugins/ObjectFile/CMakeLists.txt
===================================================================
--- source/Plugins/ObjectFile/CMakeLists.txt	(revision 0)
+++ source/Plugins/ObjectFile/CMakeLists.txt	(working copy)
@@ -0,0 +1,3 @@
+add_subdirectory(ELF)
+add_subdirectory(Mach-O)
+add_subdirectory(PECOFF)
Index: source/Plugins/ObjectFile/ELF/CMakeLists.txt
===================================================================
--- source/Plugins/ObjectFile/ELF/CMakeLists.txt	(revision 0)
+++ source/Plugins/ObjectFile/ELF/CMakeLists.txt	(working copy)
@@ -0,0 +1,6 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginObjectFileELF
+  ELFHeader.cpp
+  ObjectFileELF.cpp
+  )
Index: source/Plugins/ObjectFile/Mach-O/CMakeLists.txt
===================================================================
--- source/Plugins/ObjectFile/Mach-O/CMakeLists.txt	(revision 0)
+++ source/Plugins/ObjectFile/Mach-O/CMakeLists.txt	(working copy)
@@ -0,0 +1,5 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginObjectFileMachO
+  ObjectFileMachO.cpp
+  )
Index: source/Plugins/ObjectFile/Mach-O/ObjectFileMachO.cpp
===================================================================
--- source/Plugins/ObjectFile/Mach-O/ObjectFileMachO.cpp	(revision 163322)
+++ source/Plugins/ObjectFile/Mach-O/ObjectFileMachO.cpp	(working copy)
@@ -36,6 +36,7 @@
 #include "Plugins/Process/Utility/RegisterContextDarwin_i386.h"
 #include "Plugins/Process/Utility/RegisterContextDarwin_x86_64.h"
 
+
 using namespace lldb;
 using namespace lldb_private;
 using namespace llvm::MachO;
@@ -1246,7 +1247,7 @@
             function_starts_load_command.cmd = lc.cmd;
             function_starts_load_command.cmdsize = lc.cmdsize;
             if (m_data.GetU32(&offset, &function_starts_load_command.dataoff, 2) == NULL) // fill in symoff, nsyms, stroff, strsize fields
-                bzero (&function_starts_load_command, sizeof(function_starts_load_command));
+                memset (&function_starts_load_command, 0, sizeof(function_starts_load_command));
             break;
 
         default:
Index: source/Plugins/ObjectFile/PECOFF/CMakeLists.txt
===================================================================
--- source/Plugins/ObjectFile/PECOFF/CMakeLists.txt	(revision 0)
+++ source/Plugins/ObjectFile/PECOFF/CMakeLists.txt	(working copy)
@@ -0,0 +1,5 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginObjectFilePECOFF
+  ObjectFilePECOFF.cpp
+  )
Index: source/Plugins/ObjectFile/PECOFF/ObjectFilePECOFF.cpp
===================================================================
--- source/Plugins/ObjectFile/PECOFF/ObjectFilePECOFF.cpp	(revision 163322)
+++ source/Plugins/ObjectFile/PECOFF/ObjectFilePECOFF.cpp	(working copy)
@@ -26,6 +26,7 @@
 
 static uint32_t COFFMachineToMachCPU(uint16_t machine);
 
+#ifndef IMAGE_FILE_MACHINE_UNKNOWN
 #define IMAGE_FILE_MACHINE_UNKNOWN      0x0000
 #define IMAGE_FILE_MACHINE_AM33         0x01d3  // Matsushita AM33
 #define IMAGE_FILE_MACHINE_AMD64        0x8664  // x64
@@ -52,9 +53,8 @@
 #define IMAGE_OS2_SIGNATURE             0x454E      // NE
 #define IMAGE_OS2_SIGNATURE_LE          0x454C      // LE
 #define IMAGE_NT_SIGNATURE              0x00004550  // PE00
-#define OPT_HEADER_MAGIC_PE32           0x010b
-#define OPT_HEADER_MAGIC_PE32_PLUS      0x020b
 
+
 #define IMAGE_FILE_RELOCS_STRIPPED          0x0001
 #define IMAGE_FILE_EXECUTABLE_IMAGE         0x0002
 #define IMAGE_FILE_LINE_NUMS_STRIPPED       0x0004
@@ -71,7 +71,10 @@
 #define IMAGE_FILE_DLL                      0x2000
 #define IMAGE_FILE_UP_SYSTEM_ONLY           0x4000
 #define IMAGE_FILE_BYTES_REVERSED_HI        0x8000
+#endif
 
+#define OPT_HEADER_MAGIC_PE32           0x010b
+#define OPT_HEADER_MAGIC_PE32_PLUS      0x020b
 
 // Section Flags
 // The section flags in the Characteristics field of the section header indicate
Index: source/Plugins/OperatingSystem/CMakeLists.txt
===================================================================
--- source/Plugins/OperatingSystem/CMakeLists.txt	(revision 0)
+++ source/Plugins/OperatingSystem/CMakeLists.txt	(working copy)
@@ -0,0 +1 @@
+#add_subdirectory(Darwin-Kernel)
Index: source/Plugins/OperatingSystem/Darwin-Kernel/CMakeLists.txt
===================================================================
--- source/Plugins/OperatingSystem/Darwin-Kernel/CMakeLists.txt	(revision 0)
+++ source/Plugins/OperatingSystem/Darwin-Kernel/CMakeLists.txt	(working copy)
@@ -0,0 +1,5 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginOSDarwinKernel
+  OperatingSystemDarwinKernel.cpp
+  )
Index: source/Plugins/Platform/CMakeLists.txt
===================================================================
--- source/Plugins/Platform/CMakeLists.txt	(revision 0)
+++ source/Plugins/Platform/CMakeLists.txt	(working copy)
@@ -0,0 +1,5 @@
+#add_subdirectory(FreeBSD)
+#add_subdirectory(gdb-server)
+#add_subdirectory(Linux)
+#add_subdirectory(MacOSX)
+add_subdirectory(Windows)
Index: source/Plugins/Platform/Windows/CMakeLists.txt
===================================================================
--- source/Plugins/Platform/Windows/CMakeLists.txt	(revision 0)
+++ source/Plugins/Platform/Windows/CMakeLists.txt	(working copy)
@@ -0,0 +1,5 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginPlatformWindows
+  PlatformWindows.cpp
+  )
Index: source/Plugins/Platform/Windows/PlatformWindows.cpp
===================================================================
--- source/Plugins/Platform/Windows/PlatformWindows.cpp	(revision 0)
+++ source/Plugins/Platform/Windows/PlatformWindows.cpp	(working copy)
@@ -0,0 +1,648 @@
+//===-- PlatformWindows.cpp ---------------------------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "PlatformWindows.h"
+
+// C Includes
+#include <stdio.h>
+
+// C++ Includes
+// Other libraries and framework includes
+// Project includes
+#include "lldb/Core/Error.h"
+#include "lldb/Core/Debugger.h"
+#include "lldb/Core/PluginManager.h"
+#include "lldb/Host/Host.h"
+#include "lldb/Core/ModuleSpec.h"
+#include "lldb/Core/Module.h"
+
+using namespace lldb;
+using namespace lldb_private;
+
+Platform *
+PlatformWindows::CreateInstance (bool force, const lldb_private::ArchSpec *arch)
+{
+    // The only time we create an instance is when we are creating a remote
+    // windows platform
+    const bool is_host = false;
+
+    bool create = force;
+    if (create == false && arch && arch->IsValid())
+    {
+        const llvm::Triple &triple = arch->GetTriple();
+        switch (triple.getVendor())
+        {
+            case llvm::Triple::PC:
+                create = true;
+                break;
+                
+            case llvm::Triple::UnknownArch:
+                create = !arch->TripleVendorWasSpecified();
+                break;
+                
+            default:
+                break;
+        }
+        
+        if (create)
+        {
+            switch (triple.getOS())
+            {
+                case llvm::Triple::Win32:
+                case llvm::Triple::MinGW32:
+                    break;
+                    
+                case llvm::Triple::UnknownOS:
+                    create = arch->TripleOSWasSpecified();
+                    break;
+                    
+                default:
+                    create = false;
+                    break;
+            }
+        }
+    }
+    if (create)
+        return new PlatformWindows (is_host);
+    return NULL;
+
+}
+
+const char *
+PlatformWindows::GetPluginNameStatic()
+{
+    return "plugin.platform.windows";
+}
+
+const char *
+PlatformWindows::GetShortPluginNameStatic (bool is_host)
+{
+    if (is_host)
+        return Platform::GetHostPlatformName ();
+    else
+        return "remote-windows";
+}
+
+const char *
+PlatformWindows::GetDescriptionStatic (bool is_host)
+{
+    if (is_host)
+        return "Local Windows user platform plug-in.";
+    else
+        return "Remote Windows user platform plug-in.";
+}
+
+static uint32_t g_initialize_count = 0;
+
+void
+PlatformWindows::Initialize ()
+{
+    if (g_initialize_count++ == 0)
+    {
+#if defined (_WIN32)
+        // Force a host flag to true for the default platform object.
+        PlatformSP default_platform_sp (new PlatformWindows(true));
+        default_platform_sp->SetSystemArchitecture (Host::GetArchitecture());
+        Platform::SetDefaultPlatform (default_platform_sp);
+#endif
+        PluginManager::RegisterPlugin(PlatformWindows::GetShortPluginNameStatic(false),
+                                      PlatformWindows::GetDescriptionStatic(false),
+                                      PlatformWindows::CreateInstance);
+    }
+}
+
+void
+PlatformWindows::Terminate ()
+{
+    if (g_initialize_count > 0 && --g_initialize_count == 0)
+        PluginManager::UnregisterPlugin (PlatformWindows::CreateInstance);
+}
+
+//------------------------------------------------------------------
+/// Default Constructor
+//------------------------------------------------------------------
+PlatformWindows::PlatformWindows (bool is_host) :
+Platform(is_host)
+{
+}
+
+//------------------------------------------------------------------
+/// Destructor.
+///
+/// The destructor is virtual since this class is designed to be
+/// inherited from by the plug-in instance.
+//------------------------------------------------------------------
+PlatformWindows::~PlatformWindows()
+{
+}
+
+
+Error
+PlatformWindows::ResolveExecutable (const FileSpec &exe_file,
+                                    const ArchSpec &exe_arch,
+                                    lldb::ModuleSP &exe_module_sp,
+                                    const FileSpecList *module_search_paths_ptr)
+{
+    Error error;
+    // Nothing special to do here, just use the actual file and architecture
+
+    char exe_path[PATH_MAX];
+    FileSpec resolved_exe_file (exe_file);
+
+    if (IsHost())
+    {
+        // If we have "ls" as the exe_file, resolve the executable loation based on
+        // the current path variables
+        if (!resolved_exe_file.Exists())
+        {
+            exe_file.GetPath(exe_path, sizeof(exe_path));
+            resolved_exe_file.SetFile(exe_path, true);
+        }
+
+        if (!resolved_exe_file.Exists())
+            resolved_exe_file.ResolveExecutableLocation ();
+
+        if (resolved_exe_file.Exists())
+            error.Clear();
+        else
+        {
+            exe_file.GetPath(exe_path, sizeof(exe_path));
+            error.SetErrorStringWithFormat("unable to find executable for '%s'", exe_path);
+        }
+    }
+    else
+    {
+        if (m_remote_platform_sp)
+        {
+            error = m_remote_platform_sp->ResolveExecutable (exe_file,
+                                                             exe_arch,
+                                                             exe_module_sp,
+                                                             module_search_paths_ptr);
+        }
+        else
+        {
+            // We may connect to a process and use the provided executable (Don't use local $PATH).
+            
+            // Resolve any executable within a bundle on MacOSX
+            Host::ResolveExecutableInBundle (resolved_exe_file);
+            
+            if (resolved_exe_file.Exists()) {
+                error.Clear();
+            }
+            else
+            {
+                exe_file.GetPath(exe_path, sizeof(exe_path));
+                error.SetErrorStringWithFormat("the platform is not currently connected, and '%s' doesn't exist in the system root.", exe_path);
+            }
+        }
+    }
+
+
+    if (error.Success())
+    {
+        ModuleSpec module_spec (resolved_exe_file, exe_arch);
+        if (module_spec.GetArchitecture().IsValid())
+        {
+            error = ModuleList::GetSharedModule (module_spec,
+                                                 exe_module_sp,
+                                                 module_search_paths_ptr,
+                                                 NULL,
+                                                 NULL);
+
+            if (exe_module_sp->GetObjectFile() == NULL)
+            {
+                exe_module_sp.reset();
+                error.SetErrorStringWithFormat ("'%s%s%s' doesn't contain the architecture %s",
+                                                exe_file.GetDirectory().AsCString(""),
+                                                exe_file.GetDirectory() ? "/" : "",
+                                                exe_file.GetFilename().AsCString(""),
+                                                exe_arch.GetArchitectureName());
+            }
+        }
+        else
+        {
+            // No valid architecture was specified, ask the platform for
+            // the architectures that we should be using (in the correct order)
+            // and see if we can find a match that way
+            StreamString arch_names;
+            ArchSpec platform_arch;
+            for (uint32_t idx = 0; GetSupportedArchitectureAtIndex (idx, platform_arch); ++idx)
+            {
+                error = ModuleList::GetSharedModule (module_spec,
+                                                     exe_module_sp,
+                                                     module_search_paths_ptr,
+                                                     NULL,
+                                                     NULL);
+                // Did we find an executable using one of the
+                if (error.Success())
+                {
+                    if (exe_module_sp && exe_module_sp->GetObjectFile())
+                        break;
+                    else
+                        error.SetErrorToGenericError();
+                }
+
+                if (idx > 0)
+                    arch_names.PutCString (", ");
+                arch_names.PutCString (platform_arch.GetArchitectureName());
+            }
+
+            if (error.Fail() || !exe_module_sp)
+            {
+                error.SetErrorStringWithFormat ("'%s%s%s' doesn't contain any '%s' platform architectures: %s",
+                                                exe_file.GetDirectory().AsCString(""),
+                                                exe_file.GetDirectory() ? "/" : "",
+                                                exe_file.GetFilename().AsCString(""),
+                                                GetShortPluginName(),
+                                                arch_names.GetString().c_str());
+            }
+        }
+    }
+    else
+    {
+        error.SetErrorStringWithFormat ("'%s%s%s' does not exist",
+                                        exe_file.GetDirectory().AsCString(""),
+                                        exe_file.GetDirectory() ? "/" : "",
+                                        exe_file.GetFilename().AsCString(""));
+    }
+
+    return error;
+}
+
+size_t
+PlatformWindows::GetSoftwareBreakpointTrapOpcode (Target &target, BreakpointSite *bp_site)
+{
+    ArchSpec arch = target.GetArchitecture();
+    const uint8_t *trap_opcode = NULL;
+    size_t trap_opcode_size = 0;
+
+    switch (arch.GetCore())
+    {
+    default:
+        assert(false && "Unhandled architecture in PlatformWindows::GetSoftwareBreakpointTrapOpcode()");
+        break;
+
+    case ArchSpec::eCore_x86_32_i386:
+    case ArchSpec::eCore_x86_64_x86_64:
+        {
+            static const uint8_t g_i386_opcode[] = { 0xCC };
+            trap_opcode = g_i386_opcode;
+            trap_opcode_size = sizeof(g_i386_opcode);
+        }
+        break;
+    }
+
+    if (bp_site->SetTrapOpcode(trap_opcode, trap_opcode_size))
+        return trap_opcode_size;
+
+    return 0;
+}
+
+bool
+PlatformWindows::GetRemoteOSVersion ()
+{
+    if (m_remote_platform_sp)
+        return m_remote_platform_sp->GetOSVersion (m_major_os_version,
+                                                   m_minor_os_version,
+                                                   m_update_os_version);
+    return false;
+}
+
+bool
+PlatformWindows::GetRemoteOSBuildString (std::string &s)
+{
+    if (m_remote_platform_sp)
+        return m_remote_platform_sp->GetRemoteOSBuildString (s);
+    s.clear();
+    return false;
+}
+
+bool
+PlatformWindows::GetRemoteOSKernelDescription (std::string &s)
+{
+    if (m_remote_platform_sp)
+        return m_remote_platform_sp->GetRemoteOSKernelDescription (s);
+    s.clear();
+    return false;
+}
+
+// Remote Platform subclasses need to override this function
+ArchSpec
+PlatformWindows::GetRemoteSystemArchitecture ()
+{
+    if (m_remote_platform_sp)
+        return m_remote_platform_sp->GetRemoteSystemArchitecture ();
+    return ArchSpec();
+}
+
+
+const char *
+PlatformWindows::GetHostname ()
+{
+    if (IsHost())
+        return Platform::GetHostname();
+
+    if (m_remote_platform_sp)
+        return m_remote_platform_sp->GetHostname ();
+    return NULL;
+}
+
+bool
+PlatformWindows::IsConnected () const
+{
+    if (IsHost())
+        return true;
+    else if (m_remote_platform_sp)
+        return m_remote_platform_sp->IsConnected();
+    return false;
+}
+
+Error
+PlatformWindows::ConnectRemote (Args& args)
+{
+    Error error;
+    if (IsHost())
+    {
+        error.SetErrorStringWithFormat ("can't connect to the host platform '%s', always connected", GetShortPluginName());
+    }
+    else
+    {
+        if (!m_remote_platform_sp)
+            m_remote_platform_sp = Platform::Create ("remote-gdb-server", error);
+
+        if (m_remote_platform_sp)
+        {
+            if (error.Success())
+            {
+                if (m_remote_platform_sp)
+                {
+                    error = m_remote_platform_sp->ConnectRemote (args);
+                }
+                else
+                {
+                    error.SetErrorString ("\"platform connect\" takes a single argument: <connect-url>");
+                }
+            }
+        }
+        else
+            error.SetErrorString ("failed to create a 'remote-gdb-server' platform");
+
+        if (error.Fail())
+            m_remote_platform_sp.reset();
+    }
+
+    return error;
+}
+
+Error
+PlatformWindows::DisconnectRemote ()
+{
+    Error error;
+
+    if (IsHost())
+    {
+        error.SetErrorStringWithFormat ("can't disconnect from the host platform '%s', always connected", GetShortPluginName());
+    }
+    else
+    {
+        if (m_remote_platform_sp)
+            error = m_remote_platform_sp->DisconnectRemote ();
+        else
+            error.SetErrorString ("the platform is not currently connected");
+    }
+    return error;
+}
+
+bool
+PlatformWindows::GetProcessInfo (lldb::pid_t pid, ProcessInstanceInfo &process_info)
+{
+    bool success = false;
+    if (IsHost())
+    {
+        success = Platform::GetProcessInfo (pid, process_info);
+    }
+    else if (m_remote_platform_sp) 
+    {
+        success = m_remote_platform_sp->GetProcessInfo (pid, process_info);
+    }
+    return success;
+}
+
+
+
+uint32_t
+PlatformWindows::FindProcesses (const ProcessInstanceInfoMatch &match_info,
+                               ProcessInstanceInfoList &process_infos)
+{
+    uint32_t match_count = 0;
+    if (IsHost())
+    {
+        // Let the base class figure out the host details
+        match_count = Platform::FindProcesses (match_info, process_infos);
+    }
+    else
+    {
+        // If we are remote, we can only return results if we are connected
+        if (m_remote_platform_sp)
+            match_count = m_remote_platform_sp->FindProcesses (match_info, process_infos);
+    }
+    return match_count;
+}
+
+Error
+PlatformWindows::LaunchProcess (ProcessLaunchInfo &launch_info)
+{
+    Error error;
+    if (IsHost())
+    {
+        error = Platform::LaunchProcess (launch_info);
+    }
+    else
+    {
+        if (m_remote_platform_sp)
+            error = m_remote_platform_sp->LaunchProcess (launch_info);
+        else
+            error.SetErrorString ("the platform is not currently connected");
+    }
+    return error;
+}
+
+lldb::ProcessSP
+PlatformWindows::Attach(ProcessAttachInfo &attach_info,
+                        Debugger &debugger,
+                        Target *target,
+                        Listener &listener,
+                        Error &error)
+{
+    lldb::ProcessSP process_sp;
+    if (IsHost())
+    {
+        if (target == NULL)
+        {
+            TargetSP new_target_sp;
+            FileSpec emptyFileSpec;
+            ArchSpec emptyArchSpec;
+
+            error = debugger.GetTargetList().CreateTarget (debugger,
+                                                           emptyFileSpec,
+                                                           emptyArchSpec,
+                                                           false,
+                                                           m_remote_platform_sp,
+                                                           new_target_sp);
+            target = new_target_sp.get();
+        }
+        else
+            error.Clear();
+
+        if (target && error.Success())
+        {
+            debugger.GetTargetList().SetSelectedTarget(target);
+            // The freebsd always currently uses the GDB remote debugger plug-in
+            // so even when debugging locally we are debugging remotely!
+            // Just like the darwin plugin.
+            process_sp = target->CreateProcess (listener, "gdb-remote", NULL);
+
+            if (process_sp)
+                error = process_sp->Attach (attach_info);
+        }
+    }
+    else
+    {
+        if (m_remote_platform_sp)
+            process_sp = m_remote_platform_sp->Attach (attach_info, debugger, target, listener, error);
+        else
+            error.SetErrorString ("the platform is not currently connected");
+    }
+    return process_sp;
+}
+
+const char *
+PlatformWindows::GetUserName (uint32_t uid)
+{
+    // Check the cache in Platform in case we have already looked this uid up
+    const char *user_name = Platform::GetUserName(uid);
+    if (user_name)
+        return user_name;
+
+    if (IsRemote() && m_remote_platform_sp)
+        return m_remote_platform_sp->GetUserName(uid);
+    return NULL;
+}
+
+const char *
+PlatformWindows::GetGroupName (uint32_t gid)
+{
+    const char *group_name = Platform::GetGroupName(gid);
+    if (group_name)
+        return group_name;
+
+    if (IsRemote() && m_remote_platform_sp)
+        return m_remote_platform_sp->GetGroupName(gid);
+    return NULL;
+}
+
+Error
+PlatformWindows::GetFile (const FileSpec &platform_file,
+                          const UUID *uuid_ptr,
+                          FileSpec &local_file)
+{
+    if (IsRemote())
+    {
+        if (m_remote_platform_sp)
+            return m_remote_platform_sp->GetFile (platform_file, uuid_ptr, local_file);
+    }
+
+    // Default to the local case
+    local_file = platform_file;
+    return Error();
+}
+
+Error
+PlatformWindows::GetSharedModule (const ModuleSpec &module_spec,
+                                  ModuleSP &module_sp,
+                                  const FileSpecList *module_search_paths_ptr,
+                                  ModuleSP *old_module_sp_ptr,
+                                  bool *did_create_ptr)
+{
+    Error error;
+    module_sp.reset();
+
+    if (IsRemote())
+    {
+        // If we have a remote platform always, let it try and locate
+        // the shared module first.
+        if (m_remote_platform_sp)
+        {
+            error = m_remote_platform_sp->GetSharedModule (module_spec,
+                                                           module_sp,
+                                                           module_search_paths_ptr,
+                                                           old_module_sp_ptr,
+                                                           did_create_ptr);
+        }
+    }
+
+    if (!module_sp)
+    {
+        // Fall back to the local platform and find the file locally
+        error = Platform::GetSharedModule (module_spec,
+                                           module_sp,
+                                           module_search_paths_ptr,
+                                           old_module_sp_ptr,
+                                           did_create_ptr);
+    }
+    if (module_sp)
+        module_sp->SetPlatformFileSpec(module_spec.GetFileSpec());
+    return error;
+}
+
+
+bool
+PlatformWindows::GetSupportedArchitectureAtIndex (uint32_t idx, ArchSpec &arch)
+{
+    // From macosx;s plugin code. For FreeBSD we may want to support more archs.
+    if (idx == 0)
+    {
+        arch = Host::GetArchitecture (Host::eSystemDefaultArchitecture);
+        return arch.IsValid();
+    }
+    else if (idx == 1)
+    {
+        ArchSpec platform_arch (Host::GetArchitecture (Host::eSystemDefaultArchitecture));
+        ArchSpec platform_arch64 (Host::GetArchitecture (Host::eSystemDefaultArchitecture64));
+        if (platform_arch == platform_arch64)
+        {
+            // This freebsd platform supports both 32 and 64 bit. Since we already
+            // returned the 64 bit arch for idx == 0, return the 32 bit arch
+            // for idx == 1
+            arch = Host::GetArchitecture (Host::eSystemDefaultArchitecture32);
+            return arch.IsValid();
+        }
+    }
+    return false;
+}
+
+void
+PlatformWindows::GetStatus (Stream &strm)
+{
+    OSVERSIONINFO info;
+    
+    ZeroMemory(&info, sizeof(OSVERSIONINFO));
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
+    
+    if (GetVersionEx(&info) == 0) {
+        strm << "Windows";
+        return;
+    }
+
+    strm << "Host: Windows " << (int) info.dwMajorVersion
+        << '.' << (int) info.dwMinorVersion 
+        << " Build: " << (int) info.dwBuildNumber << '\n';
+
+    Platform::GetStatus(strm);
+}
Index: source/Plugins/Platform/Windows/PlatformWindows.h
===================================================================
--- source/Plugins/Platform/Windows/PlatformWindows.h	(revision 0)
+++ source/Plugins/Platform/Windows/PlatformWindows.h	(working copy)
@@ -0,0 +1,166 @@
+//===-- PlatformWindows.h --------------------------------------/*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef liblldb_PlatformWindows_h_
+#define liblldb_PlatformWindows_h_
+
+// C Includes
+// C++ Includes
+// Other libraries and framework includes
+// Project includes
+#include "lldb/Target/Platform.h"
+
+class PlatformWindows : public lldb_private::Platform
+{
+public:
+
+    //------------------------------------------------------------
+    // Class functions
+    //------------------------------------------------------------
+    static lldb_private::Platform*
+    CreateInstance (bool force, const lldb_private::ArchSpec *arch);
+
+    static void
+    Initialize ();
+
+    static void
+    Terminate ();
+
+    static const char *
+    GetPluginNameStatic();
+
+    static const char *
+    GetShortPluginNameStatic(bool is_host);
+
+    static const char *
+    GetDescriptionStatic(bool is_host);
+
+    //------------------------------------------------------------
+    // Class Methods
+    //------------------------------------------------------------
+    PlatformWindows (bool is_host);
+
+    virtual
+    ~PlatformWindows();
+
+    //------------------------------------------------------------
+    // lldb_private::PluginInterface functions
+    //------------------------------------------------------------
+    virtual const char *
+    GetPluginName()
+    {
+        return GetPluginNameStatic();
+    }
+
+    virtual const char *
+    GetShortPluginName()
+    {
+        return GetShortPluginNameStatic (IsHost());
+    }
+
+    virtual uint32_t
+    GetPluginVersion()
+    {
+        return 1;
+    }
+
+    virtual const char *
+    GetDescription ()
+    {
+        return GetDescriptionStatic(IsHost());
+    }
+
+    //------------------------------------------------------------
+    // lldb_private::Platform functions
+    //------------------------------------------------------------
+    virtual lldb_private::Error
+    ResolveExecutable (const lldb_private::FileSpec &exe_file,
+                       const lldb_private::ArchSpec &arch,
+                       lldb::ModuleSP &module_sp,
+                       const lldb_private::FileSpecList *module_search_paths_ptr);
+
+    virtual size_t
+    GetSoftwareBreakpointTrapOpcode (lldb_private::Target &target,
+                                     lldb_private::BreakpointSite *bp_site);
+
+    virtual bool
+    GetRemoteOSVersion ();
+
+    virtual bool
+    GetRemoteOSBuildString (std::string &s);
+
+    virtual bool
+    GetRemoteOSKernelDescription (std::string &s);
+
+    // Remote Platform subclasses need to override this function
+    virtual lldb_private::ArchSpec
+    GetRemoteSystemArchitecture ();
+
+    virtual bool
+    IsConnected () const;
+
+    virtual lldb_private::Error
+    ConnectRemote (lldb_private::Args& args);
+
+    virtual lldb_private::Error
+    DisconnectRemote ();
+
+    virtual const char *
+    GetHostname ();
+
+    virtual const char *
+    GetUserName (uint32_t uid);
+
+    virtual const char *
+    GetGroupName (uint32_t gid);
+
+    virtual bool
+    GetProcessInfo (lldb::pid_t pid,
+                    lldb_private::ProcessInstanceInfo &proc_info);
+
+    virtual uint32_t
+    FindProcesses (const lldb_private::ProcessInstanceInfoMatch &match_info,
+                   lldb_private::ProcessInstanceInfoList &process_infos);
+
+    virtual lldb_private::Error
+    LaunchProcess (lldb_private::ProcessLaunchInfo &launch_info);
+
+    virtual lldb::ProcessSP
+    Attach(lldb_private::ProcessAttachInfo &attach_info,
+           lldb_private::Debugger &debugger,
+           lldb_private::Target *target,
+           lldb_private::Listener &listener,
+           lldb_private::Error &error);
+
+    // FIXME: Only on PlatformMacOSX:
+    virtual lldb_private::Error
+    GetFile (const lldb_private::FileSpec &platform_file,
+             const lldb_private::UUID* uuid, lldb_private::FileSpec &local_file);
+
+    lldb_private::Error
+    GetSharedModule (const lldb_private::ModuleSpec &module_spec,
+                     lldb::ModuleSP &module_sp,
+                     const lldb_private::FileSpecList *module_search_paths_ptr,
+                     lldb::ModuleSP *old_module_sp_ptr,
+                     bool *did_create_ptr);
+
+    virtual bool
+    GetSupportedArchitectureAtIndex (uint32_t idx, lldb_private::ArchSpec &arch);
+
+    virtual void
+    GetStatus (lldb_private::Stream &strm);
+
+protected:
+    lldb::PlatformSP m_remote_platform_sp; // Allow multiple ways to connect to a remote freebsd OS
+
+private:
+    DISALLOW_COPY_AND_ASSIGN (PlatformWindows);
+};
+
+#endif  // liblldb_PlatformWindows_h_
Index: source/Plugins/Process/CMakeLists.txt
===================================================================
--- source/Plugins/Process/CMakeLists.txt	(revision 0)
+++ source/Plugins/Process/CMakeLists.txt	(working copy)
@@ -0,0 +1,7 @@
+#add_subdirectory(FreeBSD)
+#add_subdirectory(gdb-remote)
+#add_subdirectory(Linux)
+#add_subdirectory(mach-core)
+#add_subdirectory(MacOSx-Kernel)
+#add_subdirectory(POSIX)
+#add_subdirectory(Utility)
Index: source/Plugins/Process/gdb-remote/CMakeLists.txt
===================================================================
--- source/Plugins/Process/gdb-remote/CMakeLists.txt	(revision 0)
+++ source/Plugins/Process/gdb-remote/CMakeLists.txt	(working copy)
@@ -0,0 +1,11 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginProcessGDBRemote
+  GDBRemoteCommunication.cpp
+  GDBRemoteRegisterContext.cpp
+  GDBServer.cpp
+  GDBServerLog.cpp
+  ProcessGDBRemote.cpp
+  ProcessGDBRemoteLog.cpp
+  ThreadGDBRemote.cpp
+  )
Index: source/Plugins/Process/Utility/RegisterContextDarwin_arm.h
===================================================================
--- source/Plugins/Process/Utility/RegisterContextDarwin_arm.h	(revision 163322)
+++ source/Plugins/Process/Utility/RegisterContextDarwin_arm.h	(working copy)
@@ -137,6 +137,10 @@
 //      } v3;
 //      uint32_t fpscr;
 //  };
+// windows defines far as nothing
+#if defined(far)
+#undef far
+#endif
 
     struct EXC
     {
Index: source/Plugins/SymbolFile/CMakeLists.txt
===================================================================
--- source/Plugins/SymbolFile/CMakeLists.txt	(revision 0)
+++ source/Plugins/SymbolFile/CMakeLists.txt	(working copy)
@@ -0,0 +1,2 @@
+add_subdirectory(DWARF)
+add_subdirectory(Symtab)
Index: source/Plugins/SymbolFile/DWARF/CMakeLists.txt
===================================================================
--- source/Plugins/SymbolFile/DWARF/CMakeLists.txt	(revision 0)
+++ source/Plugins/SymbolFile/DWARF/CMakeLists.txt	(working copy)
@@ -0,0 +1,28 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginSymbolFileDWARF
+  DWARFAbbreviationDeclaration.cpp
+  DWARFCompileUnit.cpp
+  DWARFDebugAbbrev.cpp
+  DWARFDebugAranges.cpp
+  DWARFDebugArangeSet.cpp
+  DWARFDebugInfo.cpp
+  DWARFDebugInfoEntry.cpp
+  DWARFDebugLine.cpp
+  DWARFDebugMacinfo.cpp
+  DWARFDebugMacinfoEntry.cpp
+  DWARFDebugPubnames.cpp
+  DWARFDebugPubnamesSet.cpp
+  DWARFDebugRanges.cpp
+  DWARFDeclContext.cpp
+  DWARFDefines.cpp
+  DWARFDIECollection.cpp
+  DWARFFormValue.cpp
+  DWARFLocationDescription.cpp
+  DWARFLocationList.cpp
+  LogChannelDWARF.cpp
+  NameToDIE.cpp
+  SymbolFileDWARF.cpp
+  SymbolFileDWARFDebugMap.cpp
+  UniqueDWARFASTType.cpp
+  )
Index: source/Plugins/SymbolFile/DWARF/DWARFDebugPubnamesSet.h
===================================================================
--- source/Plugins/SymbolFile/DWARF/DWARFDebugPubnamesSet.h	(revision 163322)
+++ source/Plugins/SymbolFile/DWARF/DWARFDebugPubnamesSet.h	(working copy)
@@ -16,8 +16,12 @@
 #if __cplusplus >= 201103L
 #include <unordered_map>
 #else
-#include <ext/hash_map>
+#if defined __GNUC__ || defined __APPLE__
+ #include <ext/hash_map>
+#else
+#include <unordered_map>
 #endif
+#endif
 
 class DWARFDebugPubnamesSet
 {
@@ -87,11 +91,15 @@
 
     dw_offset_t     m_offset;
     Header          m_header;
-#if __cplusplus >= 201103L
+#if __cplusplus >= 201103L 
     typedef std::unordered_multimap<const char*, uint32_t, std::hash<const char*>, CStringEqualBinaryPredicate> cstr_to_index_mmap;
 #else
-    typedef __gnu_cxx::hash_multimap<const char*, uint32_t, __gnu_cxx::hash<const char*>, CStringEqualBinaryPredicate> cstr_to_index_mmap;
+#if defined __GNUC__ || defined __APPLE__
+	typedef __gnu_cxx::hash_multimap<const char*, uint32_t, __gnu_cxx::hash<const char*>, CStringEqualBinaryPredicate> cstr_to_index_mmap;
+#else
+    typedef std::unordered_multimap<const char*, uint32_t, std::hash<const char*>, CStringEqualBinaryPredicate> cstr_to_index_mmap;
 #endif
+#endif
     DescriptorColl  m_descriptors;
     mutable cstr_to_index_mmap m_name_to_descriptor_index;
 };
Index: source/Plugins/SymbolFile/DWARF/DWARFDefines.h
===================================================================
--- source/Plugins/SymbolFile/DWARF/DWARFDefines.h	(revision 163322)
+++ source/Plugins/SymbolFile/DWARF/DWARFDefines.h	(working copy)
@@ -11,7 +11,6 @@
 #define SymbolFileDWARF_DWARFDefines_h_
 
 #include <stdint.h>
-#include <stdbool.h>
 #include "lldb/Core/dwarf.h"
 
 namespace lldb_private {
Index: source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp
===================================================================
--- source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp	(revision 163322)
+++ source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp	(working copy)
@@ -1388,7 +1388,8 @@
                     if (tag == DW_TAG_template_value_parameter && ClangASTContext::IsIntegerType (clang_type, is_signed) && uval64_valid)
                     {
                         llvm::APInt apint (lldb_type->GetByteSize() * 8, uval64, is_signed);
-                        template_param_infos.args.push_back (clang::TemplateArgument (llvm::APSInt(apint), clang_qual_type));
+                        template_param_infos.args.push_back (clang::TemplateArgument (
+                            *GetClangASTContext().getASTContext(), llvm::APSInt(apint), clang_qual_type));
                     }
                     else
                     {
@@ -1547,7 +1548,7 @@
         switch (tag)
         {
         case DW_TAG_member:
-        case DW_TAG_APPLE_Property:
+        case DW_TAG_APPLE_property:
             {
                 DWARFDebugInfoEntry::Attributes attributes;
                 const size_t num_attributes = die->GetAttributes (this, 
Index: source/Plugins/SymbolFile/Symtab/CMakeLists.txt
===================================================================
--- source/Plugins/SymbolFile/Symtab/CMakeLists.txt	(revision 0)
+++ source/Plugins/SymbolFile/Symtab/CMakeLists.txt	(working copy)
@@ -0,0 +1,5 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginSymbolFileSymtab
+  SymbolFileSymtab.cpp
+  )
Index: source/Plugins/SymbolVendor/CMakeLists.txt
===================================================================
--- source/Plugins/SymbolVendor/CMakeLists.txt	(revision 0)
+++ source/Plugins/SymbolVendor/CMakeLists.txt	(working copy)
@@ -0,0 +1 @@
+#add_subdirectory(MacOSX)
Index: source/Plugins/SymbolVendor/MacOSX/CMakeLists.txt
===================================================================
--- source/Plugins/SymbolVendor/MacOSX/CMakeLists.txt	(revision 0)
+++ source/Plugins/SymbolVendor/MacOSX/CMakeLists.txt	(working copy)
@@ -0,0 +1,5 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbPluginSymbolVendorMacOSX
+  SymbolVendorMacOSX.cpp
+  )
Index: source/Plugins/UnwindAssembly/CMakeLists.txt
===================================================================
--- source/Plugins/UnwindAssembly/CMakeLists.txt	(revision 0)
+++ source/Plugins/UnwindAssembly/CMakeLists.txt	(working copy)
@@ -0,0 +1,2 @@
+#add_subdirectory(InstEmulation)
+#add_subdirectory(x86)
Index: source/Symbol/ClangASTContext.cpp
===================================================================
--- source/Symbol/ClangASTContext.cpp	(revision 163322)
+++ source/Symbol/ClangASTContext.cpp	(working copy)
@@ -48,6 +48,7 @@
 #include "clang/Basic/TargetOptions.h"
 #include "clang/Frontend/FrontendOptions.h"
 #include "clang/Frontend/LangStandard.h"
+#include "clang/Basic/Version.h"
 
 #ifdef LLDB_DEFINED_NDEBUG_FOR_CLANG
 #undef NDEBUG
@@ -358,7 +359,9 @@
     // inlining enabled.
     //
     // FIXME: This is affected by other options (-fno-inline).
+#if (CLANG_VERSION_MAJOR <= 3 && CLANG_VERSION_MINOR < 2)
     Opts.NoInline = !Opt;
+#endif
 
 //    unsigned SSP = getLastArgIntValue(Args, OPT_stack_protector, 0, Diags);
 //    switch (SSP) {
@@ -1177,7 +1180,7 @@
     for (size_t i=0; i<num_template_params; ++i)
     {
         const char *name = template_param_infos.names[i];
-        if (template_param_infos.args[i].getAsIntegral())
+        if (template_param_infos.args[i].getAsIntegral().getBoolValue())
         {
             template_param_decls.push_back (NonTypeTemplateParmDecl::Create (*ast,
                                                                              ast->getTranslationUnitDecl(), // Is this the right decl context?, SourceLocation StartLoc,
@@ -1956,7 +1959,7 @@
                                                   NULL,       // TInfo *
                                                   bit_width,  // BitWidth
                                                   false,      // Mutable
-                                                  false);     // HasInit
+                                                  ICIS_NoInit); // HasInit
             
             if (!name) {
                 // Determine whether this field corresponds to an anonymous
Index: source/Symbol/ClangASTType.cpp
===================================================================
--- source/Symbol/ClangASTType.cpp	(revision 163322)
+++ source/Symbol/ClangASTType.cpp	(working copy)
@@ -23,6 +23,7 @@
 #include "clang/Basic/LangOptions.h"
 #include "clang/Basic/SourceManager.h"
 #include "clang/Basic/TargetInfo.h"
+#include "clang/Basic/Version.h"
 
 #include "llvm/Support/FormattedStream.h"
 #include "llvm/Support/raw_ostream.h"
@@ -1271,7 +1272,11 @@
                     if (class_interface_decl)
                     {
                         clang::PrintingPolicy policy = ast_context->getPrintingPolicy();
+						
+#if CLANG_VERSION_MAJOR > 3 || (CLANG_VERSION_MAJOR == 3 && CLANG_VERSION_MINOR  >= 2)
+#else
                         policy.Dump = 1;
+#endif
                         class_interface_decl->print(llvm_ostrm, policy, s->GetIndentLevel());
                     }
                 }
Index: source/Symbol/CMakeLists.txt
===================================================================
--- source/Symbol/CMakeLists.txt	(revision 0)
+++ source/Symbol/CMakeLists.txt	(working copy)
@@ -0,0 +1,32 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbSymbol
+  Block.cpp
+  ClangASTContext.cpp
+  ClangASTImporter.cpp
+  ClangASTType.cpp
+  ClangExternalASTSourceCallbacks.cpp
+  ClangExternalASTSourceCommon.cpp
+  ClangNamespaceDecl.cpp
+  CompileUnit.cpp
+  Declaration.cpp
+  DWARFCallFrameInfo.cpp
+  Function.cpp
+  FuncUnwinders.cpp
+  LineEntry.cpp
+  LineTable.cpp
+  ObjectFile.cpp
+  Symbol.cpp
+  SymbolContext.cpp
+  SymbolFile.cpp
+  SymbolVendor.cpp
+  Symtab.cpp
+  Type.cpp
+  TypeHierarchyNavigator.cpp
+  TypeList.cpp
+  UnwindPlan.cpp
+  UnwindTable.cpp
+  Variable.cpp
+  VariableList.cpp
+  VerifyDecl.cpp
+  )
Index: source/Symbol/TypeHierarchyNavigator.cpp
===================================================================
--- source/Symbol/TypeHierarchyNavigator.cpp	(revision 163322)
+++ source/Symbol/TypeHierarchyNavigator.cpp	(working copy)
@@ -11,6 +11,7 @@
 #include "lldb/Core/ValueObject.h"
 #include "lldb/Symbol/ClangASTContext.h"
 #include "lldb/Symbol/TypeHierarchyNavigator.h"
+#include "clang/AST/ASTContext.h"
 
 using namespace lldb;
 using namespace lldb_private;
Index: source/Target/CMakeLists.txt
===================================================================
--- source/Target/CMakeLists.txt	(revision 0)
+++ source/Target/CMakeLists.txt	(working copy)
@@ -0,0 +1,42 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbTarget
+  ABI.cpp
+  CPPLanguageRuntime.cpp
+  ExecutionContext.cpp
+  LanguageRuntime.cpp
+  Memory.cpp
+  ObjCLanguageRuntime.cpp
+  OperatingSystem.cpp
+  PathMappingList.cpp
+  Platform.cpp
+  Process.cpp
+  RegisterContext.cpp
+  SectionLoadList.cpp
+  StackFrame.cpp
+  StackFrameList.cpp
+  StackID.cpp
+  StopInfo.cpp
+  Target.cpp
+  TargetList.cpp
+  Thread.cpp
+  ThreadList.cpp
+  ThreadPlan.cpp
+  ThreadPlanBase.cpp
+  ThreadPlanCallFunction.cpp
+  ThreadPlanCallUserExpression.cpp
+  ThreadPlanRunToAddress.cpp
+  ThreadPlanShouldStopHere.cpp
+  ThreadPlanStepInRange.cpp
+  ThreadPlanStepInstruction.cpp
+  ThreadPlanStepOut.cpp
+  ThreadPlanStepOverBreakpoint.cpp
+  ThreadPlanStepOverRange.cpp
+  ThreadPlanStepRange.cpp
+  ThreadPlanStepThrough.cpp
+  ThreadPlanStepUntil.cpp
+  ThreadPlanTracer.cpp
+  ThreadSpec.cpp
+  UnixSignals.cpp
+  UnwindAssembly.cpp
+  )
Index: source/Target/Process.cpp
===================================================================
--- source/Target/Process.cpp	(revision 163322)
+++ source/Target/Process.cpp	(working copy)
@@ -563,7 +563,7 @@
 }
 
 
-
+#ifdef _POSIX_SOURCE
 bool
 ProcessLaunchInfo::FileAction::AddPosixSpawnFileAction (posix_spawn_file_actions_t *file_actions,
                                                         const FileAction *info,
@@ -638,6 +638,7 @@
     }
     return error.Success();
 }
+#endif
 
 Error
 ProcessLaunchCommandOptions::SetOptionValue (uint32_t option_idx, const char *option_arg)
@@ -3509,12 +3510,16 @@
     m_currently_handling_event.SetValue(false, eBroadcastAlways);
 }
 
-void *
+thread_result_t
 Process::PrivateStateThread (void *arg)
 {
     Process *proc = static_cast<Process*> (arg);
     void *result = proc->RunPrivateStateThread ();
+#ifdef _WIN32
+    return 0;
+#else
     return result;
+#endif
 }
 
 void *
Index: source/Target/Thread.cpp
===================================================================
--- source/Target/Thread.cpp	(revision 163322)
+++ source/Target/Thread.cpp	(working copy)
@@ -37,7 +37,7 @@
 #include "lldb/Target/ThreadSpec.h"
 #include "lldb/Target/Unwind.h"
 #include "Plugins/Process/Utility/UnwindLLDB.h"
-#include "UnwindMacOSXFrameBackchain.h"
+//#include "UnwindMacOSXFrameBackchain.h"
 
 
 using namespace lldb;
@@ -1450,12 +1450,16 @@
             case llvm::Triple::x86:
             case llvm::Triple::arm:
             case llvm::Triple::thumb:
+#ifndef _WIN32
                 m_unwinder_ap.reset (new UnwindLLDB (*this));
+#endif
                 break;
                 
             default:
+#ifdef __APPLE__
                 if (target_arch.GetTriple().getVendor() == llvm::Triple::Apple)
                     m_unwinder_ap.reset (new UnwindMacOSXFrameBackchain (*this));
+#endif
                 break;
         }
     }
Index: source/Utility/CMakeLists.txt
===================================================================
--- source/Utility/CMakeLists.txt	(revision 0)
+++ source/Utility/CMakeLists.txt	(working copy)
@@ -0,0 +1,10 @@
+set(LLVM_NO_RTTI 1)
+
+add_lldb_library(lldbUtility
+  ARM_DWARF_Registers.cpp
+  PseudoTerminal.cpp
+  RefCounter.cpp
+  SharingPtr.cpp
+  StringExtractor.cpp
+  StringExtractorGDBRemote.cpp
+  )
Index: source/Utility/PseudoTerminal.cpp
===================================================================
--- source/Utility/PseudoTerminal.cpp	(revision 163322)
+++ source/Utility/PseudoTerminal.cpp	(working copy)
@@ -17,6 +17,25 @@
 #include <sys/ioctl.h>
 #endif
 
+#ifdef _WIN32
+#include "lldb/lldb-windows.h"
+int posix_openpt(int flag) { return 0; }
+
+int strerror_r(int errnum, char *buf, size_t buflen) { return 0; }
+
+int unlockpt(int fd) { return 0; }
+int grantpt(int fd) { return 0; }
+char *ptsname(int fd) { return 0; }
+
+int open(const char *pathname, int flags) { return 0; }
+void close(int fd) {}
+int dup(int oldfd);int dup2(int oldfd, int newfd) { return 0; }
+
+typedef uint32_t pid_t;
+pid_t fork(void) { return 0; }
+pid_t setsid(void) { return 0; }
+#endif
+
 using namespace lldb_utility;
 
 //----------------------------------------------------------------------
Index: tools/CMakeLists.txt
===================================================================
--- tools/CMakeLists.txt	(revision 0)
+++ tools/CMakeLists.txt	(working copy)
@@ -0,0 +1,2 @@
+#add_subdirectory(debugserver)
+add_subdirectory(driver)
Index: tools/driver/CMakeLists.txt
===================================================================
--- tools/driver/CMakeLists.txt	(revision 0)
+++ tools/driver/CMakeLists.txt	(working copy)
@@ -0,0 +1,82 @@
+set(LLVM_NO_RTTI 1)
+
+set( LLDB_USED_LIBS
+  lldbAPI
+  lldbBreakpoint
+  lldbCommands
+  lldbCore
+  lldbExpression
+  lldbHostCommon
+  lldbInitAndLog
+  lldbInterpreter
+  lldbSymbol
+  lldbTarget  
+  lldbUtility
+  
+  # Plugins
+  lldbPluginDisassemblerLLVM
+  lldbPluginSymbolFileDWARF
+  lldbPluginSymbolFileSymtab
+  lldbPluginDynamicLoaderStatic
+  
+  #lldbPluginObjectFileELF
+  #lldbPluginObjectContainerBSDArchive
+  #lldbPluginSymbolVendorMacOSX
+  
+  # Windows
+  lldbHostWindows
+  lldbPluginPlatformWindows
+  lldbPluginObjectFilePECOFF
+  
+  # Linux
+  #lldbHostLinux
+  
+  Ws2_32
+  )
+  
+set( CLANG_USED_LIBS
+  clangAnalysis
+  clangAST
+  clangBasic
+  clangCodeGen
+  clangDriver
+  clangEdit
+  clangFrontend
+  clangLex
+  clangParse
+  clangRewrite
+  clangSema
+  clangSerialization
+  )  
+  
+set( LLDB_DRIVER_LIBS
+  #edit
+  #python2.6
+  )
+
+set( LLVM_LINK_COMPONENTS
+  ${LLVM_TARGETS_TO_BUILD}
+  jit
+  interpreter
+  nativecodegen
+  asmparser
+  bitreader
+  bitwriter
+  codegen
+  ipo
+  selectiondag
+  bitreader
+  mc
+  core
+  )
+
+add_lldb_executable(lldb
+  Driver.cpp
+  DriverEvents.cpp
+  DriverOptions.cpp
+  DriverPosix.cpp
+  IOChannel.cpp
+  )
+
+install(TARGETS lldb
+  RUNTIME DESTINATION bin)
Index: tools/driver/Driver.cpp
===================================================================
--- tools/driver/Driver.cpp	(revision 163322)
+++ tools/driver/Driver.cpp	(working copy)
@@ -9,18 +9,17 @@
 
 #include "Driver.h"
 
-#include <getopt.h>
-#include <libgen.h>
-#include <sys/ioctl.h>
-#include <termios.h>
-#include <unistd.h>
+#ifdef _WIN32
+#include "lldb/lldb-windows.h"
+#include "lldb/lldb-private-log.h"
+#include "lldb/Core/StreamCallback.h"
+#include "lldb/Core/Log.h"
+#endif
 #include <string.h>
 #include <stdlib.h>
 #include <limits.h>
 #include <fcntl.h>
 
-#include <string>
-
 #include "IOChannel.h"
 #include "lldb/API/SBBreakpoint.h"
 #include "lldb/API/SBCommandInterpreter.h"
@@ -38,80 +37,10 @@
 using namespace lldb;
 
 static void reset_stdin_termios ();
-static bool g_old_stdin_termios_is_valid = false;
-static struct termios g_old_stdin_termios;
 
-static char *g_debugger_name =  (char *) "";
-static Driver *g_driver = NULL;
-
-// In the Driver::MainLoop, we change the terminal settings.  This function is
-// added as an atexit handler to make sure we clean them up.
-static void
-reset_stdin_termios ()
-{
-    if (g_old_stdin_termios_is_valid)
-    {
-        g_old_stdin_termios_is_valid = false;
-        ::tcsetattr (STDIN_FILENO, TCSANOW, &g_old_stdin_termios);
-    }
-}
-
-typedef struct
-{
-    uint32_t usage_mask;                     // Used to mark options that can be used together.  If (1 << n & usage_mask) != 0
-                                             // then this option belongs to option set n.
-    bool required;                           // This option is required (in the current usage level)
-    const char * long_option;                // Full name for this option.
-    char short_option;                       // Single character for this option.
-    int option_has_arg;                      // no_argument, required_argument or optional_argument
-    uint32_t completion_type;                // Cookie the option class can use to do define the argument completion.
-    lldb::CommandArgumentType argument_type; // Type of argument this option takes
-    const char *  usage_text;                // Full text explaining what this options does and what (if any) argument to
-                                             // pass it.
-} OptionDefinition;
-
-#define LLDB_3_TO_5 LLDB_OPT_SET_3|LLDB_OPT_SET_4|LLDB_OPT_SET_5
-#define LLDB_4_TO_5 LLDB_OPT_SET_4|LLDB_OPT_SET_5
-
-static OptionDefinition g_options[] =
-{
-    { LLDB_OPT_SET_1,    true , "help"           , 'h', no_argument      , NULL,  eArgTypeNone,         
-        "Prints out the usage information for the LLDB debugger." },
-    { LLDB_OPT_SET_2,    true , "version"        , 'v', no_argument      , NULL,  eArgTypeNone,         
-        "Prints out the current version number of the LLDB debugger." },
-    { LLDB_OPT_SET_3,    true , "arch"           , 'a', required_argument, NULL,  eArgTypeArchitecture, 
-        "Tells the debugger to use the specified architecture when starting and running the program.  <architecture> must "
-        "be one of the architectures for which the program was compiled." },
-    { LLDB_OPT_SET_3,    true , "file"           , 'f', required_argument, NULL,  eArgTypeFilename,     
-        "Tells the debugger to use the file <filename> as the program to be debugged." },
-    { LLDB_OPT_SET_3,    false, "core"           , 'c', required_argument, NULL,  eArgTypePath,     
-        "Tells the debugger to use the fullpath to <path> as the core file." },
-    { LLDB_OPT_SET_4,    true , "attach-name"    , 'n', required_argument, NULL,  eArgTypeProcessName,  
-        "Tells the debugger to attach to a process with the given name." },
-    { LLDB_OPT_SET_4,    true , "wait-for"       , 'w', no_argument      , NULL,  eArgTypeNone,         
-        "Tells the debugger to wait for a process with the given pid or name to launch before attaching." },
-    { LLDB_OPT_SET_5,    true , "attach-pid"     , 'p', required_argument, NULL,  eArgTypePid,          
-        "Tells the debugger to attach to a process with the given pid." },
-    { LLDB_3_TO_5,       false, "script-language", 'l', required_argument, NULL,  eArgTypeScriptLang,   
-        "Tells the debugger to use the specified scripting language for user-defined scripts, rather than the default.  "
-        "Valid scripting languages that can be specified include Python, Perl, Ruby and Tcl.  Currently only the Python "
-        "extensions have been implemented." },
-    { LLDB_3_TO_5,       false, "debug"          , 'd', no_argument      , NULL,  eArgTypeNone,         
-        "Tells the debugger to print out extra information for debugging itself." },
-    { LLDB_3_TO_5,       false, "source"         , 's', required_argument, NULL,  eArgTypeFilename,     
-        "Tells the debugger to read in and execute the file <file>, which should contain lldb commands." },
-    { LLDB_3_TO_5,       false, "editor"         , 'e', no_argument      , NULL,  eArgTypeNone,         
-        "Tells the debugger to open source files using the host's \"external editor\" mechanism." },
-    { LLDB_3_TO_5,       false, "no-lldbinit"    , 'x', no_argument      , NULL,  eArgTypeNone,         
-        "Do not automatically parse any '.lldbinit' files." },
-    { 0,                 false, NULL             , 0  , 0                , NULL,  eArgTypeNone,         NULL }
-};
-
-static const uint32_t last_option_set_with_args = 2;
-
 Driver::Driver () :
     SBBroadcaster ("Driver"),
-    m_debugger (SBDebugger::Create(false)),
+    m_debugger (NULL),
     m_editline_pty (),
     m_editline_slave_fh (NULL),
     m_editline_reader (),
@@ -119,307 +48,12 @@
     m_option_data (),
     m_waiting_for_command (false)
 {
-    // We want to be able to handle CTRL+D in the terminal to have it terminate
-    // certain input
-    m_debugger.SetCloseInputOnEOF (false);
-    g_debugger_name = (char *) m_debugger.GetInstanceName();
-    if (g_debugger_name == NULL)
-        g_debugger_name = (char *) "";
-    g_driver = this;
 }
 
 Driver::~Driver ()
 {
-    g_driver = NULL;
-    g_debugger_name = NULL;
 }
 
-void
-Driver::CloseIOChannelFile ()
-{
-    // Write an End of File sequence to the file descriptor to ensure any
-    // read functions can exit.
-    char eof_str[] = "\x04";
-    ::write (m_editline_pty.GetMasterFileDescriptor(), eof_str, strlen(eof_str));
-
-    m_editline_pty.CloseMasterFileDescriptor();
-
-    if (m_editline_slave_fh)
-    {
-        ::fclose (m_editline_slave_fh);
-        m_editline_slave_fh = NULL;
-    }
-}
-
-// This function takes INDENT, which tells how many spaces to output at the front
-// of each line; TEXT, which is the text that is to be output. It outputs the 
-// text, on multiple lines if necessary, to RESULT, with INDENT spaces at the 
-// front of each line.  It breaks lines on spaces, tabs or newlines, shortening 
-// the line if necessary to not break in the middle of a word. It assumes that 
-// each output line should contain a maximum of OUTPUT_MAX_COLUMNS characters.
-
-void
-OutputFormattedUsageText (FILE *out, int indent, const char *text, int output_max_columns)
-{
-    int len = strlen (text);
-    std::string text_string (text);
-
-    // Force indentation to be reasonable.
-    if (indent >= output_max_columns)
-        indent = 0;
-
-    // Will it all fit on one line?
-
-    if (len + indent < output_max_columns)
-        // Output as a single line
-        fprintf (out, "%*s%s\n", indent, "", text);
-    else
-    {
-        // We need to break it up into multiple lines.
-        int text_width = output_max_columns - indent - 1;
-        int start = 0;
-        int end = start;
-        int final_end = len;
-        int sub_len;
-
-        while (end < final_end)
-        {
-              // Dont start the 'text' on a space, since we're already outputting the indentation.
-              while ((start < final_end) && (text[start] == ' '))
-                  start++;
-
-              end = start + text_width;
-              if (end > final_end)
-                  end = final_end;
-              else
-              {
-                  // If we're not at the end of the text, make sure we break the line on white space.
-                  while (end > start
-                         && text[end] != ' ' && text[end] != '\t' && text[end] != '\n')
-                      end--;
-              }
-              sub_len = end - start;
-              std::string substring = text_string.substr (start, sub_len);
-              fprintf (out, "%*s%s\n", indent, "", substring.c_str());
-              start = end + 1;
-        }
-    }
-}
-
-void
-ShowUsage (FILE *out, OptionDefinition *option_table, Driver::OptionData data)
-{
-    uint32_t screen_width = 80;
-    uint32_t indent_level = 0;
-    const char *name = "lldb";
-    
-    fprintf (out, "\nUsage:\n\n");
-
-    indent_level += 2;
-
-
-    // First, show each usage level set of options, e.g. <cmd> [options-for-level-0]
-    //                                                   <cmd> [options-for-level-1]
-    //                                                   etc.
-
-    uint32_t num_options;
-    uint32_t num_option_sets = 0;
-    
-    for (num_options = 0; option_table[num_options].long_option != NULL; ++num_options)
-    {
-        uint32_t this_usage_mask = option_table[num_options].usage_mask;
-        if (this_usage_mask == LLDB_OPT_SET_ALL)
-        {
-            if (num_option_sets == 0)
-                num_option_sets = 1;
-        }
-        else
-        {
-            for (uint32_t j = 0; j < LLDB_MAX_NUM_OPTION_SETS; j++)
-            {
-                if (this_usage_mask & 1 << j)
-                {
-                    if (num_option_sets <= j)
-                        num_option_sets = j + 1;
-                }
-            }
-        }
-    }
-
-    for (uint32_t opt_set = 0; opt_set < num_option_sets; opt_set++)
-    {
-        uint32_t opt_set_mask;
-        
-        opt_set_mask = 1 << opt_set;
-        
-        if (opt_set > 0)
-            fprintf (out, "\n");
-        fprintf (out, "%*s%s", indent_level, "", name);
-        bool is_help_line = false;
-        
-        for (uint32_t i = 0; i < num_options; ++i)
-        {
-            if (option_table[i].usage_mask & opt_set_mask)
-            {
-                CommandArgumentType arg_type = option_table[i].argument_type;
-                const char *arg_name = SBCommandInterpreter::GetArgumentTypeAsCString (arg_type);
-                // This is a bit of a hack, but there's no way to say certain options don't have arguments yet...
-                // so we do it by hand here.
-                if (option_table[i].short_option == 'h')
-                    is_help_line = true;
-                    
-                if (option_table[i].required)
-                {
-                    if (option_table[i].option_has_arg == required_argument)
-                        fprintf (out, " -%c <%s>", option_table[i].short_option, arg_name);
-                    else if (option_table[i].option_has_arg == optional_argument)
-                        fprintf (out, " -%c [<%s>]", option_table[i].short_option, arg_name);
-                    else
-                        fprintf (out, " -%c", option_table[i].short_option);
-                }
-                else
-                {
-                    if (option_table[i].option_has_arg == required_argument)
-                        fprintf (out, " [-%c <%s>]", option_table[i].short_option, arg_name);
-                    else if (option_table[i].option_has_arg == optional_argument)
-                        fprintf (out, " [-%c [<%s>]]", option_table[i].short_option, arg_name);
-                    else
-                        fprintf (out, " [-%c]", option_table[i].short_option);
-                }
-            }
-        }
-        if (!is_help_line && (opt_set <= last_option_set_with_args))
-            fprintf (out, " [[--] <PROGRAM-ARG-1> [<PROGRAM_ARG-2> ...]]");
-    }
-
-    fprintf (out, "\n\n");
-
-    // Now print out all the detailed information about the various options:  long form, short form and help text:
-    //   -- long_name <argument>
-    //   - short <argument>
-    //   help text
-
-    // This variable is used to keep track of which options' info we've printed out, because some options can be in
-    // more than one usage level, but we only want to print the long form of its information once.
-
-    Driver::OptionData::OptionSet options_seen;
-    Driver::OptionData::OptionSet::iterator pos;
-
-    indent_level += 5;
-
-    for (uint32_t i = 0; i < num_options; ++i)
-    {
-        // Only print this option if we haven't already seen it.
-        pos = options_seen.find (option_table[i].short_option);
-        if (pos == options_seen.end())
-        {
-            CommandArgumentType arg_type = option_table[i].argument_type;
-            const char *arg_name = SBCommandInterpreter::GetArgumentTypeAsCString (arg_type);
-
-            options_seen.insert (option_table[i].short_option);
-            fprintf (out, "%*s-%c ", indent_level, "", option_table[i].short_option);
-            if (arg_type != eArgTypeNone)
-                fprintf (out, "<%s>", arg_name);
-            fprintf (out, "\n");
-            fprintf (out, "%*s--%s ", indent_level, "", option_table[i].long_option);
-            if (arg_type != eArgTypeNone)
-                fprintf (out, "<%s>", arg_name);
-            fprintf (out, "\n");
-            indent_level += 5;
-            OutputFormattedUsageText (out, indent_level, option_table[i].usage_text, screen_width);
-            indent_level -= 5;
-            fprintf (out, "\n");
-        }
-    }
-
-    indent_level -= 5;
-
-    fprintf (out, "\n%*s(If you don't provide -f then the first argument will be the file to be debugged"
-                  "\n%*s so '%s -- <filename> [<ARG1> [<ARG2>]]' also works."
-                  "\n%*s Remember to end the options with \"--\" if any of your arguments have a \"-\" in them.)\n\n",
-             indent_level, "", 
-             indent_level, "",
-             name, 
-             indent_level, "");
-}
-
-void
-BuildGetOptTable (OptionDefinition *expanded_option_table, std::vector<struct option> &getopt_table, 
-                  uint32_t num_options)
-{
-    if (num_options == 0)
-        return;
-
-    uint32_t i;
-    uint32_t j;
-    std::bitset<256> option_seen;
-
-    getopt_table.resize (num_options + 1);
-
-    for (i = 0, j = 0; i < num_options; ++i)
-    {
-        char short_opt = expanded_option_table[i].short_option;
-        
-        if (option_seen.test(short_opt) == false)
-        {
-            getopt_table[j].name    = expanded_option_table[i].long_option;
-            getopt_table[j].has_arg = expanded_option_table[i].option_has_arg;
-            getopt_table[j].flag    = NULL;
-            getopt_table[j].val     = expanded_option_table[i].short_option;
-            option_seen.set(short_opt);
-            ++j;
-        }
-    }
-
-    getopt_table[j].name    = NULL;
-    getopt_table[j].has_arg = 0;
-    getopt_table[j].flag    = NULL;
-    getopt_table[j].val     = 0;
-
-}
-
-Driver::OptionData::OptionData () :
-    m_args(),
-    m_script_lang (lldb::eScriptLanguageDefault),
-    m_core_file (),
-    m_crash_log (),
-    m_source_command_files (),
-    m_debug_mode (false),
-    m_print_version (false),
-    m_print_help (false),
-    m_wait_for(false),
-    m_process_name(),
-    m_process_pid(LLDB_INVALID_PROCESS_ID),
-    m_use_external_editor(false),
-    m_seen_options()
-{
-}
-
-Driver::OptionData::~OptionData ()
-{
-}
-
-void
-Driver::OptionData::Clear ()
-{
-    m_args.clear ();
-    m_script_lang = lldb::eScriptLanguageDefault;
-    m_source_command_files.clear ();
-    m_debug_mode = false;
-    m_print_help = false;
-    m_print_version = false;
-    m_use_external_editor = false;
-    m_wait_for = false;
-    m_process_name.erase();
-    m_process_pid = LLDB_INVALID_PROCESS_ID;
-}
-
-void
-Driver::ResetOptionValues ()
-{
-    m_option_data.Clear ();
-}
-
 const char *
 Driver::GetFilename() const
 {
@@ -462,282 +96,6 @@
     return m_option_data.m_debug_mode;
 }
 
-
-// Check the arguments that were passed to this program to make sure they are valid and to get their
-// argument values (if any).  Return a boolean value indicating whether or not to start up the full
-// debugger (i.e. the Command Interpreter) or not.  Return FALSE if the arguments were invalid OR
-// if the user only wanted help or version information.
-
-SBError
-Driver::ParseArgs (int argc, const char *argv[], FILE *out_fh, bool &exit)
-{
-    ResetOptionValues ();
-
-    SBCommandReturnObject result;
-
-    SBError error;
-    std::string option_string;
-    struct option *long_options = NULL;
-    std::vector<struct option> long_options_vector;
-    uint32_t num_options;
-
-    for (num_options = 0; g_options[num_options].long_option != NULL; ++num_options)
-        /* Do Nothing. */;
-
-    if (num_options == 0)
-    {
-        if (argc > 1)
-            error.SetErrorStringWithFormat ("invalid number of options");
-        return error;
-    }
-
-    BuildGetOptTable (g_options, long_options_vector, num_options);
-
-    if (long_options_vector.empty())
-        long_options = NULL;
-    else
-        long_options = &long_options_vector.front();
-
-    if (long_options == NULL)
-    {
-        error.SetErrorStringWithFormat ("invalid long options");
-        return error;
-    }
-
-    // Build the option_string argument for call to getopt_long.
-
-    for (int i = 0; long_options[i].name != NULL; ++i)
-    {
-        if (long_options[i].flag == NULL)
-        {
-            option_string.push_back ((char) long_options[i].val);
-            switch (long_options[i].has_arg)
-            {
-                default:
-                case no_argument:
-                    break;
-                case required_argument:
-                    option_string.push_back (':');
-                    break;
-                case optional_argument:
-                    option_string.append ("::");
-                    break;
-            }
-        }
-    }
-
-    // This is kind of a pain, but since we make the debugger in the Driver's constructor, we can't
-    // know at that point whether we should read in init files yet.  So we don't read them in in the
-    // Driver constructor, then set the flags back to "read them in" here, and then if we see the
-    // "-n" flag, we'll turn it off again.  Finally we have to read them in by hand later in the
-    // main loop.
-    
-    m_debugger.SkipLLDBInitFiles (false);
-    m_debugger.SkipAppInitFiles (false);
-
-    // Prepare for & make calls to getopt_long.
-#if __GLIBC__
-    optind = 0;
-#else
-    optreset = 1;
-    optind = 1;
-#endif
-    int val;
-    while (1)
-    {
-        int long_options_index = -1;
-        val = ::getopt_long (argc, const_cast<char **>(argv), option_string.c_str(), long_options, &long_options_index);
-
-        if (val == -1)
-            break;
-        else if (val == '?')
-        {
-            m_option_data.m_print_help = true;
-            error.SetErrorStringWithFormat ("unknown or ambiguous option");
-            break;
-        }
-        else if (val == 0)
-            continue;
-        else
-        {
-            m_option_data.m_seen_options.insert ((char) val);
-            if (long_options_index == -1)
-            {
-                for (int i = 0;
-                     long_options[i].name || long_options[i].has_arg || long_options[i].flag || long_options[i].val;
-                     ++i)
-                {
-                    if (long_options[i].val == val)
-                    {
-                        long_options_index = i;
-                        break;
-                    }
-                }
-            }
-
-            if (long_options_index >= 0)
-            {
-                const char short_option = (char) g_options[long_options_index].short_option;
-
-                switch (short_option)
-                {
-                    case 'h':
-                        m_option_data.m_print_help = true;
-                        break;
-
-                    case 'v':
-                        m_option_data.m_print_version = true;
-                        break;
-
-                    case 'c':
-                        {
-                            SBFileSpec file(optarg);
-                            if (file.Exists())
-                            {
-                                m_option_data.m_core_file = optarg;
-                            }
-                            else
-                                error.SetErrorStringWithFormat("file specified in --core (-c) option doesn't exist: '%s'", optarg);
-                        }
-                        break;
-                    
-                    case 'e':
-                        m_option_data.m_use_external_editor = true;
-                        break;
-
-                    case 'x':
-                        m_debugger.SkipLLDBInitFiles (true);
-                        m_debugger.SkipAppInitFiles (true);
-                        break;
-
-                    case 'f':
-                        {
-                            SBFileSpec file(optarg);
-                            if (file.Exists())
-                            {
-                                m_option_data.m_args.push_back (optarg);
-                            }
-                            else if (file.ResolveExecutableLocation())
-                            {
-                                char path[PATH_MAX];
-                                file.GetPath (path, sizeof(path));
-                                m_option_data.m_args.push_back (path);
-                            }
-                            else
-                                error.SetErrorStringWithFormat("file specified in --file (-f) option doesn't exist: '%s'", optarg);
-                        }
-                        break;
-
-                    case 'a':
-                        if (!m_debugger.SetDefaultArchitecture (optarg))
-                            error.SetErrorStringWithFormat("invalid architecture in the -a or --arch option: '%s'", optarg);
-                        break;
-
-                    case 'l':
-                        m_option_data.m_script_lang = m_debugger.GetScriptingLanguage (optarg);
-                        break;
-
-                    case 'd':
-                        m_option_data.m_debug_mode = true;
-                        break;
-
-                    case 'n':
-                        m_option_data.m_process_name = optarg;
-                        break;
-                    
-                    case 'w':
-                        m_option_data.m_wait_for = true;
-                        break;
-                        
-                    case 'p':
-                        {
-                            char *remainder;
-                            m_option_data.m_process_pid = strtol (optarg, &remainder, 0);
-                            if (remainder == optarg || *remainder != '\0')
-                                error.SetErrorStringWithFormat ("Could not convert process PID: \"%s\" into a pid.",
-                                                                optarg);
-                        }
-                        break;
-                    case 's':
-                        {
-                            SBFileSpec file(optarg);
-                            if (file.Exists())
-                                m_option_data.m_source_command_files.push_back (optarg);
-                            else if (file.ResolveExecutableLocation())
-                            {
-                                char final_path[PATH_MAX];
-                                file.GetPath (final_path, sizeof(final_path));
-                                std::string path_str (final_path);
-                                m_option_data.m_source_command_files.push_back (path_str);
-                            }
-                            else
-                                error.SetErrorStringWithFormat("file specified in --source (-s) option doesn't exist: '%s'", optarg);
-                        }
-                        break;
-
-                    default:
-                        m_option_data.m_print_help = true;
-                        error.SetErrorStringWithFormat ("unrecognized option %c", short_option);
-                        break;
-                }
-            }
-            else
-            {
-                error.SetErrorStringWithFormat ("invalid option with value %i", val);
-            }
-            if (error.Fail())
-            {
-                return error;
-            }
-        }
-    }
-    
-    if (error.Fail() || m_option_data.m_print_help)
-    {
-        ShowUsage (out_fh, g_options, m_option_data);
-        exit = true;
-    }
-    else if (m_option_data.m_print_version)
-    {
-        ::fprintf (out_fh, "%s\n", m_debugger.GetVersionString());
-        exit = true;
-    }
-    else if (m_option_data.m_process_name.empty() && m_option_data.m_process_pid == LLDB_INVALID_PROCESS_ID)
-    {
-        // Any arguments that are left over after option parsing are for
-        // the program. If a file was specified with -f then the filename
-        // is already in the m_option_data.m_args array, and any remaining args
-        // are arguments for the inferior program. If no file was specified with
-        // -f, then what is left is the program name followed by any arguments.
-
-        // Skip any options we consumed with getopt_long
-        argc -= optind;
-        argv += optind;
-
-        if (argc > 0)
-        {
-            for (int arg_idx=0; arg_idx<argc; ++arg_idx)
-            {
-                const char *arg = argv[arg_idx];
-                if (arg)
-                    m_option_data.m_args.push_back (arg);
-            }
-        }
-        
-    }
-    else
-    {
-        // Skip any options we consumed with getopt_long
-        argc -= optind;
-        //argv += optind; // Commented out to keep static analyzer happy
-
-        if (argc > 0)
-            ::fprintf (out_fh, "Warning: program arguments are ignored when attaching.\n");
-    }
-
-    return error;
-}
-
 size_t
 Driver::GetProcessSTDOUT ()
 {
@@ -773,733 +131,186 @@
 {
     using namespace lldb;
     SBProcess process(m_debugger.GetSelectedTarget().GetProcess());
-    if (process.IsValid())
-    {
-        SBThread curr_thread (process.GetSelectedThread());
-        SBThread thread;
-        StopReason curr_thread_stop_reason = eStopReasonInvalid;
-        curr_thread_stop_reason = curr_thread.GetStopReason();
-
-        if (!curr_thread.IsValid() ||
-            curr_thread_stop_reason == eStopReasonInvalid ||
-            curr_thread_stop_reason == eStopReasonNone)
-        {
-            // Prefer a thread that has just completed its plan over another thread as current thread.
-            SBThread plan_thread;
-            SBThread other_thread;
-            const size_t num_threads = process.GetNumThreads();
-            size_t i;
-            for (i = 0; i < num_threads; ++i)
-            {
-                thread = process.GetThreadAtIndex(i);
-                StopReason thread_stop_reason = thread.GetStopReason();
-                switch (thread_stop_reason)
-                {
-                default:
-                case eStopReasonInvalid:
-                case eStopReasonNone:
-                    break;
-
-                case eStopReasonTrace:
-                case eStopReasonBreakpoint:
-                case eStopReasonWatchpoint:
-                case eStopReasonSignal:
-                case eStopReasonException:
-                    if (!other_thread.IsValid())
-                        other_thread = thread;
-                    break;
-                case eStopReasonPlanComplete:
-                    if (!plan_thread.IsValid())
-                        plan_thread = thread;
-                    break;
-                }
-            }
-            if (plan_thread.IsValid())
-                process.SetSelectedThread (plan_thread);
-            else if (other_thread.IsValid())
-                process.SetSelectedThread (other_thread);
-            else
-            {
-                if (curr_thread.IsValid())
-                    thread = curr_thread;
-                else
-                    thread = process.GetThreadAtIndex(0);
-
-                if (thread.IsValid())
-                    process.SetSelectedThread (thread);
-            }
-        }
-    }
-}
-
-// This function handles events that were broadcast by the process.
-void
-Driver::HandleBreakpointEvent (const SBEvent &event)
-{
-    using namespace lldb;
-    const uint32_t event_type = SBBreakpoint::GetBreakpointEventTypeFromEvent (event);
+    if (!process.IsValid())
+        return;
     
-    if (event_type & eBreakpointEventTypeAdded
-        || event_type & eBreakpointEventTypeRemoved
-        || event_type & eBreakpointEventTypeEnabled
-        || event_type & eBreakpointEventTypeDisabled
-        || event_type & eBreakpointEventTypeCommandChanged
-        || event_type & eBreakpointEventTypeConditionChanged
-        || event_type & eBreakpointEventTypeIgnoreChanged
-        || event_type & eBreakpointEventTypeLocationsResolved)
-    {
-        // Don't do anything about these events, since the breakpoint commands already echo these actions.
-    }              
-    else if (event_type & eBreakpointEventTypeLocationsAdded)
-    {
-        char message[256];
-        uint32_t num_new_locations = SBBreakpoint::GetNumBreakpointLocationsFromEvent(event);
-        if (num_new_locations > 0)
-        {
-            SBBreakpoint breakpoint = SBBreakpoint::GetBreakpointFromEvent(event);
-            int message_len = ::snprintf (message, sizeof(message), "%d location%s added to breakpoint %d\n", 
-                                          num_new_locations,
-                                          num_new_locations == 1 ? " " : "s ",
-                                          breakpoint.GetID());
-            m_io_channel_ap->OutWrite(message, message_len, ASYNC);
-        }
-    }
-    else if (event_type & eBreakpointEventTypeLocationsRemoved)
-    {
-       // These locations just get disabled, not sure it is worth spamming folks about this on the command line.
-    }
-    else if (event_type & eBreakpointEventTypeLocationsResolved)
-    {
-       // This might be an interesting thing to note, but I'm going to leave it quiet for now, it just looked noisy.
-    }
-}
+    SBThread curr_thread (process.GetSelectedThread());
+    SBThread thread;
+    StopReason curr_thread_stop_reason = eStopReasonInvalid;
+    curr_thread_stop_reason = curr_thread.GetStopReason();
 
-// This function handles events that were broadcast by the process.
-void
-Driver::HandleProcessEvent (const SBEvent &event)
-{
-    using namespace lldb;
-    const uint32_t event_type = event.GetType();
-
-    if (event_type & SBProcess::eBroadcastBitSTDOUT)
+    if (!curr_thread.IsValid() ||
+        curr_thread_stop_reason == eStopReasonInvalid ||
+        curr_thread_stop_reason == eStopReasonNone)
     {
-        // The process has stdout available, get it and write it out to the
-        // appropriate place.
-        GetProcessSTDOUT ();
-    }
-    else if (event_type & SBProcess::eBroadcastBitSTDERR)
-    {
-        // The process has stderr available, get it and write it out to the
-        // appropriate place.
-        GetProcessSTDERR ();
-    }
-    else if (event_type & SBProcess::eBroadcastBitStateChanged)
-    {
-        // Drain all stout and stderr so we don't see any output come after
-        // we print our prompts
-        GetProcessSTDOUT ();
-        GetProcessSTDERR ();
-        // Something changed in the process;  get the event and report the process's current status and location to
-        // the user.
-        StateType event_state = SBProcess::GetStateFromEvent (event);
-        if (event_state == eStateInvalid)
-            return;
-
-        SBProcess process (SBProcess::GetProcessFromEvent (event));
-        assert (process.IsValid());
-
-        switch (event_state)
+        // Prefer a thread that has just completed its plan over another thread as current thread.
+        SBThread plan_thread;
+        SBThread other_thread;
+       const size_t num_threads = process.GetNumThreads();
+        size_t i;
+        for (i = 0; i < num_threads; ++i)
         {
-        case eStateInvalid:
-        case eStateUnloaded:
-        case eStateConnected:
-        case eStateAttaching:
-        case eStateLaunching:
-        case eStateStepping:
-        case eStateDetached:
-            {
-                char message[1024];
-                int message_len = ::snprintf (message, sizeof(message), "Process %llu %s\n", process.GetProcessID(),
-                                              m_debugger.StateAsCString (event_state));
-                m_io_channel_ap->OutWrite(message, message_len, ASYNC);
-            }
-            break;
+            thread = process.GetThreadAtIndex(i);
+            StopReason thread_stop_reason = thread.GetStopReason();
+            switch (thread_stop_reason)
+			{
+            default:
+            case eStopReasonInvalid:
+            case eStopReasonNone:
+                break;
 
-        case eStateRunning:
-            // Don't be chatty when we run...
-            break;
-
-        case eStateExited:
-            {
-                SBCommandReturnObject result;
-                m_debugger.GetCommandInterpreter().HandleCommand("process status", result, false);
-                m_io_channel_ap->ErrWrite (result.GetError(), result.GetErrorSize(), ASYNC);
-                m_io_channel_ap->OutWrite (result.GetOutput(), result.GetOutputSize(), ASYNC);
+            case eStopReasonTrace:
+            case eStopReasonBreakpoint:
+            case eStopReasonWatchpoint:
+            case eStopReasonSignal:
+            case eStopReasonException:
+                if (!other_thread.IsValid())
+                    other_thread = thread;
+                break;
+            case eStopReasonPlanComplete:
+                if (!plan_thread.IsValid())
+                    plan_thread = thread;
+                break;
             }
-            break;
-
-        case eStateStopped:
-        case eStateCrashed:
-        case eStateSuspended:
-            // Make sure the program hasn't been auto-restarted:
-            if (SBProcess::GetRestartedFromEvent (event))
-            {
-                // FIXME: Do we want to report this, or would that just be annoyingly chatty?
-                char message[1024];
-                int message_len = ::snprintf (message, sizeof(message), "Process %llu stopped and was programmatically restarted.\n",
-                                              process.GetProcessID());
-                m_io_channel_ap->OutWrite(message, message_len, ASYNC);
-            }
-            else
-            {
-                if (GetDebugger().GetSelectedTarget() == process.GetTarget())
-                {
-                    SBCommandReturnObject result;
-                    UpdateSelectedThread ();
-                    m_debugger.GetCommandInterpreter().HandleCommand("process status", result, false);
-                    m_io_channel_ap->ErrWrite (result.GetError(), result.GetErrorSize(), ASYNC);
-                    m_io_channel_ap->OutWrite (result.GetOutput(), result.GetOutputSize(), ASYNC);
-                }
-                else
-                {
-                    SBStream out_stream;
-                    uint32_t target_idx = GetDebugger().GetIndexOfTarget(process.GetTarget());
-                    if (target_idx != UINT32_MAX)
-                        out_stream.Printf ("Target %d: (", target_idx);
-                    else
-                        out_stream.Printf ("Target <unknown index>: (");
-                    process.GetTarget().GetDescription (out_stream, eDescriptionLevelBrief);
-                    out_stream.Printf (") stopped.\n");
-                    m_io_channel_ap->OutWrite (out_stream.GetData(), out_stream.GetSize(), ASYNC);
-                }
-            }
-            break;
         }
-    }
-}
+        if (plan_thread.IsValid())
+            process.SetSelectedThread (plan_thread);
+        else if (other_thread.IsValid())
+            process.SetSelectedThread (other_thread);
+        else
+		{
+			if (curr_thread.IsValid())
+				thread = curr_thread;
+			else
+				thread = process.GetThreadAtIndex(0);
 
-//  This function handles events broadcast by the IOChannel (HasInput, UserInterrupt, or ThreadShouldExit).
-
-bool
-Driver::HandleIOEvent (const SBEvent &event)
-{
-    bool quit = false;
-
-    const uint32_t event_type = event.GetType();
-
-    if (event_type & IOChannel::eBroadcastBitHasUserInput)
-    {
-        // We got some input (i.e. a command string) from the user; pass it off to the command interpreter for
-        // handling.
-
-        const char *command_string = SBEvent::GetCStringFromEvent(event);
-        if (command_string == NULL)
-            command_string = "";
-        SBCommandReturnObject result;
-        
-        // We don't want the result to bypass the OutWrite function in IOChannel, as this can result in odd
-        // output orderings and problems with the prompt.
-        m_debugger.GetCommandInterpreter().HandleCommand (command_string, result, true);
-
-        if (result.GetOutputSize() > 0)
-            m_io_channel_ap->OutWrite (result.GetOutput(), result.GetOutputSize(), NO_ASYNC);
-            
-        if (result.GetErrorSize() > 0)
-            m_io_channel_ap->OutWrite (result.GetError(), result.GetErrorSize(), NO_ASYNC);
-
-        // We are done getting and running our command, we can now clear the
-        // m_waiting_for_command so we can get another one.
-        m_waiting_for_command = false;
-
-        // If our editline input reader is active, it means another input reader
-        // got pushed onto the input reader and caused us to become deactivated.
-        // When the input reader above us gets popped, we will get re-activated
-        // and our prompt will refresh in our callback
-        if (m_editline_reader.IsActive())
-        {
-            ReadyForCommand ();
+			if (thread.IsValid())
+				process.SetSelectedThread (thread);
         }
     }
-    else if (event_type & IOChannel::eBroadcastBitUserInterrupt)
-    {
-        // This is here to handle control-c interrupts from the user.  It has not yet really been implemented.
-        // TO BE DONE:  PROPERLY HANDLE CONTROL-C FROM USER
-        //m_io_channel_ap->CancelInput();
-        // Anything else?  Send Interrupt to process?
-    }
-    else if ((event_type & IOChannel::eBroadcastBitThreadShouldExit) ||
-             (event_type & IOChannel::eBroadcastBitThreadDidExit))
-    {
-        // If the IOChannel thread is trying to go away, then it is definitely
-        // time to end the debugging session.
-        quit = true;
-    }
-
-    return quit;
 }
 
-void
-Driver::MasterThreadBytesReceived (void *baton, const void *src, size_t src_len)
+void LogOutput(const char * msg, void *baton)
 {
-    Driver *driver = (Driver*)baton;
-    driver->GetFromMaster ((const char *)src, src_len);
+    puts(msg);
 }
 
-void
-Driver::GetFromMaster (const char *src, size_t src_len)
+void Driver::Initialize()
 {
-    // Echo the characters back to the Debugger's stdout, that way if you
-    // type characters while a command is running, you'll see what you've typed.
-    FILE *out_fh = m_debugger.GetOutputFileHandle();
-    if (out_fh)
-        ::fwrite (src, 1, src_len, out_fh);
-}
+    m_debugger = SBDebugger::Create(false, LogOutput, 0);
+    // We want to be able to handle CTRL+D in the terminal to have it terminate
+    // certain input
+    m_debugger.SetCloseInputOnEOF (false);
+    InitializePseudoTerminal();
+ 
 
-size_t
-Driver::EditLineInputReaderCallback 
-(
-    void *baton, 
-    SBInputReader *reader, 
-    InputReaderAction notification,
-    const char *bytes, 
-    size_t bytes_len
-)
-{
-    Driver *driver = (Driver *)baton;
-
-    switch (notification)
-    {
-    case eInputReaderActivate:
-        break;
-
-    case eInputReaderReactivate:
-        driver->ReadyForCommand();
-        break;
-
-    case eInputReaderDeactivate:
-        break;
-        
-    case eInputReaderAsynchronousOutputWritten:
-        if (driver->m_io_channel_ap.get() != NULL)
-            driver->m_io_channel_ap->RefreshPrompt();
-        break;
-
-    case eInputReaderInterrupt:
-        if (driver->m_io_channel_ap.get() != NULL)
-        {
-            SBProcess process(driver->GetDebugger().GetSelectedTarget().GetProcess());
-            if (!driver->m_io_channel_ap->EditLineHasCharacters()
-                &&  process.IsValid()
-                && (process.GetState() == lldb::eStateRunning || process.GetState() == lldb::eStateAttaching))
-            {
-                process.SendAsyncInterrupt ();
-            }
-            else
-            {
-                driver->m_io_channel_ap->OutWrite ("^C\n", 3, NO_ASYNC);
-                // I wish I could erase the entire input line, but there's no public API for that.
-                driver->m_io_channel_ap->EraseCharsBeforeCursor();
-                driver->m_io_channel_ap->RefreshPrompt();
-            }
-        }
-        break;
-        
-    case eInputReaderEndOfFile:
-        if (driver->m_io_channel_ap.get() != NULL)
-        {
-            driver->m_io_channel_ap->OutWrite ("^D\n", 3, NO_ASYNC);
-            driver->m_io_channel_ap->RefreshPrompt ();
-        }
-        write (driver->m_editline_pty.GetMasterFileDescriptor(), "quit\n", 5);
-        break;
-
-    case eInputReaderGotToken:
-        write (driver->m_editline_pty.GetMasterFileDescriptor(), bytes, bytes_len);
-        break;
-        
-    case eInputReaderDone:
-        break;
-    }
-    return bytes_len;
-}
-
-void
-Driver::MainLoop ()
-{
-    char error_str[1024];
-    if (m_editline_pty.OpenFirstAvailableMaster(O_RDWR|O_NOCTTY, error_str, sizeof(error_str)) == false)
-    {
-        ::fprintf (stderr, "error: failed to open driver pseudo terminal : %s", error_str);
-        exit(1);
-    }
-    else
-    {
-        const char *driver_slave_name = m_editline_pty.GetSlaveName (error_str, sizeof(error_str));
-        if (driver_slave_name == NULL)
-        {
-            ::fprintf (stderr, "error: failed to get slave name for driver pseudo terminal : %s", error_str);
-            exit(2);
-        }
-        else
-        {
-            m_editline_slave_fh = ::fopen (driver_slave_name, "r+");
-            if (m_editline_slave_fh == NULL)
-            {
-                SBError error;
-                error.SetErrorToErrno();
-                ::fprintf (stderr, "error: failed to get open slave for driver pseudo terminal : %s",
-                           error.GetCString());
-                exit(3);
-            }
-
-            ::setbuf (m_editline_slave_fh, NULL);
-        }
-    }
-
-    lldb_utility::PseudoTerminal editline_output_pty;
-    FILE *editline_output_slave_fh = NULL;
-    
-    if (editline_output_pty.OpenFirstAvailableMaster (O_RDWR|O_NOCTTY, error_str, sizeof (error_str)) == false)
-    {
-        ::fprintf (stderr, "error: failed to open output pseudo terminal : %s", error_str);
-        exit(1);
-    }
-    else
-    {
-        const char *output_slave_name = editline_output_pty.GetSlaveName (error_str, sizeof(error_str));
-        if (output_slave_name == NULL)
-        {
-            ::fprintf (stderr, "error: failed to get slave name for output pseudo terminal : %s", error_str);
-            exit(2);
-        }
-        else
-        {
-            editline_output_slave_fh = ::fopen (output_slave_name, "r+");
-            if (editline_output_slave_fh == NULL)
-            {
-                SBError error;
-                error.SetErrorToErrno();
-                ::fprintf (stderr, "error: failed to get open slave for output pseudo terminal : %s",
-                           error.GetCString());
-                exit(3);
-            }
-            ::setbuf (editline_output_slave_fh, NULL);
-        }
-    }
-
-   // struct termios stdin_termios;
-
-    if (::tcgetattr(STDIN_FILENO, &g_old_stdin_termios) == 0)
-    {
-        g_old_stdin_termios_is_valid = true;
-        atexit (reset_stdin_termios);
-    }
-
-    ::setbuf (stdin, NULL);
-    ::setbuf (stdout, NULL);
-
     m_debugger.SetErrorFileHandle (stderr, false);
     m_debugger.SetOutputFileHandle (stdout, false);
     m_debugger.SetInputFileHandle (stdin, true);
-    
+ 
     m_debugger.SetUseExternalEditor(m_option_data.m_use_external_editor);
 
-    // You have to drain anything that comes to the master side of the PTY.  master_out_comm is
-    // for that purpose.  The reason you need to do this is a curious reason...  editline will echo
-    // characters to the PTY when it gets characters while el_gets is not running, and then when
-    // you call el_gets (or el_getc) it will try to reset the terminal back to raw mode which blocks
-    // if there are unconsumed characters in the out buffer.
-    // However, you don't need to do anything with the characters, since editline will dump these
-    // unconsumed characters after printing the prompt again in el_gets.
+    InitializeEditLineIO();	
 
-    SBCommunication master_out_comm("driver.editline");
-    master_out_comm.SetCloseOnEOF (false);
-    master_out_comm.AdoptFileDesriptor(m_editline_pty.GetMasterFileDescriptor(), false);
-    master_out_comm.SetReadThreadBytesReceivedCallback(Driver::MasterThreadBytesReceived, this);
+	
+    SBCommandInterpreter sb_interpreter = m_debugger.GetCommandInterpreter();
+    m_interpreter = &sb_interpreter;
 
-    if (master_out_comm.ReadThreadStart () == false)
-    {
-        ::fprintf (stderr, "error: failed to start master out read thread");
-        exit(5);
-    }
+    SBListener listener(m_debugger.GetListener());
+    listener.StartListeningForEventClass(m_debugger, 
+                                         SBTarget::GetBroadcasterClassName(), 
+                                         SBTarget::eBroadcastBitBreakpointChanged);
+    if (!listener.IsValid())
+        return;
 
-    SBCommandInterpreter sb_interpreter = m_debugger.GetCommandInterpreter();
+    listener.StartListeningForEvents (*m_io_channel_ap,
+                                        IOChannel::eBroadcastBitHasUserInput |
+                                        IOChannel::eBroadcastBitUserInterrupt |
+                                        IOChannel::eBroadcastBitThreadShouldExit |
+                                        IOChannel::eBroadcastBitThreadDidStart |
+                                        IOChannel::eBroadcastBitThreadDidExit);
 
-    m_io_channel_ap.reset (new IOChannel(m_editline_slave_fh, editline_output_slave_fh, stdout, stderr, this));
+    if (!m_io_channel_ap->Start ())
+        return;
+    
+	iochannel_thread_exited = false;
+	
+    listener.StartListeningForEvents (sb_interpreter.GetBroadcaster(),
+                                        SBCommandInterpreter::eBroadcastBitQuitCommandReceived |
+                                        SBCommandInterpreter::eBroadcastBitAsynchronousOutputData |
+                                        SBCommandInterpreter::eBroadcastBitAsynchronousErrorData);
 
-    SBCommunication out_comm_2("driver.editline_output");
-    out_comm_2.SetCloseOnEOF (false);
-    out_comm_2.AdoptFileDesriptor (editline_output_pty.GetMasterFileDescriptor(), false);
-    out_comm_2.SetReadThreadBytesReceivedCallback (IOChannel::LibeditOutputBytesReceived, m_io_channel_ap.get());
+    // Before we handle any options from the command line, we parse the
+    // .lldbinit file in the user's home directory.
+    SBCommandReturnObject result;
+    sb_interpreter.SourceInitFileInHomeDirectory(result);
 
-    if (out_comm_2.ReadThreadStart () == false)
+    if (GetDebugMode())
     {
-        ::fprintf (stderr, "error: failed to start libedit output read thread");
-        exit (5);
+        result.PutError (m_debugger.GetErrorFileHandle());
+        result.PutOutput (m_debugger.GetOutputFileHandle());
     }
+	HandleCommandLine(result);
 
-
-    struct winsize window_size;
-    if (isatty (STDIN_FILENO)
-        && ::ioctl (STDIN_FILENO, TIOCGWINSZ, &window_size) == 0)
+    // Now that all option parsing is done, we try and parse the .lldbinit
+    // file in the current working directory
+    sb_interpreter.SourceInitFileInCurrentWorkingDirectory (result);
+    if (GetDebugMode())	
     {
-        if (window_size.ws_col > 0)
-            m_debugger.SetTerminalWidth (window_size.ws_col);
+        result.PutError(m_debugger.GetErrorFileHandle());
+        result.PutOutput(m_debugger.GetOutputFileHandle());
     }
-
-    // Since input can be redirected by the debugger, we must insert our editline
-    // input reader in the queue so we know when our reader should be active
-    // and so we can receive bytes only when we are supposed to.
-    SBError err (m_editline_reader.Initialize (m_debugger, 
-                                               Driver::EditLineInputReaderCallback, // callback
-                                               this,                              // baton
-                                               eInputReaderGranularityByte,       // token_size
-                                               NULL,                              // end token - NULL means never done
-                                               NULL,                              // prompt - taken care of elsewhere
-                                               false));                           // echo input - don't need Debugger 
-                                                                                  // to do this, we handle it elsewhere
+	SBEvent event;
+    // Make sure the IO channel is started up before we try to tell it we
+    // are ready for input
+    listener.WaitForEventForBroadcasterWithType (UINT32_MAX, 
+                                                    *m_io_channel_ap,
+                                                    IOChannel::eBroadcastBitThreadDidStart, 
+                                                    event);
     
-    if (err.Fail())
+    // If we were asked to attach, then do that here:
+    // I'm going to use the command string rather than directly
+    // calling the API's because then I don't have to recode the
+    // event handling here.
+    if (!m_option_data.m_process_name.empty()
+        || m_option_data.m_process_pid != LLDB_INVALID_PROCESS_ID)
     {
-        ::fprintf (stderr, "error: %s", err.GetCString());
-        exit (6);
+        AttachToProcess();
     }
     
-    m_debugger.PushInputReader (m_editline_reader);
+    ReadyForCommand ();
+}
 
-    SBListener listener(m_debugger.GetListener());
-    listener.StartListeningForEventClass(m_debugger, 
-                                         SBTarget::GetBroadcasterClassName(), 
-                                         SBTarget::eBroadcastBitBreakpointChanged);
-    if (listener.IsValid())
+void
+Driver::MainLoop ()
+{
+    SBEvent event;
+    while (!GetIsDone())
     {
-
-        listener.StartListeningForEvents (*m_io_channel_ap,
-                                          IOChannel::eBroadcastBitHasUserInput |
-                                          IOChannel::eBroadcastBitUserInterrupt |
-                                          IOChannel::eBroadcastBitThreadShouldExit |
-                                          IOChannel::eBroadcastBitThreadDidStart |
-                                          IOChannel::eBroadcastBitThreadDidExit);
-
-        if (m_io_channel_ap->Start ())
+        m_listener->WaitForEvent (UINT32_MAX, event);
+        if (event.IsValid())
+		{
+            ProcessEvent(event);
+        }
+    }
+	
+	
+    DestroyPseudoTerminal();
+    CloseIOChannelFile ();
+ 
+    if (!iochannel_thread_exited)
+    {
+	        event.Clear();
+        m_listener->GetNextEventForBroadcasterWithType (*m_io_channel_ap,
+                                                        IOChannel::eBroadcastBitThreadDidExit,
+                                                        event);
+        if (!event.IsValid())
         {
-            bool iochannel_thread_exited = false;
-
-            listener.StartListeningForEvents (sb_interpreter.GetBroadcaster(),
-                                              SBCommandInterpreter::eBroadcastBitQuitCommandReceived |
-                                              SBCommandInterpreter::eBroadcastBitAsynchronousOutputData |
-                                              SBCommandInterpreter::eBroadcastBitAsynchronousErrorData);
-
-            // Before we handle any options from the command line, we parse the
-            // .lldbinit file in the user's home directory.
-            SBCommandReturnObject result;
-            sb_interpreter.SourceInitFileInHomeDirectory(result);
-            if (GetDebugMode())
-            {
-                result.PutError (m_debugger.GetErrorFileHandle());
-                result.PutOutput (m_debugger.GetOutputFileHandle());
-            }
-
-            // Now we handle options we got from the command line
-            char command_string[PATH_MAX * 2];
-            const size_t num_source_command_files = GetNumSourceCommandFiles();
-            if (num_source_command_files > 0)
-            {
-                for (size_t i=0; i < num_source_command_files; ++i)
-                {
-                    const char *command_file = GetSourceCommandFileAtIndex(i);
-                    ::snprintf (command_string, sizeof(command_string), "command source '%s'", command_file);
-                    m_debugger.GetCommandInterpreter().HandleCommand (command_string, result, false);
-                    if (GetDebugMode())
-                    {
-                        result.PutError (m_debugger.GetErrorFileHandle());
-                        result.PutOutput (m_debugger.GetOutputFileHandle());
-                    }
-                }
-            }
-
-            // Was there a core file specified?
-            std::string core_file_spec("");
-            if (!m_option_data.m_core_file.empty())
-                core_file_spec.append("--core ").append(m_option_data.m_core_file);
-
-            const size_t num_args = m_option_data.m_args.size();
-            if (num_args > 0)
-            {
-                char arch_name[64];
-                if (m_debugger.GetDefaultArchitecture (arch_name, sizeof (arch_name)))
-                    ::snprintf (command_string, 
-                                sizeof (command_string), 
-                                "target create --arch=%s %s \"%s\"", 
-                                arch_name,
-                                core_file_spec.c_str(),
-                                m_option_data.m_args[0].c_str());
-                else
-                    ::snprintf (command_string, 
-                                sizeof(command_string), 
-                                "target create %s \"%s\"", 
-                                core_file_spec.c_str(),
-                                m_option_data.m_args[0].c_str());
-
-                m_debugger.HandleCommand (command_string);
-                
-                if (num_args > 1)
-                {
-                    m_debugger.HandleCommand ("settings clear target.run-args");
-                    char arg_cstr[1024];
-                    for (size_t arg_idx = 1; arg_idx < num_args; ++arg_idx)
-                    {
-                        ::snprintf (arg_cstr, 
-                                    sizeof(arg_cstr), 
-                                    "settings append target.run-args \"%s\"", 
-                                    m_option_data.m_args[arg_idx].c_str());
-                        m_debugger.HandleCommand (arg_cstr);
-                    }
-                }
-            }
-            else if (!core_file_spec.empty())
-            {
-                ::snprintf (command_string, 
-                            sizeof(command_string), 
-                            "target create %s", 
-                            core_file_spec.c_str());
-                m_debugger.HandleCommand (command_string);;
-            }
-
-            // Now that all option parsing is done, we try and parse the .lldbinit
-            // file in the current working directory
-            sb_interpreter.SourceInitFileInCurrentWorkingDirectory (result);
-            if (GetDebugMode())
-            {
-                result.PutError(m_debugger.GetErrorFileHandle());
-                result.PutOutput(m_debugger.GetOutputFileHandle());
-            }
-
-            SBEvent event;
-
-            // Make sure the IO channel is started up before we try to tell it we
-            // are ready for input
-            listener.WaitForEventForBroadcasterWithType (UINT32_MAX, 
-                                                         *m_io_channel_ap,
-                                                         IOChannel::eBroadcastBitThreadDidStart, 
-                                                         event);
-            // If we were asked to attach, then do that here:
-            // I'm going to use the command string rather than directly
-            // calling the API's because then I don't have to recode the
-            // event handling here.
-            if (!m_option_data.m_process_name.empty()
-                || m_option_data.m_process_pid != LLDB_INVALID_PROCESS_ID)
-            {
-                std::string command_str("process attach ");
-                if (m_option_data.m_process_pid != LLDB_INVALID_PROCESS_ID)
-                {
-                    command_str.append("-p ");
-                    char pid_buffer[32];
-                    ::snprintf (pid_buffer, sizeof(pid_buffer), "%llu", m_option_data.m_process_pid);
-                    command_str.append(pid_buffer);
-                }
-                else 
-                {
-                    command_str.append("-n \"");
-                    command_str.append(m_option_data.m_process_name);
-                    command_str.push_back('\"');
-                    if (m_option_data.m_wait_for)
-                        command_str.append(" -w");
-                }
-                
-                if (m_debugger.GetOutputFileHandle())
-                    ::fprintf (m_debugger.GetOutputFileHandle(), 
-                               "Attaching to process with:\n    %s\n", 
-                               command_str.c_str());
-                                               
-                // Force the attach to be synchronous:
-                bool orig_async = m_debugger.GetAsync();
-                m_debugger.SetAsync(true);
-                m_debugger.HandleCommand(command_str.c_str());
-                m_debugger.SetAsync(orig_async);                
-            }
-                        
-            ReadyForCommand ();
-
-            while (!GetIsDone())
-            {
-                listener.WaitForEvent (UINT32_MAX, event);
-                if (event.IsValid())
-                {
-                    if (event.GetBroadcaster().IsValid())
-                    {
-                        uint32_t event_type = event.GetType();
-                        if (event.BroadcasterMatchesRef (*m_io_channel_ap))
-                        {
-                            if ((event_type & IOChannel::eBroadcastBitThreadShouldExit) ||
-                                (event_type & IOChannel::eBroadcastBitThreadDidExit))
-                            {
-                                SetIsDone();
-                                if (event_type & IOChannel::eBroadcastBitThreadDidExit)
-                                    iochannel_thread_exited = true;
-                            }
-                            else
-                            {
-                                if (HandleIOEvent (event))
-                                    SetIsDone();
-                            }
-                        }
-                        else if (SBProcess::EventIsProcessEvent (event))
-                        {
-                            HandleProcessEvent (event);
-                        }
-                        else if (SBBreakpoint::EventIsBreakpointEvent (event))
-                        {
-                            HandleBreakpointEvent (event);
-                        }
-                        else if (event.BroadcasterMatchesRef (sb_interpreter.GetBroadcaster()))
-                        {
-                            // TODO: deprecate the eBroadcastBitQuitCommandReceived event
-                            // now that we have SBCommandInterpreter::SetCommandOverrideCallback()
-                            // that can take over a command
-                            if (event_type & SBCommandInterpreter::eBroadcastBitQuitCommandReceived)
-                            {
-                                SetIsDone();
-                            }
-                            else if (event_type & SBCommandInterpreter::eBroadcastBitAsynchronousErrorData)
-                            {
-                                const char *data = SBEvent::GetCStringFromEvent (event);
-                                m_io_channel_ap->ErrWrite (data, strlen(data), ASYNC);
-                            }
-                            else if (event_type & SBCommandInterpreter::eBroadcastBitAsynchronousOutputData)
-                            {
-                                const char *data = SBEvent::GetCStringFromEvent (event);
-                                m_io_channel_ap->OutWrite (data, strlen(data), ASYNC);
-                            }
-                        }
-                    }
-                }
-            }
-
-            editline_output_pty.CloseMasterFileDescriptor();
-            master_out_comm.Disconnect();
-            out_comm_2.Disconnect();
-            reset_stdin_termios();
-            fclose (stdin);
-
-            CloseIOChannelFile ();
-
-            if (!iochannel_thread_exited)
-            {
-                event.Clear();
-                listener.GetNextEventForBroadcasterWithType (*m_io_channel_ap,
-                                                             IOChannel::eBroadcastBitThreadDidExit,
-                                                             event);
-                if (!event.IsValid())
-                {
-                    // Send end EOF to the driver file descriptor
-                    m_io_channel_ap->Stop();
-                }
-            }
-
-            SBDebugger::Destroy (m_debugger);
+            // Send end EOF to the driver file descriptor
+            m_io_channel_ap->Stop();
         }
     }
+	SBDebugger::Destroy (m_debugger);
 }
 
 
@@ -1513,57 +324,30 @@
     }
 }
 
+// defined in DriverPosix.cpp
+void SetupPosixSignals();
 
-void
-sigwinch_handler (int signo)
-{
-    struct winsize window_size;
-    if (isatty (STDIN_FILENO)
-        && ::ioctl (STDIN_FILENO, TIOCGWINSZ, &window_size) == 0)
-    {
-        if ((window_size.ws_col > 0) && g_driver != NULL)
-        {
-            g_driver->GetDebugger().SetTerminalWidth (window_size.ws_col);
-        }
-    }
-}
-
-void
-sigint_handler (int signo)
-{
-	static bool g_interrupt_sent = false;
-    if (g_driver)
-	{
-		if (!g_interrupt_sent)
-		{
-			g_interrupt_sent = true;
-        	g_driver->GetDebugger().DispatchInputInterrupt();
-			g_interrupt_sent = false;
-			return;
-		}
-	}
-    
-	exit (signo);
-}
-
 int
 main (int argc, char const *argv[], const char *envp[])
 {
+#if 1 // Enable for debug logging
+    lldb::StreamSP logStream(new lldb_private::StreamCallback(LogOutput, 0));
+    const char* logCategories[] = { 0 };
+    lldb::LogSP log = lldb_private::EnableLog(logStream, 0, logCategories, 0);
+    log->GetMask().Reset(LIBLLDB_LOG_ALL);
+#endif
     SBDebugger::Initialize();
     
     SBHostOS::ThreadCreated ("<lldb.driver.main-thread>");
 
-    signal (SIGPIPE, SIG_IGN);
-    signal (SIGWINCH, sigwinch_handler);
-    signal (SIGINT, sigint_handler);
-
+	SetupPosixSignals();
     // Create a scope for driver so that the driver object will destroy itself
     // before SBDebugger::Terminate() is called.
     {
         Driver driver;
 
         bool exit = false;
-        SBError error (driver.ParseArgs (argc, argv, stdout, exit));
+        SBError error = driver.ParseArgs (argc, argv, stdout, exit);
         if (error.Fail())
         {
             const char *error_cstr = error.GetCString ();
@@ -1572,7 +356,7 @@
         }
         else if (!exit)
         {
-            driver.MainLoop ();
+            driver.Initialize();
         }
     }
 
Index: tools/driver/Driver.h
===================================================================
--- tools/driver/Driver.h	(revision 163322)
+++ tools/driver/Driver.h	(working copy)
@@ -10,8 +10,6 @@
 #ifndef lldb_Driver_h_
 #define lldb_Driver_h_
 
-#include "lldb/Utility/PseudoTerminal.h"
-
 #include <set>
 #include <bitset>
 #include <string>
@@ -22,6 +20,10 @@
 #include "lldb/API/SBDebugger.h"
 #include "lldb/API/SBError.h"
 #include "lldb/API/SBInputReader.h"
+#include "lldb/API/SBEvent.h"
+#include "lldb/API/SBCommandInterpreter.h"
+#include "lldb/API/SBCommandReturnObject.h"
+#include "lldb/Utility/PseudoTerminal.h"
 
 #define ASYNC true
 #define NO_ASYNC false
@@ -33,7 +35,6 @@
     class SBInputReader;
 }
 
-
 class Driver : public lldb::SBBroadcaster
 {
 public:
@@ -48,6 +49,9 @@
     ~Driver ();
 
     void
+    Initialize();
+
+    void
     MainLoop ();
 
     void
@@ -150,6 +154,9 @@
 
 private:
     lldb::SBDebugger m_debugger;
+    lldb::SBCommandInterpreter* m_interpreter;
+    lldb::SBListener* m_listener;
+
     lldb_utility::PseudoTerminal m_editline_pty;
     FILE *m_editline_slave_fh;
     lldb::SBInputReader m_editline_reader;
@@ -158,6 +165,8 @@
     bool m_waiting_for_command;
     bool m_done;
 
+    bool iochannel_thread_exited;
+
     void
     ResetOptionValues ();
 
@@ -173,6 +182,24 @@
     void
     CloseIOChannelFile ();
 
+    void
+    InitializePseudoTerminal();
+
+    void
+    DestroyPseudoTerminal();
+
+    void
+    InitializeEditLineIO();
+
+    void
+    ProcessEvent(lldb::SBEvent& event);
+
+    void
+    AttachToProcess();
+
+    void
+    HandleCommandLine(lldb::SBCommandReturnObject& result);
+
     static size_t
     EditLineInputReaderCallback (void *baton, 
                                  lldb::SBInputReader *reader, 
Index: tools/driver/DriverEvents.cpp
===================================================================
--- tools/driver/DriverEvents.cpp	(revision 0)
+++ tools/driver/DriverEvents.cpp	(working copy)
@@ -0,0 +1,413 @@
+//===-- Driver.cpp ----------------------------------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "Driver.h"
+
+#ifdef _WIN32
+#include "lldb/lldb-windows.h"
+#endif
+
+#include <string.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <fcntl.h>
+
+#include "IOChannel.h"
+#include "lldb/API/SBBreakpoint.h"
+#include "lldb/API/SBCommandInterpreter.h"
+#include "lldb/API/SBCommandReturnObject.h"
+#include "lldb/API/SBCommunication.h"
+#include "lldb/API/SBDebugger.h"
+#include "lldb/API/SBEvent.h"
+#include "lldb/API/SBHostOS.h"
+#include "lldb/API/SBListener.h"
+#include "lldb/API/SBStream.h"
+#include "lldb/API/SBTarget.h"
+#include "lldb/API/SBThread.h"
+#include "lldb/API/SBProcess.h"
+
+using namespace lldb;
+
+// This function handles events that were broadcast by the process.
+void
+Driver::HandleBreakpointEvent (const SBEvent &event)
+{
+    const uint32_t event_type = SBBreakpoint::GetBreakpointEventTypeFromEvent (event);
+    
+    if (event_type & eBreakpointEventTypeAdded
+        || event_type & eBreakpointEventTypeRemoved
+        || event_type & eBreakpointEventTypeEnabled
+        || event_type & eBreakpointEventTypeDisabled
+        || event_type & eBreakpointEventTypeCommandChanged
+        || event_type & eBreakpointEventTypeConditionChanged
+        || event_type & eBreakpointEventTypeIgnoreChanged
+        || event_type & eBreakpointEventTypeLocationsResolved)
+        return;
+        // Don't do anything about these events, since the breakpoint commands already echo these actions.
+    
+    if (event_type & eBreakpointEventTypeLocationsAdded)
+    {
+        uint32_t num_new_locations = SBBreakpoint::GetNumBreakpointLocationsFromEvent(event);
+        if (num_new_locations > 0)
+        {
+            SBBreakpoint breakpoint = SBBreakpoint::GetBreakpointFromEvent(event);
+
+            char message[256];
+            int message_len = ::snprintf (message, sizeof(message), "%d location%s added to breakpoint %d\n", 
+                                          num_new_locations,
+                                          num_new_locations == 1 ? " " : "s ",
+                                          breakpoint.GetID());
+            m_io_channel_ap->OutWrite(message, message_len, ASYNC);
+        }
+    }
+    else if (event_type & eBreakpointEventTypeLocationsRemoved)
+    {
+       // These locations just get disabled, not sure it is worth spamming folks about this on the command line.
+    }
+    else if (event_type & eBreakpointEventTypeLocationsResolved)
+    {
+       // This might be an interesting thing to note, but I'm going to leave it quiet for now, it just looked noisy.
+    }
+}
+
+// This function handles events that were broadcast by the process.
+void
+Driver::HandleProcessEvent (const SBEvent &event)
+{
+    using namespace lldb;
+    const uint32_t event_type = event.GetType();
+
+    if (event_type & SBProcess::eBroadcastBitSTDOUT)
+    {
+        // The process has stdout available, get it and write it out to the
+        // appropriate place.
+        GetProcessSTDOUT ();
+    }
+    else if (event_type & SBProcess::eBroadcastBitSTDERR)
+    {
+        // The process has stderr available, get it and write it out to the
+        // appropriate place.
+        GetProcessSTDERR ();
+    }
+    else if (event_type & SBProcess::eBroadcastBitStateChanged)
+    {
+        // Drain all stout and stderr so we don't see any output come after
+        // we print our prompts
+        GetProcessSTDOUT ();
+        GetProcessSTDERR ();
+        // Something changed in the process;  get the event and report the process's current status and location to
+        // the user.
+        StateType event_state = SBProcess::GetStateFromEvent (event);
+        if (event_state == eStateInvalid)
+            return;
+
+        SBProcess process (SBProcess::GetProcessFromEvent (event));
+        assert (process.IsValid());
+
+        switch (event_state)
+        {
+        case eStateInvalid:
+        case eStateUnloaded:
+        case eStateConnected:
+        case eStateAttaching:
+        case eStateLaunching:
+        case eStateStepping:
+        case eStateDetached:
+            {
+                char message[1024];
+                int message_len = ::snprintf (message, sizeof(message), "Process %llu %s\n", process.GetProcessID(),
+                                              m_debugger.StateAsCString (event_state));
+                m_io_channel_ap->OutWrite(message, message_len, ASYNC);
+            }
+            break;
+
+        case eStateRunning:
+            // Don't be chatty when we run...
+            break;
+
+        case eStateExited:
+            {
+                SBCommandReturnObject result;
+                m_debugger.GetCommandInterpreter().HandleCommand("process status", result, false);
+                m_io_channel_ap->ErrWrite (result.GetError(), result.GetErrorSize(), ASYNC);
+                m_io_channel_ap->OutWrite (result.GetOutput(), result.GetOutputSize(), ASYNC);
+            }
+            break;
+
+        case eStateStopped:
+        case eStateCrashed:
+        case eStateSuspended:
+            // Make sure the program hasn't been auto-restarted:
+            if (SBProcess::GetRestartedFromEvent (event))
+            {
+                // FIXME: Do we want to report this, or would that just be annoyingly chatty?
+                char message[1024];
+                int message_len = ::snprintf (message, sizeof(message), "Process %llu stopped and was programmatically restarted.\n",
+                                              process.GetProcessID());
+                m_io_channel_ap->OutWrite(message, message_len, ASYNC);
+            }
+            else
+            {
+                if (GetDebugger().GetSelectedTarget() == process.GetTarget())
+                {
+                    SBCommandReturnObject result;
+                    UpdateSelectedThread ();
+                    m_debugger.GetCommandInterpreter().HandleCommand("process status", result, false);
+                    m_io_channel_ap->ErrWrite (result.GetError(), result.GetErrorSize(), ASYNC);
+                    m_io_channel_ap->OutWrite (result.GetOutput(), result.GetOutputSize(), ASYNC);
+                }
+                else
+                {
+                    SBStream out_stream;
+                    uint32_t target_idx = GetDebugger().GetIndexOfTarget(process.GetTarget());
+                    if (target_idx != UINT32_MAX)
+                        out_stream.Printf ("Target %d: (", target_idx);
+                    else
+                        out_stream.Printf ("Target <unknown index>: (");
+                    process.GetTarget().GetDescription (out_stream, eDescriptionLevelBrief);
+                    out_stream.Printf (") stopped.\n");
+                    m_io_channel_ap->OutWrite (out_stream.GetData(), out_stream.GetSize(), ASYNC);
+                }
+            }
+            break;
+        }
+    }
+}
+
+//  This function handles events broadcast by the IOChannel (HasInput, UserInterrupt, or ThreadShouldExit).
+
+bool
+Driver::HandleIOEvent (const SBEvent &event)
+{
+    bool quit = false;
+
+    const uint32_t event_type = event.GetType();
+
+    if (event_type & IOChannel::eBroadcastBitHasUserInput)
+    {
+        // We got some input (i.e. a command string) from the user; pass it off to the command interpreter for
+        // handling.
+
+        const char *command_string = SBEvent::GetCStringFromEvent(event);
+        if (command_string == NULL)
+            command_string = "";
+        SBCommandReturnObject result;
+        
+        // We don't want the result to bypass the OutWrite function in IOChannel, as this can result in odd
+        // output orderings and problems with the prompt.
+        m_debugger.GetCommandInterpreter().HandleCommand (command_string, result, true);
+
+        if (result.GetOutputSize() > 0)
+            m_io_channel_ap->OutWrite (result.GetOutput(), result.GetOutputSize(), NO_ASYNC);
+            
+        if (result.GetErrorSize() > 0)
+            m_io_channel_ap->OutWrite (result.GetError(), result.GetErrorSize(), NO_ASYNC);
+
+        // We are done getting and running our command, we can now clear the
+        // m_waiting_for_command so we can get another one.
+        m_waiting_for_command = false;
+
+        // If our editline input reader is active, it means another input reader
+        // got pushed onto the input reader and caused us to become deactivated.
+        // When the input reader above us gets popped, we will get re-activated
+        // and our prompt will refresh in our callback
+        if (m_editline_reader.IsActive())
+        {
+            ReadyForCommand ();
+        }
+    }
+    else if (event_type & IOChannel::eBroadcastBitUserInterrupt)
+    {
+        // This is here to handle control-c interrupts from the user.  It has not yet really been implemented.
+        // TO BE DONE:  PROPERLY HANDLE CONTROL-C FROM USER
+        //m_io_channel_ap->CancelInput();
+        // Anything else?  Send Interrupt to process?
+    }
+    else if ((event_type & IOChannel::eBroadcastBitThreadShouldExit) ||
+             (event_type & IOChannel::eBroadcastBitThreadDidExit))
+    {
+        // If the IOChannel thread is trying to go away, then it is definitely
+        // time to end the debugging session.
+        quit = true;
+    }
+
+    return quit;
+}
+
+void
+Driver::MasterThreadBytesReceived (void *baton, const void *src, size_t src_len)
+{
+    Driver *driver = (Driver*)baton;
+    driver->GetFromMaster ((const char *)src, src_len);
+}
+
+void
+Driver::GetFromMaster (const char *src, size_t src_len)
+{
+    // Echo the characters back to the Debugger's stdout, that way if you
+    // type characters while a command is running, you'll see what you've typed.
+    FILE *out_fh = m_debugger.GetOutputFileHandle();
+    if (out_fh)
+        ::fwrite (src, 1, src_len, out_fh);
+}
+
+size_t
+Driver::EditLineInputReaderCallback 
+(
+    void *baton, 
+    SBInputReader *reader, 
+    InputReaderAction notification,
+    const char *bytes, 
+    size_t bytes_len
+)
+{
+    Driver *driver = (Driver *)baton;
+
+    switch (notification)
+    {
+    case eInputReaderActivate:
+        break;
+
+    case eInputReaderReactivate:
+        driver->ReadyForCommand();
+        break;
+
+    case eInputReaderDeactivate:
+        break;
+        
+    case eInputReaderAsynchronousOutputWritten:
+        if (driver->m_io_channel_ap.get() != NULL)
+            driver->m_io_channel_ap->RefreshPrompt();
+        break;
+
+    case eInputReaderInterrupt:
+        if (driver->m_io_channel_ap.get() != NULL)
+        {
+            SBProcess process = driver->GetDebugger().GetSelectedTarget().GetProcess();
+            if (!driver->m_io_channel_ap->EditLineHasCharacters()
+                &&  process.IsValid() && process.GetState() == lldb::eStateRunning)
+            {
+                process.Stop();
+            }
+            else
+            {
+                driver->m_io_channel_ap->OutWrite ("^C\n", 3, NO_ASYNC);
+                // I wish I could erase the entire input line, but there's no public API for that.
+                driver->m_io_channel_ap->EraseCharsBeforeCursor();
+                driver->m_io_channel_ap->RefreshPrompt();
+            }
+        }
+        break;
+        
+    case eInputReaderEndOfFile:
+        if (driver->m_io_channel_ap.get() != NULL)
+        {
+            driver->m_io_channel_ap->OutWrite ("^D\n", 3, NO_ASYNC);
+            driver->m_io_channel_ap->RefreshPrompt ();
+        }
+#ifdef __unix__
+        write (driver->m_editline_pty.GetMasterFileDescriptor(), "quit\n", 5);
+#endif
+        break;
+
+    case eInputReaderGotToken:
+#ifdef __unix__
+        write (driver->m_editline_pty.GetMasterFileDescriptor(), bytes, bytes_len);
+#endif
+        break;
+        
+    case eInputReaderDone:
+        break;
+    }
+    return bytes_len;
+}
+
+void
+Driver::AttachToProcess()
+{
+    std::string command_str("process attach ");
+    if (m_option_data.m_process_pid != LLDB_INVALID_PROCESS_ID)
+    {
+        command_str.append("-p ");
+        char pid_buffer[32];
+        ::snprintf (pid_buffer, sizeof(pid_buffer), "%llu", m_option_data.m_process_pid);
+        command_str.append(pid_buffer);
+    }
+    else 
+    {
+        command_str.append("-n \"");
+        command_str.append(m_option_data.m_process_name);
+        command_str.push_back('\"');
+        if (m_option_data.m_wait_for)
+            command_str.append(" -w");
+    }
+                
+    if (m_debugger.GetOutputFileHandle())
+        ::fprintf (m_debugger.GetOutputFileHandle(), 
+                    "Attaching to process with:\n    %s\n", 
+                    command_str.c_str());
+                                               
+    // Force the attach to be synchronous:
+    bool orig_async = m_debugger.GetAsync();
+    m_debugger.SetAsync(true);
+    m_debugger.HandleCommand(command_str.c_str());
+    m_debugger.SetAsync(orig_async);
+}
+
+void
+Driver::ProcessEvent(SBEvent& event)
+{
+    if (!event.GetBroadcaster().IsValid())
+        return;
+
+    uint32_t event_type = event.GetType();
+    if (event.BroadcasterMatchesRef (*m_io_channel_ap))
+    {
+        if ((event_type & IOChannel::eBroadcastBitThreadShouldExit) ||
+            (event_type & IOChannel::eBroadcastBitThreadDidExit))
+        {
+            SetIsDone();
+            if (event_type & IOChannel::eBroadcastBitThreadDidExit)
+                iochannel_thread_exited = true;
+        }
+        else
+        {
+            if (HandleIOEvent (event))
+                SetIsDone();
+        }
+    }
+    else if (SBProcess::EventIsProcessEvent (event))
+    {
+        HandleProcessEvent (event);
+    }
+    else if (SBBreakpoint::EventIsBreakpointEvent (event))
+    {
+        HandleBreakpointEvent (event);
+    }
+    else if (event.BroadcasterMatchesRef (m_interpreter->GetBroadcaster()))
+    {
+        // TODO: deprecate the eBroadcastBitQuitCommandReceived event
+        // now that we have SBCommandInterpreter::SetCommandOverrideCallback()
+        // that can take over a command
+        if (event_type & SBCommandInterpreter::eBroadcastBitQuitCommandReceived)
+        {
+            SetIsDone();
+        }
+        else if (event_type & SBCommandInterpreter::eBroadcastBitAsynchronousErrorData)
+        {
+            const char *data = SBEvent::GetCStringFromEvent (event);
+            m_io_channel_ap->ErrWrite (data, strlen(data), ASYNC);
+        }
+        else if (event_type & SBCommandInterpreter::eBroadcastBitAsynchronousOutputData)
+        {
+            const char *data = SBEvent::GetCStringFromEvent (event);
+            m_io_channel_ap->OutWrite (data, strlen(data), ASYNC);
+        }
+    }
+}
Index: tools/driver/DriverOptions.cpp
===================================================================
--- tools/driver/DriverOptions.cpp	(revision 0)
+++ tools/driver/DriverOptions.cpp	(working copy)
@@ -0,0 +1,664 @@
+//===-- Driver.cpp ----------------------------------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "Driver.h"
+
+#ifdef _WIN32
+#include "lldb/lldb-windows.h"
+#endif
+
+#include "lldb/API/SBHostOS.h"
+using namespace lldb;
+
+typedef struct
+{
+    uint32_t usage_mask;                     // Used to mark options that can be used together.  If (1 << n & usage_mask) != 0
+                                             // then this option belongs to option set n.
+    bool required;                           // This option is required (in the current usage level)
+    const char * long_option;                // Full name for this option.
+    char short_option;                       // Single character for this option.
+    int option_has_arg;                      // no_argument, required_argument or optional_argument
+    uint32_t completion_type;                // Cookie the option class can use to do define the argument completion.
+    lldb::CommandArgumentType argument_type; // Type of argument this option takes
+    const char *  usage_text;                // Full text explaining what this options does and what (if any) argument to
+                                             // pass it.
+} OptionDefinition;
+
+#define LLDB_3_TO_5 LLDB_OPT_SET_3|LLDB_OPT_SET_4|LLDB_OPT_SET_5
+#define LLDB_4_TO_5 LLDB_OPT_SET_4|LLDB_OPT_SET_5
+
+static OptionDefinition g_options[] =
+{
+    { LLDB_OPT_SET_1,    true , "help"           , 'h', no_argument      , NULL,  eArgTypeNone,         
+        "Prints out the usage information for the LLDB debugger." },
+    { LLDB_OPT_SET_2,    true , "version"        , 'v', no_argument      , NULL,  eArgTypeNone,         
+        "Prints out the current version number of the LLDB debugger." },
+    { LLDB_OPT_SET_3,    true , "arch"           , 'a', required_argument, NULL,  eArgTypeArchitecture, 
+        "Tells the debugger to use the specified architecture when starting and running the program.  <architecture> must "
+        "be one of the architectures for which the program was compiled." },
+    { LLDB_OPT_SET_3,    true , "file"           , 'f', required_argument, NULL,  eArgTypeFilename,     
+        "Tells the debugger to use the file <filename> as the program to be debugged." },
+    { LLDB_OPT_SET_4,    true , "attach-name"    , 'n', required_argument, NULL,  eArgTypeProcessName,  
+        "Tells the debugger to attach to a process with the given name." },
+    { LLDB_OPT_SET_4,    true , "wait-for"       , 'w', no_argument      , NULL,  eArgTypeNone,         
+        "Tells the debugger to wait for a process with the given pid or name to launch before attaching." },
+    { LLDB_OPT_SET_5,    true , "attach-pid"     , 'p', required_argument, NULL,  eArgTypePid,          
+        "Tells the debugger to attach to a process with the given pid." },
+    { LLDB_3_TO_5,       false, "script-language", 'l', required_argument, NULL,  eArgTypeScriptLang,   
+        "Tells the debugger to use the specified scripting language for user-defined scripts, rather than the default.  "
+        "Valid scripting languages that can be specified include Python, Perl, Ruby and Tcl.  Currently only the Python "
+        "extensions have been implemented." },
+    { LLDB_3_TO_5,       false, "debug"          , 'd', no_argument      , NULL,  eArgTypeNone,         
+        "Tells the debugger to print out extra information for debugging itself." },
+    { LLDB_3_TO_5,       false, "source"         , 's', required_argument, NULL,  eArgTypeFilename,     
+        "Tells the debugger to read in and execute the file <file>, which should contain lldb commands." },
+    { LLDB_3_TO_5,       false, "editor"         , 'e', no_argument      , NULL,  eArgTypeNone,         
+        "Tells the debugger to open source files using the host's \"external editor\" mechanism." },
+    { LLDB_3_TO_5,       false, "no-lldbinit"    , 'x', no_argument      , NULL,  eArgTypeNone,         
+        "Do not automatically parse any '.lldbinit' files." },
+    { 0,                 false, NULL             , 0  , 0                , NULL,  eArgTypeNone,         NULL }
+};
+
+static const uint32_t last_option_set_with_args = 2;
+
+// This function takes INDENT, which tells how many spaces to output at the front
+// of each line; TEXT, which is the text that is to be output. It outputs the 
+// text, on multiple lines if necessary, to RESULT, with INDENT spaces at the 
+// front of each line.  It breaks lines on spaces, tabs or newlines, shortening 
+// the line if necessary to not break in the middle of a word. It assumes that 
+// each output line should contain a maximum of OUTPUT_MAX_COLUMNS characters.
+
+void
+OutputFormattedUsageText (FILE *out, int indent, const char *text, int output_max_columns)
+{
+    int len = strlen (text);
+    std::string text_string (text);
+
+    // Force indentation to be reasonable.
+    if (indent >= output_max_columns)
+        indent = 0;
+
+    // Will it all fit on one line?
+
+    if (len + indent < output_max_columns)
+        // Output as a single line
+        fprintf (out, "%*s%s\n", indent, "", text);
+    else
+    {
+        // We need to break it up into multiple lines.
+        int text_width = output_max_columns - indent - 1;
+        int start = 0;
+        int end = start;
+        int final_end = len;
+        int sub_len;
+
+        while (end < final_end)
+        {
+              // Dont start the 'text' on a space, since we're already outputting the indentation.
+              while ((start < final_end) && (text[start] == ' '))
+                  start++;
+
+              end = start + text_width;
+              if (end > final_end)
+                  end = final_end;
+              else
+              {
+                  // If we're not at the end of the text, make sure we break the line on white space.
+                  while (end > start
+                         && text[end] != ' ' && text[end] != '\t' && text[end] != '\n')
+                      end--;
+              }
+              sub_len = end - start;
+              std::string substring = text_string.substr (start, sub_len);
+              fprintf (out, "%*s%s\n", indent, "", substring.c_str());
+              start = end + 1;
+        }
+    }
+}
+
+void
+ShowUsage (FILE *out, OptionDefinition *option_table, Driver::OptionData data)
+{
+    uint32_t screen_width = 80;
+    uint32_t indent_level = 0;
+    const char *name = "lldb";
+    
+    fprintf (out, "\nUsage:\n\n");
+
+    indent_level += 2;
+
+
+    // First, show each usage level set of options, e.g. <cmd> [options-for-level-0]
+    //                                                   <cmd> [options-for-level-1]
+    //                                                   etc.
+
+    uint32_t num_options;
+    uint32_t num_option_sets = 0;
+    
+    for (num_options = 0; option_table[num_options].long_option != NULL; ++num_options)
+    {
+        uint32_t this_usage_mask = option_table[num_options].usage_mask;
+        if (this_usage_mask == LLDB_OPT_SET_ALL)
+        {
+            if (num_option_sets == 0)
+                num_option_sets = 1;
+        }
+        else
+        {
+            for (uint32_t j = 0; j < LLDB_MAX_NUM_OPTION_SETS; j++)
+            {
+                if (this_usage_mask & 1 << j)
+                {
+                    if (num_option_sets <= j)
+                        num_option_sets = j + 1;
+                }
+            }
+        }
+    }
+
+    for (uint32_t opt_set = 0; opt_set < num_option_sets; opt_set++)
+    {
+        uint32_t opt_set_mask;
+        
+        opt_set_mask = 1 << opt_set;
+        
+        if (opt_set > 0)
+            fprintf (out, "\n");
+        fprintf (out, "%*s%s", indent_level, "", name);
+        bool is_help_line = false;
+        
+        for (uint32_t i = 0; i < num_options; ++i)
+        {
+            if (option_table[i].usage_mask & opt_set_mask)
+            {
+                CommandArgumentType arg_type = option_table[i].argument_type;
+                const char *arg_name = SBCommandInterpreter::GetArgumentTypeAsCString (arg_type);
+                // This is a bit of a hack, but there's no way to say certain options don't have arguments yet...
+                // so we do it by hand here.
+                if (option_table[i].short_option == 'h')
+                    is_help_line = true;
+                    
+                if (option_table[i].required)
+                {
+                    if (option_table[i].option_has_arg == required_argument)
+                        fprintf (out, " -%c <%s>", option_table[i].short_option, arg_name);
+                    else if (option_table[i].option_has_arg == optional_argument)
+                        fprintf (out, " -%c [<%s>]", option_table[i].short_option, arg_name);
+                    else
+                        fprintf (out, " -%c", option_table[i].short_option);
+                }
+                else
+                {
+                    if (option_table[i].option_has_arg == required_argument)
+                        fprintf (out, " [-%c <%s>]", option_table[i].short_option, arg_name);
+                    else if (option_table[i].option_has_arg == optional_argument)
+                        fprintf (out, " [-%c [<%s>]]", option_table[i].short_option, arg_name);
+                    else
+                        fprintf (out, " [-%c]", option_table[i].short_option);
+                }
+            }
+        }
+        if (!is_help_line && (opt_set <= last_option_set_with_args))
+            fprintf (out, " [[--] <PROGRAM-ARG-1> [<PROGRAM_ARG-2> ...]]");
+    }
+
+    fprintf (out, "\n\n");
+
+    // Now print out all the detailed information about the various options:  long form, short form and help text:
+    //   -- long_name <argument>
+    //   - short <argument>
+    //   help text
+
+    // This variable is used to keep track of which options' info we've printed out, because some options can be in
+    // more than one usage level, but we only want to print the long form of its information once.
+
+    Driver::OptionData::OptionSet options_seen;
+    Driver::OptionData::OptionSet::iterator pos;
+
+    indent_level += 5;
+
+    for (uint32_t i = 0; i < num_options; ++i)
+    {
+        // Only print this option if we haven't already seen it.
+        pos = options_seen.find (option_table[i].short_option);
+        if (pos == options_seen.end())
+        {
+            CommandArgumentType arg_type = option_table[i].argument_type;
+            const char *arg_name = SBCommandInterpreter::GetArgumentTypeAsCString (arg_type);
+
+            options_seen.insert (option_table[i].short_option);
+            fprintf (out, "%*s-%c ", indent_level, "", option_table[i].short_option);
+            if (arg_type != eArgTypeNone)
+                fprintf (out, "<%s>", arg_name);
+            fprintf (out, "\n");
+            fprintf (out, "%*s--%s ", indent_level, "", option_table[i].long_option);
+            if (arg_type != eArgTypeNone)
+                fprintf (out, "<%s>", arg_name);
+            fprintf (out, "\n");
+            indent_level += 5;
+            OutputFormattedUsageText (out, indent_level, option_table[i].usage_text, screen_width);
+            indent_level -= 5;
+            fprintf (out, "\n");
+        }
+    }
+
+    indent_level -= 5;
+
+    fprintf (out, "\n%*s(If you don't provide -f then the first argument will be the file to be debugged"
+                  "\n%*s so '%s -- <filename> [<ARG1> [<ARG2>]]' also works."
+                  "\n%*s Remember to end the options with \"--\" if any of your arguments have a \"-\" in them.)\n\n",
+             indent_level, "", 
+             indent_level, "",
+             name, 
+             indent_level, "");
+}
+
+void
+BuildGetOptTable (OptionDefinition *expanded_option_table, std::vector<struct option> &getopt_table, 
+                  uint32_t num_options)
+{
+    if (num_options == 0)
+        return;
+
+    uint32_t i;
+    uint32_t j;
+    std::bitset<256> option_seen;
+
+    getopt_table.resize (num_options + 1);
+
+    for (i = 0, j = 0; i < num_options; ++i)
+    {
+        char short_opt = expanded_option_table[i].short_option;
+        
+        if (option_seen.test(short_opt) == false)
+        {
+            getopt_table[j].name    = expanded_option_table[i].long_option;
+            getopt_table[j].has_arg = expanded_option_table[i].option_has_arg;
+            getopt_table[j].flag    = NULL;
+            getopt_table[j].val     = expanded_option_table[i].short_option;
+            option_seen.set(short_opt);
+            ++j;
+        }
+    }
+
+    getopt_table[j].name    = NULL;
+    getopt_table[j].has_arg = 0;
+    getopt_table[j].flag    = NULL;
+    getopt_table[j].val     = 0;
+
+}
+
+Driver::OptionData::OptionData () :
+    m_args(),
+    m_script_lang (lldb::eScriptLanguageDefault),
+    m_crash_log (),
+    m_source_command_files (),
+    m_debug_mode (false),
+    m_print_version (false),
+    m_print_help (false),
+    m_wait_for(false),
+    m_process_name(),
+    m_process_pid(LLDB_INVALID_PROCESS_ID),
+    m_use_external_editor(false),
+    m_seen_options()
+{
+}
+
+Driver::OptionData::~OptionData ()
+{
+}
+
+void
+Driver::OptionData::Clear ()
+{
+    m_args.clear ();
+    m_script_lang = lldb::eScriptLanguageDefault;
+    m_source_command_files.clear ();
+    m_debug_mode = false;
+    m_print_help = false;
+    m_print_version = false;
+    m_use_external_editor = false;
+    m_wait_for = false;
+    m_process_name.erase();
+    m_process_pid = LLDB_INVALID_PROCESS_ID;
+}
+
+void
+Driver::ResetOptionValues ()
+{
+    m_option_data.Clear ();
+}
+
+// Check the arguments that were passed to this program to make sure they are valid and to get their
+// argument values (if any).  Return a boolean value indicating whether or not to start up the full
+// debugger (i.e. the Command Interpreter) or not.  Return FALSE if the arguments were invalid OR
+// if the user only wanted help or version information.
+
+SBError
+Driver::ParseArgs (int argc, const char *argv[], FILE *out_fh, bool &exit)
+{
+    ResetOptionValues ();
+
+    SBCommandReturnObject result;
+
+    SBError error;
+    std::string option_string;
+    struct option *long_options = NULL;
+    std::vector<struct option> long_options_vector;
+    uint32_t num_options;
+
+    for (num_options = 0; g_options[num_options].long_option != NULL; ++num_options)
+        /* Do Nothing. */;
+
+    if (num_options == 0)
+    {
+        if (argc > 1)
+            error.SetErrorStringWithFormat ("invalid number of options");
+        return error;
+    }
+
+    BuildGetOptTable (g_options, long_options_vector, num_options);
+
+    if (long_options_vector.empty())
+        long_options = NULL;
+    else
+        long_options = &long_options_vector.front();
+
+    if (long_options == NULL)
+    {
+        error.SetErrorStringWithFormat ("invalid long options");
+        return error;
+    }
+
+    // Build the option_string argument for call to getopt_long.
+
+    for (int i = 0; long_options[i].name != NULL; ++i)
+    {
+        if (long_options[i].flag == NULL)
+        {
+            option_string.push_back ((char) long_options[i].val);
+            switch (long_options[i].has_arg)
+            {
+                default:
+                case no_argument:
+                    break;
+                case required_argument:
+                    option_string.push_back (':');
+                    break;
+                case optional_argument:
+                    option_string.append ("::");
+                    break;
+            }
+        }
+    }
+
+    // This is kind of a pain, but since we make the debugger in the Driver's constructor, we can't
+    // know at that point whether we should read in init files yet.  So we don't read them in in the
+    // Driver constructor, then set the flags back to "read them in" here, and then if we see the
+    // "-n" flag, we'll turn it off again.  Finally we have to read them in by hand later in the
+    // main loop.
+    
+    m_debugger.SkipLLDBInitFiles (false);
+    m_debugger.SkipAppInitFiles (false);
+
+    // Prepare for & make calls to getopt_long.
+#if __GLIBC__
+    optind = 0;
+#else
+    optreset = 1;
+    optind = 1;
+#endif
+    int val;
+    while (1)
+    {
+        int long_options_index = -1;
+        val = ::getopt_long (argc, const_cast<char **>(argv), option_string.c_str(), long_options, &long_options_index);
+
+        if (val == -1)
+            break;
+        else if (val == '?')
+        {
+            m_option_data.m_print_help = true;
+            error.SetErrorStringWithFormat ("unknown or ambiguous option");
+            break;
+        }
+        else if (val == 0)
+            continue;
+        else
+        {
+            m_option_data.m_seen_options.insert ((char) val);
+            if (long_options_index == -1)
+            {
+                for (int i = 0;
+                     long_options[i].name || long_options[i].has_arg || long_options[i].flag || long_options[i].val;
+                     ++i)
+                {
+                    if (long_options[i].val == val)
+                    {
+                        long_options_index = i;
+                        break;
+                    }
+                }
+            }
+
+            if (long_options_index >= 0)
+            {
+                const char short_option = (char) g_options[long_options_index].short_option;
+
+                switch (short_option)
+                {
+                    case 'h':
+                        m_option_data.m_print_help = true;
+                        break;
+
+                    case 'v':
+                        m_option_data.m_print_version = true;
+                        break;
+
+                    case 'c':
+                        m_option_data.m_crash_log = optarg;
+                        break;
+
+                    case 'e':
+                        m_option_data.m_use_external_editor = true;
+                        break;
+
+                    case 'x':
+                        m_debugger.SkipLLDBInitFiles (true);
+                        m_debugger.SkipAppInitFiles (true);
+                        break;
+
+                    case 'f':
+                        {
+                            SBFileSpec file(optarg);
+                            if (file.Exists())
+                            {
+                                m_option_data.m_args.push_back (optarg);
+                            }
+                            else if (file.ResolveExecutableLocation())
+                            {
+                                char path[PATH_MAX];
+                                file.GetPath (path, sizeof(path));
+                                m_option_data.m_args.push_back (path);
+                            }
+                            else
+                                error.SetErrorStringWithFormat("file specified in --file (-f) option doesn't exist: '%s'", optarg);
+                        }
+                        break;
+
+                    case 'a':
+                        if (!m_debugger.SetDefaultArchitecture (optarg))
+                            error.SetErrorStringWithFormat("invalid architecture in the -a or --arch option: '%s'", optarg);
+                        break;
+
+                    case 'l':
+                        m_option_data.m_script_lang = m_debugger.GetScriptingLanguage (optarg);
+                        break;
+
+                    case 'd':
+                        m_option_data.m_debug_mode = true;
+                        break;
+
+                    case 'n':
+                        m_option_data.m_process_name = optarg;
+                        break;
+                    
+                    case 'w':
+                        m_option_data.m_wait_for = true;
+                        break;
+                        
+                    case 'p':
+                        {
+                            char *remainder;
+                            m_option_data.m_process_pid = strtol (optarg, &remainder, 0);
+                            if (remainder == optarg || *remainder != '\0')
+                                error.SetErrorStringWithFormat ("Could not convert process PID: \"%s\" into a pid.",
+                                                                optarg);
+                        }
+                        break;
+                    case 's':
+                        {
+                            SBFileSpec file(optarg);
+                            if (file.Exists())
+                                m_option_data.m_source_command_files.push_back (optarg);
+                            else if (file.ResolveExecutableLocation())
+                            {
+                                char final_path[PATH_MAX];
+                                file.GetPath (final_path, sizeof(final_path));
+                                std::string path_str (final_path);
+                                m_option_data.m_source_command_files.push_back (path_str);
+                            }
+                            else
+                                error.SetErrorStringWithFormat("file specified in --source (-s) option doesn't exist: '%s'", optarg);
+                        }
+                        break;
+
+                    default:
+                        m_option_data.m_print_help = true;
+                        error.SetErrorStringWithFormat ("unrecognized option %c", short_option);
+                        break;
+                }
+            }
+            else
+            {
+                error.SetErrorStringWithFormat ("invalid option with value %i", val);
+            }
+            if (error.Fail())
+            {
+                return error;
+            }
+        }
+    }
+    
+    if (error.Fail() || m_option_data.m_print_help)
+    {
+        ShowUsage (out_fh, g_options, m_option_data);
+        exit = true;
+    }
+    else if (m_option_data.m_print_version)
+    {
+        ::fprintf (out_fh, "%s\n", m_debugger.GetVersionString());
+        exit = true;
+    }
+    else if (! m_option_data.m_crash_log.empty())
+    {
+        // Handle crash log stuff here.
+    }
+    else if (m_option_data.m_process_name.empty() && m_option_data.m_process_pid == LLDB_INVALID_PROCESS_ID)
+    {
+        // Any arguments that are left over after option parsing are for
+        // the program. If a file was specified with -f then the filename
+        // is already in the m_option_data.m_args array, and any remaining args
+        // are arguments for the inferior program. If no file was specified with
+        // -f, then what is left is the program name followed by any arguments.
+
+        // Skip any options we consumed with getopt_long
+        argc -= optind;
+        argv += optind;
+
+        if (argc > 0)
+        {
+            for (int arg_idx=0; arg_idx<argc; ++arg_idx)
+            {
+                const char *arg = argv[arg_idx];
+                if (arg)
+                    m_option_data.m_args.push_back (arg);
+            }
+        }
+        
+    }
+    else
+    {
+        // Skip any options we consumed with getopt_long
+        argc -= optind;
+        //argv += optind; // Commented out to keep static analyzer happy
+
+        if (argc > 0)
+            ::fprintf (out_fh, "Warning: program arguments are ignored when attaching.\n");
+    }
+
+    return error;
+}
+
+void
+Driver::HandleCommandLine(SBCommandReturnObject& result)
+{
+    // Now we handle options we got from the command line
+    char command_string[PATH_MAX * 2];
+    const size_t num_source_command_files = GetNumSourceCommandFiles();
+    if (num_source_command_files > 0)
+    {
+        for (size_t i=0; i < num_source_command_files; ++i)
+        {
+            const char *command_file = GetSourceCommandFileAtIndex(i);
+            ::snprintf (command_string, sizeof(command_string), "command source '%s'", command_file);
+            m_debugger.GetCommandInterpreter().HandleCommand (command_string, result, false);
+            if (GetDebugMode())
+            {
+                result.PutError (m_debugger.GetErrorFileHandle());
+                result.PutOutput (m_debugger.GetOutputFileHandle());
+            }
+        }
+    }
+
+    const size_t num_args = m_option_data.m_args.size();
+    
+    if (!num_args)
+        return;
+
+    char arch_name[64];
+    if (m_debugger.GetDefaultArchitecture (arch_name, sizeof (arch_name)))
+        ::snprintf (command_string, 
+                    sizeof (command_string), 
+                    "target create --arch=%s \"%s\"", 
+                    arch_name,
+                    m_option_data.m_args[0].c_str());
+    else
+        ::snprintf (command_string, 
+                    sizeof(command_string), 
+                    "target create \"%s\"", 
+                    m_option_data.m_args[0].c_str());
+
+    m_debugger.HandleCommand (command_string);
+                
+    if (num_args > 1)
+    {
+        m_debugger.HandleCommand ("settings clear target.run-args");
+        char arg_cstr[1024];
+        for (size_t arg_idx = 1; arg_idx < num_args; ++arg_idx)
+        {
+            ::snprintf (arg_cstr, 
+                        sizeof(arg_cstr), 
+                        "settings append target.run-args \"%s\"", 
+                        m_option_data.m_args[arg_idx].c_str());
+            m_debugger.HandleCommand (arg_cstr);
+        }
+    }
+}
+
Index: tools/driver/DriverPosix.cpp
===================================================================
--- tools/driver/DriverPosix.cpp	(revision 0)
+++ tools/driver/DriverPosix.cpp	(working copy)
@@ -0,0 +1,257 @@
+//===-- Driver.cpp ----------------------------------------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "Driver.h"
+
+#ifdef _POSIX_SOURCE
+#include <getopt.h>
+#include <libgen.h>
+#include <sys/ioctl.h>
+#include <termios.h>
+#include <unistd.h>
+#endif
+
+#ifdef __unix__
+static void reset_stdin_termios ();
+static bool g_old_stdin_termios_is_valid = false;
+static struct termios g_old_stdin_termios;
+#endif
+
+// In the Driver::MainLoop, we change the terminal settings.  This function is
+// added as an atexit handler to make sure we clean them up.
+static void
+reset_stdin_termios ()
+{
+#ifdef _POSIX_SOURCE
+    if (g_old_stdin_termios_is_valid)
+    {
+        g_old_stdin_termios_is_valid = false;
+        ::tcsetattr (STDIN_FILENO, TCSANOW, &g_old_stdin_termios);
+    }
+#endif
+}
+
+void
+Driver::InitializePseudoTerminal()
+{
+#ifndef _WIN32
+    char error_str[1024];
+    if (m_editline_pty.OpenFirstAvailableMaster(O_RDWR|O_NOCTTY, error_str, sizeof(error_str)) == false)
+    {
+        ::fprintf (stderr, "error: failed to open driver pseudo terminal : %s", error_str);
+        exit(1);
+    }
+    else
+    {
+        const char *driver_slave_name = m_editline_pty.GetSlaveName (error_str, sizeof(error_str));
+        if (driver_slave_name == NULL)
+        {
+            ::fprintf (stderr, "error: failed to get slave name for driver pseudo terminal : %s", error_str);
+            exit(2);
+        }
+        else
+        {
+            m_editline_slave_fh = ::fopen (driver_slave_name, "r+");
+            if (m_editline_slave_fh == NULL)
+            {
+                SBError error;
+                error.SetErrorToErrno();
+                ::fprintf (stderr, "error: failed to get open slave for driver pseudo terminal : %s",
+                           error.GetCString());
+                exit(3);
+            }
+
+            ::setbuf (m_editline_slave_fh, NULL);
+        }
+    }
+
+    lldb_utility::PseudoTerminal editline_output_pty;
+    FILE *editline_output_slave_fh = NULL;
+    
+    if (editline_output_pty.OpenFirstAvailableMaster (O_RDWR|O_NOCTTY, error_str, sizeof (error_str)) == false)
+    {
+        ::fprintf (stderr, "error: failed to open output pseudo terminal : %s", error_str);
+        exit(1);
+    }
+    else
+    {
+        const char *output_slave_name = editline_output_pty.GetSlaveName (error_str, sizeof(error_str));
+        if (output_slave_name == NULL)
+        {
+            ::fprintf (stderr, "error: failed to get slave name for output pseudo terminal : %s", error_str);
+            exit(2);
+        }
+        else
+        {
+            editline_output_slave_fh = ::fopen (output_slave_name, "r+");
+            if (editline_output_slave_fh == NULL)
+            {
+                SBError error;
+                error.SetErrorToErrno();
+                ::fprintf (stderr, "error: failed to get open slave for output pseudo terminal : %s",
+                           error.GetCString());
+                exit(3);
+            }
+            ::setbuf (editline_output_slave_fh, NULL);
+        }
+    }
+  
+     struct termios stdin_termios;
+
+    if (::tcgetattr(STDIN_FILENO, &g_old_stdin_termios) == 0)
+    {
+        g_old_stdin_termios_is_valid = true;
+        atexit (reset_stdin_termios);
+    }
+
+    ::setbuf (stdin, NULL);
+    ::setbuf (stdout, NULL);
+#endif
+}
+
+void
+Driver::InitializeEditLineIO()
+{
+#ifndef _WIN32
+    // You have to drain anything that comes to the master side of the PTY.  master_out_comm is
+    // for that purpose.  The reason you need to do this is a curious reason...  editline will echo
+    // characters to the PTY when it gets characters while el_gets is not running, and then when
+    // you call el_gets (or el_getc) it will try to reset the terminal back to raw mode which blocks
+    // if there are unconsumed characters in the out buffer.
+    // However, you don't need to do anything with the characters, since editline will dump these
+    // unconsumed characters after printing the prompt again in el_gets.
+
+    SBCommunication master_out_comm("driver.editline");
+    master_out_comm.SetCloseOnEOF (false);
+    master_out_comm.AdoptFileDesriptor(m_editline_pty.GetMasterFileDescriptor(), false);
+    master_out_comm.SetReadThreadBytesReceivedCallback(Driver::MasterThreadBytesReceived, this);
+
+    if (master_out_comm.ReadThreadStart () == false)
+    {
+        ::fprintf (stderr, "error: failed to start master out read thread");
+        exit(5);
+    }
+
+    m_io_channel_ap.reset (new IOChannel(m_editline_slave_fh, editline_output_slave_fh, stdout, stderr, this));
+
+    SBCommunication out_comm_2("driver.editline_output");
+    out_comm_2.SetCloseOnEOF (false);
+    out_comm_2.AdoptFileDesriptor (editline_output_pty.GetMasterFileDescriptor(), false);
+    out_comm_2.SetReadThreadBytesReceivedCallback (IOChannel::LibeditOutputBytesReceived, m_io_channel_ap.get());
+
+    if (out_comm_2.ReadThreadStart () == false)
+    {
+        ::fprintf (stderr, "error: failed to start libedit output read thread");
+        exit (5);
+    }
+
+    struct winsize window_size;
+    if (isatty (STDIN_FILENO)
+        && ::ioctl (STDIN_FILENO, TIOCGWINSZ, &window_size) == 0)
+    {
+        if (window_size.ws_col > 0)
+            m_debugger.SetTerminalWidth (window_size.ws_col);
+    }
+
+    // Since input can be redirected by the debugger, we must insert our editline
+    // input reader in the queue so we know when our reader should be active
+    // and so we can receive bytes only when we are supposed to.
+    SBError err (m_editline_reader.Initialize (m_debugger, 
+                                               Driver::EditLineInputReaderCallback, // callback
+                                               this,                              // baton
+                                               eInputReaderGranularityByte,       // token_size
+                                               NULL,                              // end token - NULL means never done
+                                               NULL,                              // prompt - taken care of elsewhere
+                                               false));                           // echo input - don't need Debugger 
+                                                                                  // to do this, we handle it elsewhere
+    
+    if (err.Fail())
+    {
+        ::fprintf (stderr, "error: %s", err.GetCString());
+        exit (6);
+    }
+    
+    m_debugger.PushInputReader (m_editline_reader);
+#endif
+}
+
+void
+Driver::DestroyPseudoTerminal()
+{
+#ifndef _WIN32
+    editline_output_pty.CloseMasterFileDescriptor();
+    master_out_comm.Disconnect();
+    out_comm_2.Disconnect();
+    reset_stdin_termios();
+    fclose (stdin);
+#endif
+}
+
+void
+Driver::CloseIOChannelFile ()
+{
+#ifdef __unix__
+    // Write an End of File sequence to the file descriptor to ensure any
+    // read functions can exit.
+    char eof_str[] = "\x04";
+    ::write (m_editline_pty.GetMasterFileDescriptor(), eof_str, strlen(eof_str));
+
+    m_editline_pty.CloseMasterFileDescriptor();
+
+    if (m_editline_slave_fh)
+    {
+        ::fclose (m_editline_slave_fh);
+        m_editline_slave_fh = NULL;
+    }
+#endif
+}
+
+#ifdef __unix__
+void
+sigwinch_handler (int signo)
+{
+    struct winsize window_size;
+    if (isatty (STDIN_FILENO)
+        && ::ioctl (STDIN_FILENO, TIOCGWINSZ, &window_size) == 0)
+    {
+        if ((window_size.ws_col > 0) && g_driver != NULL)
+        {
+            g_driver->GetDebugger().SetTerminalWidth (window_size.ws_col);
+        }
+    }
+}
+
+void
+sigint_handler (int signo)
+{
+    static bool g_interrupt_sent = false;
+    if (g_driver)
+    {
+        if (!g_interrupt_sent)
+        {
+            g_interrupt_sent = true;
+            g_driver->GetDebugger().DispatchInputInterrupt();
+            g_interrupt_sent = false;
+            return;
+        }
+    }
+    
+    exit (signo);
+}
+#endif
+
+void
+SetupPosixSignals()
+{
+#ifdef __unix__
+    signal (SIGPIPE, SIG_IGN);
+    signal (SIGWINCH, sigwinch_handler);
+    signal (SIGINT, sigint_handler);
+#endif
+}
Index: tools/driver/IOChannel.cpp
===================================================================
--- tools/driver/IOChannel.cpp	(revision 163322)
+++ tools/driver/IOChannel.cpp	(working copy)
@@ -23,6 +23,17 @@
 #include <string.h>
 #include <limits.h>
 
+#ifdef _WIN32
+enum
+{
+  CC_ERROR,
+  CC_REDISPLAY,
+  CC_REFRESH_BEEP,
+};
+#endif
+
+
+
 using namespace lldb;
 
 typedef std::map<EditLine *, std::string> PromptMap;
@@ -53,6 +64,7 @@
 bool
 IOChannel::EditLineHasCharacters ()
 {
+#ifdef __unix__
     const LineInfo *line_info  = el_line(m_edit_line);
     if (line_info)
     {
@@ -65,26 +77,31 @@
             return line_info->cursor != line_info->buffer;
     }
     else
-        return false;
+#endif	
+		return false;
 }
 
 
 void
 IOChannel::EraseCharsBeforeCursor ()
 {
+#ifdef __unix__
     const LineInfo *line_info  = el_line(m_edit_line);
     el_deletestr(m_edit_line, line_info->cursor - line_info->buffer);
+#endif	
 }
 
 unsigned char
 IOChannel::ElCompletionFn (EditLine *e, int ch)
 {
+#ifdef __unix__
     IOChannel *io_channel;
     if (el_get(e, EL_CLIENTDATA, &io_channel) == 0)
     {
         return io_channel->HandleCompletion (e, ch);
     }
     else
+#endif	
     {
         return CC_ERROR;
     }
@@ -94,7 +111,7 @@
 IOChannel::HandleCompletion (EditLine *e, int ch)
 {
     assert (e == m_edit_line);
-
+#ifdef __unix__
     const LineInfo *line_info  = el_line(m_edit_line);
     SBStringList completions;
     int page_size = 40;
@@ -180,7 +197,8 @@
     if (num_completions == 0)
         return CC_REFRESH_BEEP;
     else
-        return CC_REDISPLAY;
+#endif
+		return CC_REDISPLAY;
 }
 
 IOChannel::IOChannel
@@ -201,14 +219,17 @@
     m_err_file (err),
     m_command_queue (),
     m_completion_key ("\t"),
+#ifdef __unix__
     m_edit_line (::el_init (SBHostOS::GetProgramFileSpec().GetFilename(), editline_in, editline_out,  editline_out)),
     m_history (history_init()),
+#endif	
     m_history_event(),
     m_getting_command (false),
     m_expecting_prompt (false),
 	m_prompt_str (),
     m_refresh_request_pending (false)
 {
+#ifdef __unix__
     assert (m_edit_line);
     ::el_set (m_edit_line, EL_PROMPT, el_prompt);
     ::el_set (m_edit_line, EL_EDITOR, "emacs");
@@ -247,7 +268,7 @@
     assert (error == 0);
 
     // Initialize time that ::el_gets was last called.
-
+#endif
     m_enter_elgets_time.tv_sec = 0;
     m_enter_elgets_time.tv_usec = 0;
 }
@@ -257,6 +278,7 @@
     // Save history
     HistorySaveLoad (true);
 
+#ifdef __unix__
     if (m_history != NULL)
     {
         ::history_end (m_history);
@@ -270,6 +292,7 @@
     }
 
     ::pthread_mutex_destroy (&m_output_mutex);
+#endif
 }
 
 void
@@ -277,6 +300,7 @@
 {
     if (m_history != NULL)
     {
+#ifdef __unix__
         char history_path[PATH_MAX];
         ::snprintf (history_path, sizeof(history_path), "~/.%s-history", SBHostOS::GetProgramFileSpec().GetFilename());
         if ((size_t)SBFileSpec::ResolvePath (history_path, history_path, sizeof(history_path)) < sizeof(history_path) - 1)
@@ -287,7 +311,8 @@
             else
                 ::history (m_history, &m_history_event, H_LOAD, path_ptr);
         }
-    }
+#endif
+	}
 }
 
 void
@@ -326,7 +351,8 @@
 bool
 IOChannel::LibeditGetInput (std::string &new_line)
 {
-    if (m_edit_line != NULL)
+ #ifdef __unix__
+	if (m_edit_line != NULL)
     {
         int line_len = 0;
 
@@ -360,13 +386,15 @@
             return true;
         }
     }
+#endif
     // Return false to indicate failure. This can happen when the file handle
     // is closed (EOF).
     new_line.clear();
     return false;
+	
 }
 
-void *
+thread_result_t 
 IOChannel::IOReadThread (void *ptr)
 {
     IOChannel *myself = static_cast<IOChannel *> (ptr);
@@ -520,8 +548,9 @@
 
     if (m_refresh_request_pending)
         return;
-
+#ifdef __unix__
     ::el_set (m_edit_line, EL_REFRESH);
+#endif	
     m_refresh_request_pending = true;    
 }
 
@@ -611,16 +640,14 @@
     m_getting_command = new_value;
 }
 
-IOLocker::IOLocker (pthread_mutex_t &mutex) :
+IOLocker::IOLocker (llvm::sys::Mutex &mutex) :
     m_mutex_ptr (&mutex)
 {
-    if (m_mutex_ptr)
-        ::pthread_mutex_lock (m_mutex_ptr);
+    mutex.acquire();		
         
 }
 
 IOLocker::~IOLocker ()
 {
-    if (m_mutex_ptr)
-        ::pthread_mutex_unlock (m_mutex_ptr);
+    m_mutex_ptr->release();
 }
Index: tools/driver/IOChannel.h
===================================================================
--- tools/driver/IOChannel.h	(revision 163322)
+++ tools/driver/IOChannel.h	(working copy)
@@ -16,11 +16,28 @@
 #if defined(__FreeBSD__)
 #include <readline/readline.h>
 #else
+#ifndef _WIN32
 #include <editline/readline.h>
 #endif
+#endif
+
+#ifndef _WIN32
 #include <histedit.h>
+#else
+struct EditLine;
+struct History;
+struct HistEvent {};
+#include <Winsock2.h>
+#endif
+
+#include "llvm/Support/Mutex.h"
+
+#ifdef _POSIX_SOURCE
 #include <pthread.h>
 #include <sys/time.h>
+#else
+#include <ctime>
+#endif
 
 #include "Driver.h"
 
@@ -54,7 +71,7 @@
     bool
     Stop ();
 
-    static void *
+    static lldb::thread_result_t
     IOReadThread (void *);
 
     void
@@ -115,7 +132,7 @@
 
 private:
 
-    pthread_mutex_t m_output_mutex;
+    llvm::sys::Mutex m_output_mutex;
     struct timeval m_enter_elgets_time;
 
     Driver *m_driver;
@@ -131,7 +148,7 @@
     HistEvent m_history_event;
     bool m_getting_command;
     bool m_expecting_prompt;
-	std::string m_prompt_str;  // for accumlating the prompt as it gets written out by editline
+    std::string m_prompt_str;  // for accumlating the prompt as it gets written out by editline
     bool m_refresh_request_pending;
 
     void
@@ -145,13 +162,13 @@
 {
 public:
 
-    IOLocker (pthread_mutex_t &mutex);
+    IOLocker (llvm::sys::Mutex &mutex);
 
     ~IOLocker ();
 
 protected:
 
-    pthread_mutex_t *m_mutex_ptr;
+    llvm::sys::Mutex *m_mutex_ptr;
 
 private:
 
