<?xml version="1.0" encoding="UTF-8"?>
<!--=========================================================================-->
<!-- Copyright (C) 2006 Reid Spencer. All Rights Reserved.                   -->
<!--                                                                         -->
<!-- This software is free software; you can redistribute it and/or modify it-->
<!-- under the terms of the GNU Lesser General Public License as published by-->
<!-- the Free Software Foundation; either version 2.1 of the License, or (at -->
<!-- your option) any later version.                                         -->
<!--                                                                         -->
<!-- This software is distributed in the hope that it will be useful, but    -->
<!-- WITHOUT ANY WARRANTY; without even the implied warranty of              -->
<!-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser-->
<!-- General Public License for more details.                                -->
<!--                                                                         -->
<!-- You should have received a copy of the GNU Lesser General Public License-->
<!-- along with this library in the file named LICENSE.txt; if not, write to -->
<!-- the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,    -->
<!-- Boston, MA 02110-1301 USA                                               -->
<!--                                                                         -->
<!--=========================================================================-->
<!-- @file hlvm/Reader/XML/HLVM.rng                                          -->
<!-- @author Reid Spencer <rspencer@reidspencer.com> (original author)       -->
<!-- @date 2006/05/13                                                        -->
<!-- @since 0.1.0                                                            -->
<!-- @brief Defines the core XPL language via Relax/NG Schema                -->
<!--=========================================================================-->
<!-- HLVM AST Schema                                                         -->
<!--                                                                         -->
<!-- This file contains the Relax/NG schema for construction of the HLVM AST -->
<!-- via an XML syntax. The schema aims to be simple and closely match the   -->
<!-- construction of an HLVM AST.                                            -->
<!--                                                                         -->
<!-- For full commentary on this schema, see http://hlvm.org/docs/XML.html   -->
<!--                                                                         -->
<!--=========================================================================-->

<grammar 
  datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
  xmlns ="http://relaxng.org/ns/structure/1.0"
  xmlns:a="http://relaxng.org/ns/annotation/1.0"
  ns="http://hlvm.org/src/hlvm/Reader/XML/HLVMAST.rng">

  <start>
    <ref name="bundle.elem"/>
  </start>

  <!-- PATTERN DEFINITIONS FOR DATA TYPES -->

  <define name="Identifier.type">
    <choice>
      <ref name="Unprefixed_Identifier.type"/>
      <ref name="Prefixed_Identifier.type"/>
    </choice>
  </define>

  <define name="Unprefixed_Identifier.type">
    <data type="string">
      <param name="pattern">[^:]+</param>
      <param name="maxLength">1024</param>
    </data>
  </define>

  <define name="Prefixed_Identifier.type">
    <data type="string">
      <param name="pattern">[^:]+:[^:]+</param>
      <param name="maxLength">1024</param>
    </data>
  </define>

  <define name="Boolean.type">
    <choice>
      <data type="boolean"/>
      <value>TRUE</value>
      <value>True</value>
      <value>yes</value>
      <value>Yes</value>
      <value>YES</value>
      <value>1</value>
      <value>FALSE</value>
      <value>False</value>
      <value>no</value>
      <value>No</value>
      <value>NO</value>
      <value>0</value>
    </choice>
  </define>

  <!-- DOCUMENTATION OF HLVM AST PROGRAMS -->

  <define name="Documentation.pat">
    <optional>
      <element name="doc">
        <zeroOrMore>
          <choice>
            <text/>
            <ref name="Any.pat"/> <!-- should really be XHTML elements -->
          </choice>
        </zeroOrMore>
      </element>
    </optional>
  </define>

  <define name="Any.pat">
    <element>
      <anyName/>
      <zeroOrMore>
        <choice>
          <attribute>
            <anyName/>
          </attribute>
          <text/>
          <ref name="Any.pat"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>

  <!-- PATTERNS THAT DEFINE name AND type ATTRIBUTES -->

  <define name="Named_Element.pat">
    <ref name="Documentation.pat"/>
    <attribute name="name">
      <ref name="Identifier.type"/>
    </attribute>
  </define>

  <define name="Typed_Element.pat">
    <ref name="Documentation.pat"/>
    <attribute name="type">
      <ref name="Identifier.type"/>
    </attribute>
  </define>

  <define name="Named_Typed_Element.pat">
    <ref name="Documentation.pat"/>
    <attribute name="name">
      <ref name="Identifier.type"/>
    </attribute>
    <attribute name="type">
      <ref name="Identifier.type"/>
    </attribute>
  </define>

  <!--BUNDLES PATTERN -->

  <define name="bundle.elem">
    <element name="bundle">
      <ref name="bundle.pat"/>
    </element>
  </define>

  <define name="bundle.pat">
    <attribute name="pubid"><data type="anyURI"/></attribute>
    <ref name="Documentation.pat"/>
    <zeroOrMore>
      <ref name="import.elem"/>
    </zeroOrMore>
    <oneOrMore>
      <interleave>
        <ref name="bundle.elem"/>
        <ref name="class.elem"/>
        <ref name="function.elem"/>
        <ref name="interface.elem"/>
        <ref name="program.elem"/>
        <ref name="signature.elem"/>
        <ref name="type.elem"/>
        <ref name="variable.elem"/>
      </interleave>
    </oneOrMore>
  </define>

  <define name="import.elem">
    <element name="import">
      <ref name="Documentation.pat"/>
      <attribute name="prefix">
        <ref name="Identifier.type"/>
      </attribute>
      <attribute name="pubid">
        <data type="anyURI"/>
      </attribute>
    </element>
  </define>

  <!--PATTERNS FOR DEFINING TYPES -->

  <define name="Type.pat">
    <choice>
      <ref name="Alias.elem"/>
      <ref name="Atom.elem"/>
      <ref name="Enumeration.elem"/>
      <ref name="Pointer.elem"/>
      <ref name="Array.elem"/>
      <ref name="Vector.elem"/>
      <ref name="Structure.elem"/>
      <ref name="Signature.elem"/>
      <ref name="Opaque.elem"/>
    </choice>
  </define>

  <define name="Alias.elem">
    <element name="Alias">
      <ref name="Named_Element.pat"/>
      <attribute name="renames"><ref name="Identifier.type"/></attribute>
    </element>
    <ref name="Alias.ext"/>
  </define>

  <define name="Alias.ext" combine="choice"><empty/></define>

  <define name="Atom.elem">
    <element name="Atom">
      <ref name="Named_Element.pat"/>
      <attribute name="is">
        <ref name="Intrinsic_Atoms.type"/>
      </attribute>
      <ref name="Atom.ext"/>
    </element>
  </define>

  <define name="Intrinsic_Atoms.type">
    <choice>
      <value>bool</value>
      <value>char</value>
      <value>f32</value>
      <value>f64</value>
      <value>i8</value>
      <value>i16</value>
      <value>i32</value>
      <value>i64</value>
      <value>u8</value>
      <value>u16</value>
      <value>u32</value>
      <value>u64</value>
      <value>void</value>
    </choice>
  </define>

  <define name="Atom.ext" combine="choice"><empty/></define>

  <define name="Enumeration.elem">
    <element name="Enum">
      <ref name="Named_Element.pat"/>
      <oneOrMore>
        <element name="value">
          <ref name="Named_Element.pat"/>
          <ref name="Constant.pat"/>
        </element>
      </oneOrMore>
      <ref name="Enumeration.ext"/>
    </element>
  </define>

  <define name="Enumeration.ext" combine="choice"><empty/></define>

  <define name="Pointer.elem">
    <element name="Pointer">
      <ref name="Named_Element.pat"/>
      <attribute name="to"><ref name="Identifier.type"/></attribute>
      <ref name="Pointer.ext"/>
    </element>
  </define>

  <define name="Pointer.ext" combine="choice"><empty/></define>

  <define name="Vector.elem">
    <element name="Vector">
      <ref name="Named_Element.pat"/>
      <attribute name="length"><data type="nonNegativeInteger"/></attribute>
      <attribute name="of">
        <ref name="Intrinsic_Atoms.type"/>
      </attribute>
      <ref name="Vector.ext"/>
    </element>
  </define>

  <define name="Vector.ext" combine="choice"><empty/></define>

  <define name="Array.elem">
    <element name="Array">
      <ref name="Named_Element.pat"/>
      <attribute name="length"><data type="nonNegativeInteger"/></attribute>
      <attribute name="of"><ref name="Identifier.type"/></attribute>
      <ref name="Array.ext"/>
    </element>
  </define>

  <define name="Array.ext" combine="choice"><empty/></define>

  <define name="Structure.elem">
    <element name="structure">
      <ref name="Named_Element.pat"/>
      <zeroOrMore>
        <element name="field">
          <ref name="Named_Typed_Element.pat"/>
        </element>
      </zeroOrMore>
    </element>
  </define>

  <define name="signature.elem">
    <element name="signature">
      <ref name="Named_Element.pat"/>
      <attribute name="result"><ref name="Identifier.type"/></attribute>
      <optional>
        <attribute name="varargs"><ref name="Boolean.type"/></attribute>
      </optional>
      <zeroOrMore>
        <element name="arg">
          <ref name="Named_Typed_Element.pat"/>
        </element>
      </zeroOrMore>
    </element>
  </define>

  <define name="Signature.ext" combine="choice"><empty/></define>

  <define name="Opaque.elem">
    <element name="Opaque">
      <ref name="Named_Element.pat"/>
      <empty/>
    </element>
    <ref name="Opaque.ext"/>
  </define>

  <define name="Opaque.ext" combine="choice"><empty/></define>

  <!--PATTERNS FOR VARIABLES-->

  <define name="Variable.elem">
    <element name="Var">
      <ref name="Named_Typed_Element.pat"/>
      <optional>
        <choice>
          <element name="const">
            <ref name="Constant.pat"/>
          </element>
          <element name="init">
            <ref name="Constant.pat"/>
          </element>
          <element name="zero">
            <empty/>
          </element>
        </choice>
      </optional>
      <optional>
        <attribute name="linkage">
          <ref name="Linkage.type"/>
        </attribute>
      </optional>
      <ref name="Variable.ext"/>
    </element>
  </define>

  <define name="Linkage.type">
    <choice>
      <value>appending</value>
      <value>external</value>
      <value>internal</value>
      <value>linkonce</value>
      <value>weak</value>
    </choice>
  </define>

  <define name="Variable.ext" combine="choice"><empty/></define>

  <!--PATTERNS FOR FUNCTIONS -->

  <define name="Function.elem">
    <element name="Function">
      <ref name="Named_Typed_Element.pat"/>
      <optional>
        <attribute name="symbol"><ref name="Identifier.type"/></attribute>
      </optional>
      <optional>
        <attribute name="linkage"><ref name="Linkage.type"/></attribute>
      </optional>
      <zeroOrMore>
        <element name="var">
          <ref name="Named_Typed_Element.pat"/>
          <optional>
            <attribute name="gc">
              <ref name="Boolean.type"/>
            </attribute>
          </optional>
        </element>
      </zeroOrMore>
      <zeroOrMore>
        <ref name="Block.elem"/>
      </zeroOrMore>
      <ref name="Function.ext"/>
    </element>
  </define>

  <define name="Block.elem">
    <element name="block">
      <optional>
        <attribute name="label"><ref name="Identifier.type"/></attribute>
      </optional>
      <zeroOrMore>
        <choice>
          <ref name="Binary_Operators.pat"/>
          <ref name="Bitwise_Operators.pat"/>
          <ref name="Memory_Accessors.pat"/>
          <ref name="Other_Instructions.pat"/>
        </choice>
      </zeroOrMore>
      <ref name="Terminators.pat"/>
    </element>
  </define>

  <define name="Function.ext" combine="choice"><empty/></define>

  <!-- PATTERNS FOR INSTRUCTIONS -->

  <define name="Binary_Operators.pat">
    <choice>
      <ref name="Add.elem"/>
      <ref name="Subtract.elem"/>
      <ref name="Multiply.elem"/>
      <ref name="Divide.elem"/>
      <ref name="Remainder.elem"/>
      <ref name="Equal.elem"/>
      <ref name="NotEqual.elem"/>
      <ref name="GreaterThan.elem"/>
      <ref name="GreaterEqual.elem"/>
      <ref name="LessThan.elem"/>
      <ref name="LessEqual.elem"/>
    </choice>
  </define>

  <define name="Bitwise_Operators.pat">
    <choice>
      <ref name="And.elem"/>
      <ref name="Or.elem"/>
      <ref name="Xor.elem"/>
      <ref name="ShiftLeft.elem"/>
      <ref name="ShiftRight.elem"/>
    </choice>
  </define>

  <define name="Memory_Accessors.pat">
    <choice>
      <ref name="Get.elem"/>
      <ref name="Put.elem"/>
      <ref name="Alloca.elem"/>
      <ref name="Malloc.elem"/>
      <ref name="Free.elem"/>
      <ref name="Index.elem"/>
    </choice>
  </define>

  <define name="Other_Instructions.pat">
    <choice>
      <ref name="Cast.elem"/>
      <ref name="Select.elem"/>
      <ref name="Call.elem"/>
      <ref name="VA_Arg.elem"/>
    </choice>
  </define>

  <define name="Terminators.pat">
    <choice>
      <ref name="Return.elem"/>
      <ref name="Branch.elem"/>
      <ref name="Switch.elem"/>
      <ref name="Invoke.elem"/>
      <ref name="Unwind.elem"/>
      <ref name="Unreachable.elem"/>
    </choice>
  </define>

  <define name="Return.elem">
    <element name="ret">
      <optional>
        <ref name="Value.pat"/>
      </optional>
    </element>
  </define>

  <define name="Branch.elem">
    <element name="br">
      <choice>
        <group>
          <attribute name="to"><ref name="Identifier.type"/></attribute>
          <empty/>
        </group>
        <group>
          <attribute name="then"><ref name="Identifier.type"/></attribute>
          <attribute name="else"><ref name="Identifier.type"/></attribute>
          <ref name="Value.pat"/>
        </group>
      </choice>
    </element>
  </define>

  <define name="Switch.elem">
    <element name="switch">
      <attribute name="default"><ref name="Identifier.type"/></attribute>
      <element name="on"><ref name="Value.pat"/></element>
      <zeroOrMore>
        <element name="jump">
          <attribute name="to"><ref name="Identifier.type"/></attribute>
          <ref name="Value.pat"/>
        </element>
      </zeroOrMore>
    </element>
  </define>

  <define name="Invoke.elem">
    <element name="invoke">
      <attribute name="var"><ref name="Identifier.type"/></attribute>
      <attribute name="to"><ref name="Identifier.type"/></attribute>
      <attribute name="except"><ref name="Identifier.type"/></attribute>
      <ref name="Value.pat"/>
      <zeroOrMore>
        <ref name="Value.pat"/>
      </zeroOrMore>
    </element>
  </define>

  <define name="Unwind.elem">
    <element name="unwind"><empty/></element>
  </define>

  <define name="Unreachable.elem">
    <element name="unreachable"><empty/></element>
  </define>

  <define name="Binary_Operator.pat">
    <ref name="Value.pat"/>
    <ref name="Value.pat"/>
  </define>

  <define name="Add.elem">
    <element name="add"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="Subtract.elem">
    <element name="sub"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="Multiply.elem">
    <element name="mul"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="Divide.elem">
    <element name="div"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="Remainder.elem">
    <element name="rem"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="Equal.elem">
    <element name="eq"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="NotEqual.elem">
    <element name="ne"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="GreaterThan.elem">
    <element name="gt"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="GreaterEqual.elem">
    <element name="ge"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="LessThan.elem">
    <element name="lt"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="LessEqual.elem">
    <element name="le"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="And.elem">
    <element name="and"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="Or.elem">
    <element name="or"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="Xor.elem">
    <element name="xor"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="ShiftLeft.elem">
    <element name="shl"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="ShiftRight.elem">
    <element name="shr"><ref name="Binary_Operator.pat"/></element>
  </define>

  <define name="Get.elem">
    <element name="get">
      <ref name="Value.pat"/>
      <optional>
        <attribute name="volatile">
          <ref name="Boolean.type"/>
        </attribute>
      </optional>
      <optional>
        <element name="gc">
          <ref name="Value.pat"/>
        </element>
      </optional>
    </element>
  </define>

  <define name="Put.elem">
    <element name="put">
      <ref name="Value.pat"/>
      <ref name="Value.pat"/>
      <optional>
        <attribute name="volatile"><ref name="Boolean.type"/></attribute>
      </optional>
      <optional>
        <element name="gc">
          <ref name="Value.pat"/>
        </element>
      </optional>
    </element>
  </define>

  <define name="Alloca.elem">
    <element name="alloca">
      <ref name="Typed_Element.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="Malloc.elem">
    <element name="malloc">
      <ref name="Typed_Element.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="Free.elem">
    <element name="free">
      <ref name="Value.pat"/>
      <optional>
        <attribute name="gc">
          <ref name="Boolean.type"/>
        </attribute>
      </optional>
    </element>
  </define>

  <define name="Index.elem">
    <element name="index">
      <ref name="Value.pat"/>
      <zeroOrMore>
        <choice>
          <element name="idx"><ref name="Value.pat"/></element>
          <element name="fld"><ref name="Named_Element.pat"/></element>
        </choice>
      </zeroOrMore>
    </element>
  </define>

  <define name="Cast.elem">
    <element name="cast">
      <ref name="Value.pat"/>
      <attribute name="to"><ref name="Identifier.type"/></attribute>
    </element>
  </define>

  <define name="Select.elem">
    <element name="select">
      <ref name="Value.pat"/>
      <ref name="Value.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="Call.elem">
    <element name="call">
      <ref name="Value.pat"/>
      <zeroOrMore>
        <ref name="Value.pat"/>
      </zeroOrMore>
    </element>
  </define>

  <define name="VA_Arg.elem">
    <element name="va_arg">
      <ref name="Typed_Element.pat"/>
      <ref name="Value.pat"/>
    </element>
  </define>

  <define name="Value.pat">
    <choice>
      <ref name="Binary_Operators.pat"/>
      <ref name="Bitwise_Operators.pat"/>
      <ref name="Constant.pat"/>
      <ref name="Invoke.elem"/>
      <ref name="Get.elem"/>
      <ref name="Alloca.elem"/>
      <ref name="Malloc.elem"/>
      <ref name="Index.elem"/>
      <ref name="Cast.elem"/>
      <ref name="Select.elem"/>
      <ref name="Call.elem"/>
      <ref name="VA_Arg.elem"/>
    </choice>
  </define>

  <define name="Constant.pat">
    <choice>
      <ref name="Reference.elem"/>
      <ref name="Literal.pat"/>
      <ref name="Cast.elem"/>
      <ref name="Index.elem"/>
      <ref name="Binary_Operators.pat"/>
      <ref name="Bitwise_Operators.pat"/>
    </choice>
  </define>

  <define name="Reference.elem">
    <element name="ref">
      <ref name="Named_Element.pat"/>
      <empty/>
    </element>
  </define>

  <!-- PATTERNS FOR LITERAL CONSTANTS -->

  <define name="Literal.pat">
    <choice>
      <ref name="Binary_Literal.elem"/>
      <ref name="Octal_Literal.elem"/>
      <ref name="Decimal_Literal.elem"/>
      <ref name="Hexadecimal_Literal.elem"/>
      <ref name="Boolean_Literal.elem"/>
      <ref name="Character_Literal.elem"/>
      <ref name="Real_Literal.elem"/>
      <ref name="Text_Literal.elem"/>
      <ref name="Null_Literal.elem"/>
      <ref name="Array_Literal.elem"/>
      <ref name="Vector_Literal.elem"/>
      <ref name="Aggregate_Literal.elem"/>
    </choice>
  </define>

  <define name="Typed_Literal.pat">
    <optional>
      <attribute name="type"><ref name="Identifier.type"/></attribute>
    </optional>
  </define>

  <define name="Binary_Literal.elem">
    <element name="bin">
      <ref name="Typed_Literal.pat"/>
      <ref name="Binary.type"/>
    </element>
  </define>

  <define name="Binary.type">
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">[01]+</param>
    </data>
  </define>

  <define name="Octal_Literal.elem">
    <element name="oct">
      <ref name="Typed_Literal.pat"/>
      <ref name="Octal.type"/>
    </element>
  </define>

  <define name="Octal.type" >
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">[0-7]+</param>
    </data>
  </define>

  <define name="Decimal_Literal.elem">
    <element name="dec">
      <ref name="Typed_Literal.pat"/>
      <ref name="Decimal.type"/>
    </element>
  </define>

  <define name="Decimal.type">
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">[+\-]?\d+</param>
    </data>
  </define>

  <define name="Hexadecimal_Literal.elem">
    <element name="hex">
      <ref name="Typed_Literal.pat"/>
      <ref name="Hexadecimal.type"/>
    </element>
  </define>

  <define name="Hexadecimal.type">
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">([0-9A-Fa-f][0-9A-Fa-f])+</param>
    </data>
  </define>

  <define name="Boolean_Literal.elem">
    <choice>
      <element name="true"><empty/></element>
      <element name="false"><empty/></element>
    </choice>
  </define>

  <define name="Character_Literal.elem">
    <element name="char"><ref name="Character.type"/></element>
  </define>

  <define name="Character.type">
    <choice>
      <data type="string"><param name="length">1</param></data>
      <data type="string">
        <param name="length">5</param>
        <param name="pattern">[#][0-9A-Fa-f]{4,4}</param>
      </data>
    </choice>
  </define>

  <define name="Real_Literal.elem">
    <choice>
      <element name="flt"><ref name="Real.type"/></element>
      <element name="dbl"><ref name="Real.type"/></element>
    </choice>
  </define>

  <define name="Real.type">
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">ninf|pinf|nan|signan|zero|nzero|[+\-]?0x[0-9A-Fa-f](\.[0-9A-Fa-f]+)?p[-+][0-9]+|#[0-9A-Fa-f]{16}|#[0-9a-fA-F]{8}|[+\-]?\d+\.\d*([Ee][+\-]?\d+)?</param>
    </data>
  </define>

  <define name="Text_Literal.elem">
    <element name="text"><text/></element>
  </define>

  <define name="Null_Literal.elem">
    <element name="null"><empty/></element>
  </define>

  <define name="Array_Literal.elem">
    <element name="array">
      <ref name="Typed_Element.pat"/>
      <oneOrMore>
        <ref name="Constant.pat"/>
      </oneOrMore>
    </element>
  </define>

  <define name="Vector_Literal.elem">
    <element name="vector">
      <ref name="Typed_Element.pat"/>
      <oneOrMore>
        <ref name="Constant.pat"/>
      </oneOrMore>
    </element>
  </define>

  <define name="Aggregate_Literal.elem">
    <element name="aggregate">
      <ref name="Typed_Element.pat"/>
      <oneOrMore>
        <ref name="Constant.pat"/>
      </oneOrMore>
    </element>
  </define>
</grammar>
