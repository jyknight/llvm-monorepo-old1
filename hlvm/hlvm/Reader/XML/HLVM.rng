<?xml version="1.0" encoding="UTF-8"?>
<!--=========================================================================-->
<!-- Copyright (C) 2006 Reid Spencer. All Rights Reserved.                   -->
<!--                                                                         -->
<!-- This software is free software; you can redistribute it and/or modify it-->
<!-- under the terms of the GNU Lesser General Public License as published by-->
<!-- the Free Software Foundation; either version 2.1 of the License, or (at -->
<!-- your option) any later version.                                         -->
<!--                                                                         -->
<!-- This software is distributed in the hope that it will be useful, but    -->
<!-- WITHOUT ANY WARRANTY; without even the implied warranty of              -->
<!-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser-->
<!-- General Public License for more details.                                -->
<!--                                                                         -->
<!-- You should have received a copy of the GNU Lesser General Public License-->
<!-- along with this library in the file named LICENSE.txt; if not, write to -->
<!-- the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,    -->
<!-- Boston, MA 02110-1301 USA                                               -->
<!--                                                                         -->
<!--=========================================================================-->
<!-- @file hlvm/Reader/XML/HLVM.rng                                          -->
<!-- @author Reid Spencer <rspencer@reidspencer.com> (original author)       -->
<!-- @date 2006/05/13                                                        -->
<!-- @since 0.1.0                                                            -->
<!-- @brief Defines the core XPL language via Relax/NG Schema                -->
<!--=========================================================================-->
<!-- HLVM AST Schema                                                         -->
<!--                                                                         -->
<!-- This file contains the Relax/NG schema for construction of the HLVM AST -->
<!-- via an XML syntax. The schema aims to be simple and closely match the   -->
<!-- construction of an HLVM AST.                                            -->
<!--                                                                         -->
<!-- For full commentary on this schema, see http://hlvm.org/docs/XML.html   -->
<!--                                                                         -->
<!--=========================================================================-->

<grammar 
  datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
  xmlns ="http://relaxng.org/ns/structure/1.0"
  xmlns:a="http://relaxng.org/ns/annotation/1.0"
  ns="http://hlvm.org/src/hlvm/Reader/XML/HLVM.rng">

  <start>
    <ref name="HLVM.elem"/>
  </start>

  <!-- PATTERN DEFINITIONS FOR DATA TYPES -->

  <define name="Identifier.type">
    <choice>
      <ref name="Unprefixed_Identifier.type"/>
      <ref name="Prefixed_Identifier.type"/>
    </choice>
  </define>

  <define name="Unprefixed_Identifier.type">
    <data type="string">
      <param name="pattern">[^:]+</param>
      <param name="maxLength">1024</param>
    </data>
  </define>

  <define name="Prefixed_Identifier.type">
    <data type="string">
      <param name="pattern">[^:]+:[^:]+</param>
      <param name="maxLength">1024</param>
    </data>
  </define>

  <define name="Boolean.type">
    <choice>
      <data type="boolean"/>
      <value>TRUE</value>
      <value>True</value>
      <value>yes</value>
      <value>Yes</value>
      <value>YES</value>
      <value>1</value>
      <value>FALSE</value>
      <value>False</value>
      <value>no</value>
      <value>No</value>
      <value>NO</value>
      <value>0</value>
    </choice>
  </define>

  <!-- DOCUMENTATION OF HLVM AST PROGRAMS -->

  <define name="Documentation.pat">
    <optional>
      <element name="doc">
        <zeroOrMore>
          <choice>
            <text/>
            <ref name="Any.pat"/> <!-- should really be XHTML elements -->
          </choice>
        </zeroOrMore>
      </element>
    </optional>
  </define>

  <define name="Any.pat">
    <element>
      <anyName/>
      <zeroOrMore>
        <choice>
          <attribute>
            <anyName/>
          </attribute>
          <text/>
          <ref name="Any.pat"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>

  <!-- PATTERNS THAT DEFINE name AND type ATTRIBUTES -->

  <define name="Named_Element.pat">
    <ref name="Documentation.pat"/>
    <attribute name="name">
      <ref name="Identifier.type"/>
    </attribute>
  </define>

  <define name="Typed_Element.pat">
    <ref name="Documentation.pat"/>
    <attribute name="type">
      <ref name="Identifier.type"/>
    </attribute>
  </define>

  <define name="Named_Typed_Element.pat">
    <ref name="Documentation.pat"/>
    <attribute name="name">
      <ref name="Identifier.type"/>
    </attribute>
    <attribute name="type">
      <ref name="Identifier.type"/>
    </attribute>
  </define>

  <!-- HLVM PATTERN -->
  <define name="HLVM.elem">
    <element name="hlvm">
      <ref name="Bundle.elem"/>
    </element>
  </define>

  <!--BUNDLES PATTERN -->

  <define name="Bundle.elem">
    <element name="bundle">
      <ref name="bundle.pat"/>
    </element>
  </define>

  <define name="bundle.pat">
    <attribute name="pubid"><data type="anyURI"/></attribute>
    <ref name="Documentation.pat"/>
    <optional>
      <zeroOrMore>
        <ref name="import.elem"/>
      </zeroOrMore>
    </optional>
    <zeroOrMore>
      <choice>
        <ref name="Bundle.elem"/>
        <ref name="Function.elem"/>
        <ref name="Type.pat"/>
        <ref name="Variable.elem"/>
      </choice>
    </zeroOrMore>
  </define>

  <define name="import.elem">
    <element name="import">
      <ref name="Documentation.pat"/>
      <attribute name="prefix">
        <ref name="Identifier.type"/>
      </attribute>
      <attribute name="pubid">
        <data type="anyURI"/>
      </attribute>
    </element>
  </define>

  <!--PATTERNS FOR DEFINING TYPES -->

  <define name="Type.pat">
    <choice>
      <ref name="Alias.elem"/>
      <ref name="Atom.elem"/>
      <ref name="Enumeration.elem"/>
      <ref name="Pointer.elem"/>
      <ref name="Array.elem"/>
      <ref name="Vector.elem"/>
      <ref name="Structure.elem"/>
      <ref name="Signature.elem"/>
    </choice>
  </define>

  <define name="Alias.elem">
    <element name="alias">
      <ref name="Named_Element.pat"/>
      <attribute name="renames"><ref name="Identifier.type"/></attribute>
    </element>
  </define>

  <define name="Intrinsic.elem">
    <element name="intrinsic">
      <attribute name="is">
        <ref name="Intrinsic_Atoms.type"/>
      </attribute>
    </element>
  </define>

  <define name="Signed.elem">
    <element name="signed">
      <attribute name="bits">
        <ref name="Integer.type"/>
      </attribute>
    </element>
  </define>

  <define name="Unsigned.elem">
    <element name="unsigned">
      <attribute name="bits">
        <ref name="Integer.type"/>
      </attribute>
    </element>
  </define>

  <define name="Range.elem">
    <element name="range">
      <attribute name="min">
        <ref name="Integer.type"/>
      </attribute>
      <attribute name="max">
        <ref name="Integer.type"/>
      </attribute>
    </element>
  </define>

  <define name="Real.elem">
    <element name="real">
      <attribute name="precision">
        <ref name="Integer.type"/>
      </attribute>
    </element>
  </define>

  <define name="Atom.elem">
    <element name="atom">
      <ref name="Named_Element.pat"/>
      <choice>
        <ref name="Intrinsic.elem"/>
        <ref name="Signed.elem"/>
        <ref name="Unsigned.elem"/>
        <ref name="Range.elem"/>
        <ref name="Real.elem"/>
      </choice>
    </element>
  </define>

  <define name="Intrinsic_Atoms.type">
    <choice>
      <value>any</value>
      <value>bool</value>
      <value>char</value>
      <value>f32</value>
      <value>f43</value>
      <value>f64</value>
      <value>f80</value>
      <value>f128</value>
      <value>octet</value>
      <value>s8</value>
      <value>s16</value>
      <value>s32</value>
      <value>s64</value>
      <value>s128</value>
      <value>u8</value>
      <value>u16</value>
      <value>u32</value>
      <value>u64</value>
      <value>u128</value>
      <value>void</value>
    </choice>
  </define>

  <define name="Enumeration.elem">
    <element name="enum">
      <ref name="Named_Element.pat"/>
      <oneOrMore>
        <element name="value">
          <ref name="Named_Element.pat"/>
          <ref name="IntegerLiteral.pat"/>
        </element>
      </oneOrMore>
    </element>
  </define>

  <define name="Pointer.elem">
    <element name="pointer">
      <ref name="Named_Element.pat"/>
      <attribute name="to"><ref name="Identifier.type"/></attribute>
    </element>
  </define>

  <define name="Vector.elem">
    <element name="vector">
      <ref name="Named_Element.pat"/>
      <attribute name="length"><data type="nonNegativeInteger"/></attribute>
      <attribute name="of">
        <ref name="Intrinsic_Atoms.type"/>
      </attribute>
    </element>
  </define>

  <define name="Array.elem">
    <element name="array">
      <ref name="Named_Element.pat"/>
      <attribute name="length"><data type="nonNegativeInteger"/></attribute>
      <attribute name="of"><ref name="Identifier.type"/></attribute>
    </element>
  </define>

  <define name="Structure.elem">
    <element name="structure">
      <ref name="Named_Element.pat"/>
      <zeroOrMore>
        <element name="field">
          <ref name="Named_Typed_Element.pat"/>
        </element>
      </zeroOrMore>
    </element>
  </define>

  <define name="Signature.elem">
    <element name="signature">
      <ref name="Named_Element.pat"/>
      <attribute name="result"><ref name="Identifier.type"/></attribute>
      <optional>
        <attribute name="varargs"><ref name="Boolean.type"/></attribute>
      </optional>
      <zeroOrMore>
        <element name="arg">
          <ref name="Named_Typed_Element.pat"/>
        </element>
      </zeroOrMore>
    </element>
  </define>

  <define name="Opaque.elem">
    <element name="opaque">
      <ref name="Named_Element.pat"/>
      <empty/>
    </element>
  </define>

  <!--PATTERNS FOR VARIABLES-->

  <define name="Variable.elem">
    <element name="var">
      <ref name="Named_Typed_Element.pat"/>
      <optional>
        <choice>
          <element name="const">
            <ref name="Constant.pat"/>
          </element>
          <element name="init">
            <ref name="Constant.pat"/>
          </element>
          <element name="zero">
            <empty/>
          </element>
        </choice>
      </optional>
      <optional>
        <attribute name="linkage">
          <ref name="Linkage.type"/>
        </attribute>
      </optional>
    </element>
  </define>

  <define name="Linkage.type">
    <choice>
      <value>appending</value>
      <value>external</value>
      <value>internal</value>
      <value>linkonce</value>
      <value>weak</value>
    </choice>
  </define>

  <!--PATTERNS FOR FUNCTIONS -->

  <define name="Function.elem">
    <element name="function">
      <ref name="Named_Typed_Element.pat"/>
      <optional>
        <attribute name="symbol"><ref name="Identifier.type"/></attribute>
      </optional>
      <optional>
        <attribute name="linkage"><ref name="Linkage.type"/></attribute>
      </optional>
      <zeroOrMore>
        <element name="var">
          <ref name="Named_Typed_Element.pat"/>
        </element>
      </zeroOrMore>
      <zeroOrMore>
        <ref name="Block.elem"/>
      </zeroOrMore>
    </element>
  </define>

  <define name="Block.elem">
    <element name="block">
      <optional>
        <attribute name="label"><ref name="Identifier.type"/></attribute>
      </optional>
    </element>
  </define>

  <define name="Constant.pat">
    <choice>
      <ref name="Reference.elem"/>
      <ref name="Literal.pat"/>
    </choice>
  </define>

  <define name="Reference.elem">
    <element name="ref">
      <ref name="Named_Element.pat"/>
      <empty/>
    </element>
  </define>

  <!-- PATTERNS FOR LITERAL CONSTANTS -->

  <define name="Literal.pat">
    <choice>
      <ref name="IntegerLiteral.pat"/>
      <ref name="Boolean_Literal.elem"/>
      <ref name="Character_Literal.elem"/>
      <ref name="Real_Literal.elem"/>
      <ref name="Text_Literal.elem"/>
      <ref name="Null_Literal.elem"/>
      <ref name="Array_Literal.elem"/>
      <ref name="Vector_Literal.elem"/>
      <ref name="Aggregate_Literal.elem"/>
    </choice>
  </define>

  <define name="IntegerLiteral.pat">
    <choice>
      <ref name="Binary_Literal.elem"/>
      <ref name="Octal_Literal.elem"/>
      <ref name="Decimal_Literal.elem"/>
      <ref name="Hexadecimal_Literal.elem"/>
    </choice>
  </define>

  <define name="Integer.type">
    <choice>
      <ref name="Binary.type"/>
      <ref name="Octal.type"/>
      <ref name="Decimal.type"/>
      <ref name="Hexadecimal.type"/>
    </choice>
  </define>

  <define name="Typed_Literal.pat">
    <optional>
      <attribute name="type"><ref name="Identifier.type"/></attribute>
    </optional>
  </define>

  <define name="Binary_Literal.elem">
    <element name="bin">
      <ref name="Typed_Literal.pat"/>
      <ref name="Binary.type"/>
    </element>
  </define>

  <define name="Binary.type">
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">[01]+</param>
    </data>
  </define>

  <define name="Octal_Literal.elem">
    <element name="oct">
      <ref name="Typed_Literal.pat"/>
      <ref name="Octal.type"/>
    </element>
  </define>

  <define name="Octal.type" >
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">[0-7]+</param>
    </data>
  </define>

  <define name="Decimal_Literal.elem">
    <element name="dec">
      <ref name="Typed_Literal.pat"/>
      <ref name="Decimal.type"/>
    </element>
  </define>

  <define name="Decimal.type">
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">[+\-]?\d+</param>
    </data>
  </define>

  <define name="Hexadecimal_Literal.elem">
    <element name="hex">
      <ref name="Typed_Literal.pat"/>
      <ref name="Hexadecimal.type"/>
    </element>
  </define>

  <define name="Hexadecimal.type">
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">([0-9A-Fa-f][0-9A-Fa-f])+</param>
    </data>
  </define>

  <define name="Boolean_Literal.elem">
    <choice>
      <element name="true"><empty/></element>
      <element name="false"><empty/></element>
    </choice>
  </define>

  <define name="Character_Literal.elem">
    <element name="char"><ref name="Character.type"/></element>
  </define>

  <define name="Character.type">
    <choice>
      <data type="string"><param name="length">1</param></data>
      <data type="string">
        <param name="length">5</param>
        <param name="pattern">[#][0-9A-Fa-f]{4,4}</param>
      </data>
    </choice>
  </define>

  <define name="Real_Literal.elem">
    <choice>
      <element name="flt"><ref name="Real.type"/></element>
      <element name="dbl"><ref name="Real.type"/></element>
    </choice>
  </define>

  <define name="Real.type">
    <data type="string">
      <param name="minLength">1</param>
      <param name="maxLength">1024</param>
      <param name="pattern">ninf|pinf|nan|signan|zero|nzero|[+\-]?0x[0-9A-Fa-f](\.[0-9A-Fa-f]+)?p[-+][0-9]+|#[0-9A-Fa-f]{16}|#[0-9a-fA-F]{8}|[+\-]?\d+\.\d*([Ee][+\-]?\d+)?</param>
    </data>
  </define>

  <define name="Text_Literal.elem">
    <element name="text"><text/></element>
  </define>

  <define name="Null_Literal.elem">
    <element name="null"><empty/></element>
  </define>

  <define name="Array_Literal.elem">
    <element name="array">
      <ref name="Typed_Element.pat"/>
      <oneOrMore>
        <ref name="Constant.pat"/>
      </oneOrMore>
    </element>
  </define>

  <define name="Vector_Literal.elem">
    <element name="vector">
      <ref name="Typed_Element.pat"/>
      <oneOrMore>
        <ref name="Constant.pat"/>
      </oneOrMore>
    </element>
  </define>

  <define name="Aggregate_Literal.elem">
    <element name="aggregate">
      <ref name="Typed_Element.pat"/>
      <oneOrMore>
        <ref name="Constant.pat"/>
      </oneOrMore>
    </element>
  </define>
</grammar>
